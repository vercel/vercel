#!/usr/bin/env python3
"""Slideshow viewer for demo notes. Splits on --- and navigates with arrow keys."""
import os
import re
import subprocess
import sys
import termios
import threading
import tty
from pathlib import Path

NOTES = Path(__file__).resolve().parent / "notes.md"


def get_width():
    """Get terminal width, fallback to 120."""
    try:
        return os.get_terminal_size().columns
    except OSError:
        return 120

GREEN = "\033[0;32m"
DIM = "\033[2m"
NC = "\033[0m"


def parse_slides(filepath):
    """Split markdown on --- separators into slides."""
    content = Path(filepath).read_text()
    # Split on lines that are just ---
    slides = re.split(r"\n---\n", content)
    # Strip leading/trailing whitespace from each slide
    return [s.strip() for s in slides if s.strip()]


WHITE = "\033[1;37m"           # bold white — spoken text
CMD_HIGHLIGHT = "\033[1;97;41m"  # bold bright white on red background
ITALIC = "\033[3m"             # ANSI italic code
ITALIC_RE = re.compile(r"\033\[;?3m")  # glow's italic marker

def render_slide(text):
    """Render a markdown slide using glow, then post-process for readability.

    - RUN commands: red background highlight
    - Italic lines (stage directions): left as-is (dim/italic from glow)
    - Everything else (spoken text): boosted to bold white
    """
    result = subprocess.run(
        ["glow", "-s", "dark", "-w", str(get_width()), "-"],
        input=text,
        capture_output=True,
        text=True,
    )
    lines = result.stdout.split("\n")
    highlighted = []
    for line in lines:
        stripped = re.sub(r"\033\[[0-9;]*m", "", line)
        if "RUN" in stripped and ("vc " in stripped or "vercel " in stripped):
            highlighted.append(f"{CMD_HIGHLIGHT}{stripped}{NC}")
        elif ITALIC_RE.search(line):
            # Stage direction — leave glow's italic styling as-is
            highlighted.append(line)
        elif stripped.strip():
            # Non-empty, non-italic line — boost to white
            highlighted.append(f"{WHITE}{line}{NC}")
        else:
            highlighted.append(line)
    return "\n".join(highlighted)


def get_key():
    """Read a single keypress (handles arrow keys)."""
    fd = sys.stdin.fileno()
    old = termios.tcgetattr(fd)
    try:
        tty.setraw(fd)
        b = os.read(fd, 1)
        if b == b"\x1b":
            b2 = os.read(fd, 1)
            if b2 == b"[":
                b3 = os.read(fd, 1)
                if b3 == b"C":
                    return "right"
                elif b3 == b"D":
                    return "left"
                elif b3 == b"B":
                    return "right"
                elif b3 == b"A":
                    return "left"
            return "esc"
        return b.decode("utf-8", errors="replace")
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old)


def watch_file(filepath, callback):
    """Watch a file for changes in a background thread."""
    def _watch():
        while True:
            subprocess.run(
                ["fswatch", "-1", str(filepath)],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
            )
            callback()

    t = threading.Thread(target=_watch, daemon=True)
    t.start()


def clear():
    sys.stdout.write("\033[2J\033[H")
    sys.stdout.flush()


def main():
    target = sys.argv[1] if len(sys.argv) > 1 else str(NOTES)
    slides = parse_slides(target)
    idx = 0
    needs_redraw = True

    def on_file_change():
        nonlocal slides, idx, needs_redraw
        slides = parse_slides(target)
        if idx >= len(slides):
            idx = len(slides) - 1
        needs_redraw = True

    watch_file(target, on_file_change)

    # Pre-render all slides
    rendered = [render_slide(s) for s in slides]

    while True:
        if needs_redraw:
            # Re-render if slides changed
            rendered = [render_slide(s) for s in slides]
            needs_redraw = False

        clear()
        if rendered:
            sys.stdout.write(rendered[idx])
        # Status bar
        sys.stdout.write(
            f"\n{DIM}{'─' * get_width()}{NC}\n"
            f"{GREEN}  Slide {idx + 1}/{len(slides)}{NC}  "
            f"{DIM}← → navigate  r refresh  q quit{NC}\n"
        )
        sys.stdout.flush()

        key = get_key()

        if key in ("q", "\x03"):  # q or ctrl-c
            clear()
            break
        elif key in ("right", "j", "l", " ", "n"):
            if idx < len(slides) - 1:
                idx += 1
        elif key in ("left", "h", "k", "p"):
            if idx > 0:
                idx -= 1
        elif key == "g":
            idx = 0
        elif key == "G":
            idx = len(slides) - 1
        elif key == "r":
            slides = parse_slides(target)
            rendered = [render_slide(s) for s in slides]
            if idx >= len(slides):
                idx = len(slides) - 1
            # Flash confirmation
            clear()
            sys.stdout.write(rendered[idx])
            sys.stdout.write(
                f"\n{DIM}{'─' * get_width()}{NC}\n"
                f"{GREEN}  Slide {idx + 1}/{len(slides)}  ✓ Refreshed{NC}\n"
            )
            sys.stdout.flush()
            import time; time.sleep(0.3)
        elif needs_redraw:
            # File changed, will redraw on next loop
            pass


if __name__ == "__main__":
    main()
