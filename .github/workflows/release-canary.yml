name: Release Canary

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to release from'
        required: true
        type: string

env:
  TURBO_REMOTE_ONLY: 'true'
  TURBO_TEAM: 'vercel'
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  # Resolve the branch and SHA before the approval gate so the approver
  # can see exactly what will be published in the workflow summary.
  resolve:
    name: Resolve Branch
    runs-on: ubuntu-latest
    outputs:
      sha: ${{ steps.resolve.outputs.sha }}
    steps:
      - name: Verify branch and resolve SHA
        id: resolve
        run: |
          SHA=$(git ls-remote --heads origin "${{ inputs.branch }}" | awk '{print $1}')
          if [ -z "$SHA" ]; then
            echo "::error::Branch '${{ inputs.branch }}' does not exist"
            exit 1
          fi
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"

      - name: Print release info
        run: |
          echo "## Canary Release" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| | |" >> "$GITHUB_STEP_SUMMARY"
          echo "|---|---|" >> "$GITHUB_STEP_SUMMARY"
          echo "| **Branch** | \`${{ inputs.branch }}\` |" >> "$GITHUB_STEP_SUMMARY"
          echo "| **SHA** | \`${{ steps.resolve.outputs.sha }}\` |" >> "$GITHUB_STEP_SUMMARY"

  # The "canary-release" environment must be configured in repo settings
  # with "vercel-cli-approvers" as a required reviewer. This is the only
  # way to gate a workflow_dispatch behind team approval in GitHub Actions.
  approve:
    name: Require Approval
    needs: resolve
    runs-on: ubuntu-latest
    environment: canary-release
    steps:
      - name: Approved
        run: echo "Releasing ${{ inputs.branch }} @ ${{ needs.resolve.outputs.sha }}"

  release-canary:
    name: Release Canary
    needs: [approve, resolve]
    runs-on: ubuntu-latest
    # Only contents: read is needed (release.yml uses contents: write because
    # changesets pushes commits/tags back to the repo).
    permissions:
      contents: read
      id-token: write
    steps:
      # Unlike release.yml, we use the default GITHUB_TOKEN and skip fetching
      # git tags. The custom token and tags are only needed for changesets to
      # push commits/tags back to the repo, which canary releases don't do.
      - name: Checkout Repo
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.resolve.outputs.sha }}

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # 2025-12-16
        with:
          toolchain: stable
          targets: wasm32-wasip2

      - name: install npm@9
        run: npm i -g npm@9

      - name: install pnpm@8.3.1
        run: npm i -g pnpm@8.3.1

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Build Packages
        run: pnpm build
        env:
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

      - name: Set Canary Versions
        run: |
          SHORT_SHA=$(echo "${{ needs.resolve.outputs.sha }}" | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          CANARY_SUFFIX="canary.${TIMESTAMP}.${SHORT_SHA}"

          # For each public package, bump to the next minor prerelease version.
          # e.g. 1.2.3 -> 1.3.0-canary.20260211120000.abc1234
          node -e "
            const fs = require('fs');
            const glob = require('glob');
            const pkgPaths = glob.sync('packages/*/package.json');
            for (const pkgPath of pkgPaths) {
              const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
              if (pkg.private) continue;
              const [major, minor] = pkg.version.split('.').map(Number);
              pkg.version = major + '.' + (minor + 1) + '.0-${CANARY_SUFFIX}';
              fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n');
              console.log(pkg.name + '@' + pkg.version);
            }
          "

      # Post-publish steps from release.yml (trigger update workflow, python
      # runtime release, update latest GitHub release) are intentionally omitted
      # since those are only relevant for production releases.
      - name: Publish Canary to npm
        run: pnpm publish -r --tag canary --no-git-checks
        env:
          NPM_CONFIG_PROVENANCE: 'true'
          NPM_TOKEN: ${{ secrets.NPM_TOKEN_ELEVATED }}
