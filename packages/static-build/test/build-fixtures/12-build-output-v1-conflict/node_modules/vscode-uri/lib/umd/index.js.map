{"version":3,"sources":["webpack://vscode-uri/webpack/universalModuleDefinition","webpack://vscode-uri/./node_modules/path-browserify/index.js","webpack://vscode-uri/./src/index.ts","webpack://vscode-uri/./src/platform.ts","webpack://vscode-uri/./src/uri.ts","webpack://vscode-uri/./src/utils.ts","webpack://vscode-uri/webpack/bootstrap","webpack://vscode-uri/webpack/startup"],"names":["root","factory","exports","module","define","amd","a","i","this","assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","arguments","undefined","process","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","base","name","_format","parse","ret","delimiter","win32","URI","Utils","isWindows","platform","navigator","userAgent","indexOf","_schemePattern","_singleSlashStart","_doubleSlashStart","_validateUri","_strict","scheme","Error","authority","query","fragment","test","_empty","_slash","_regexp","schemeOrData","_schemeFix","_referenceResolution","isUri","thing","fsPath","with","toString","uriToFsPath","change","Uri","value","match","exec","percentDecode","file","replace","idx","substring","components","result","skipEncoding","_asFormatted","toJSON","revive","data","_formatted","external","_fsPath","_sep","_pathSepMarker","$mid","encodeTable","encodeURIComponentFast","uriComponent","allowSlash","nativeEncodePos","pos","encodeURIComponent","charAt","substr","escaped","encodeURIComponentMinimal","uri","keepDriveLetterCasing","toLowerCase","encoder","userinfo","String","fromCharCode","decodeURIComponentGraceful","str","decodeURIComponent","_rEncodedAsHex","posixPath","nodePath","joinPath","paths","resolvePath","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn ","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { URI } from './uri';\nimport { Utils } from './utils';\n\nexport { URI, Utils }","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n// !!!!!\n// SEE https://github.com/microsoft/vscode/blob/master/src/vs/base/common/platform.ts\n// !!!!!\n\ndeclare const process: { platform: 'win32' };\ndeclare const navigator: { userAgent: string };\n\nexport let isWindows: boolean;\n\nif (typeof process === 'object') {\n\tisWindows = process.platform === 'win32';\n} else if (typeof navigator === 'object') {\n\tlet userAgent = navigator.userAgent;\n\tisWindows = userAgent.indexOf('Windows') >= 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { CharCode } from './charCode'\nimport { isWindows } from './platform';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\tstatic from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t\t_validateUri(result, true);\n\t\treturn result;\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn <any>data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\texternal: string;\n\tfsPath: string;\n\t_sep: 1 | undefined;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, allowSlash: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (allowSlash && code === CharCode.Slash)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.indexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport { CharCode } from './charCode';\nimport { URI } from './uri';\nimport * as nodePath from 'path';\n\nconst posixPath = nodePath.posix || nodePath;\n\nexport namespace Utils {\n\n    /**\n     * Joins one or more input paths to the path of URI. \n     * '/' is used as the directory separation character. \n     * \n     * The resolved path will be normalized. That means:\n     *  - all '..' and '.' segments are resolved.\n     *  - multiple, sequential occurences of '/' are replaced by a single instance of '/'.\n     *  - trailing separators are preserved.\n     * \n     * @param uri The input URI.\n     * @param paths The paths to be joined with the path of URI.\n     * @returns A URI with the joined path. All other properties of the URI (scheme, authority, query, fragments, ...) will be taken from the input URI.\n     */\n    export function joinPath(uri: URI, ...paths: string[]): URI {\n        return uri.with({ path: posixPath.join(uri.path, ...paths) });\n    }\n\n\n    /**\n     * Resolves one or more paths against the path of a URI. \n     * '/' is used as the directory separation character. \n     * \n     * The resolved path will be normalized. That means:\n     *  - all '..' and '.' segments are resolved. \n     *  - multiple, sequential occurences of '/' are replaced by a single instance of '/'.\n     *  - trailing separators are removed.\n     * \n     * @param uri The input URI.\n     * @param paths The paths to resolve against the path of URI.\n     * @returns A URI with the resolved path. All other properties of the URI (scheme, authority, query, fragments, ...) will be taken from the input URI.\n     */\n    export function resolvePath(uri: URI, ...paths: string[]): URI {\n        const path = uri.path || '/'; // normalize the path which is necessary as for posixPath.resolve the first segments has to be absolute or cwd is used.\n        return uri.with({ path: posixPath.resolve(path, ...paths) });\n    }\n\n    /**\n     * Returns a URI where the path is the directory name of the input uri, similar to the Unix dirname command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The orignal URI is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The last segment of the URIs path.\n     */\n    export function dirname(uri: URI): URI {\n        let path = posixPath.dirname(uri.path);\n        if (path.length === 1 && path.charCodeAt(0) === CharCode.Period) {\n            return uri;\n        }\n        return uri.with({ path });\n    }\n\n    /**\n     * Returns the last segment of the path of a URI, similar to the Unix basename command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The empty string is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The base name of the URIs path.\n     */\n    export function basename(uri: URI): string {\n        return posixPath.basename(uri.path);\n    }\n\n    /**\n     * Returns the extension name of the path of a URI, similar to the Unix extname command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The empty string is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The extension name of the URIs path.\n     */\n    export function extname(uri: URI): string {\n        return posixPath.extname(uri.path);\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(465);\n"],"sourceRoot":""}