"use strict";
var __create2 = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __getProtoOf2 = Object.getPrototypeOf;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps2 = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames2(from))
      if (!__hasOwnProp2.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
var require_bytes = __commonJS2({
  "../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format;
    module2.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/constants.js
var require_constants = __commonJS2({
  "../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var SEP = "/";
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR,
      SEP
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`,
      SEP: "\\"
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS2({
  "../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1) return input;
      if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
    exports2.basename = (path3, { windows } = {}) => {
      const segs = path3.split(windows ? /[\\/]/ : "/");
      const last = segs[segs.length - 1];
      if (last === "") {
        return segs[segs.length - 2];
      }
      return last;
    };
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS2({
  "../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA: CHAR_COMMA2,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS: CHAR_PLUS2,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA2) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS2 || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob2 = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob2 = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2) glob2 = utils.removeBackslashes(glob2);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/parse.js
var require_parse4 = __commonJS2({
  "../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants();
    var utils = require_utils4();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const PLATFORM_CHARS = constants.globChars(opts.windows);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.output = (prev.output || prev.value) + tok.value;
          prev.value += tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(opts.windows);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match) return;
            const source2 = create(match[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS2({
  "../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var scan = require_scan();
    var parse = require_parse4();
    var utils = require_utils4();
    var constants = require_constants();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob2, options, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = opts.windows;
      const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob: glob2, posix });
        const result = { glob: glob2, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob: glob2, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob2;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob2;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob2, options) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
      return regex.test(utils.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern)) return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// ../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS2({
  "../../node_modules/.pnpm/picomatch@4.0.1/node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    var pico = require_picomatch();
    var isWindows = () => {
      if (typeof navigator !== "undefined" && navigator.platform) {
        const platform = navigator.platform.toLowerCase();
        return platform === "win32" || platform === "windows";
      }
      if (typeof process !== "undefined" && process.platform) {
        return process.platform === "win32";
      }
      return false;
    };
    function picomatch(glob2, options, returnState = false) {
      if (options && (options.windows === null || options.windows === void 0)) {
        options = { ...options, windows: isWindows() };
      }
      return pico(glob2, options, returnState);
    }
    Object.assign(picomatch, pico);
    module2.exports = picomatch;
  }
});

// ../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js
var require_universalify2 = __commonJS2({
  "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function") fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function") return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills2 = __commonJS2({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs4) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs4);
      }
      if (!fs4.lutimes) {
        patchLutimes(fs4);
      }
      fs4.chown = chownFix(fs4.chown);
      fs4.fchown = chownFix(fs4.fchown);
      fs4.lchown = chownFix(fs4.lchown);
      fs4.chmod = chmodFix(fs4.chmod);
      fs4.fchmod = chmodFix(fs4.fchmod);
      fs4.lchmod = chmodFix(fs4.lchmod);
      fs4.chownSync = chownFixSync(fs4.chownSync);
      fs4.fchownSync = chownFixSync(fs4.fchownSync);
      fs4.lchownSync = chownFixSync(fs4.lchownSync);
      fs4.chmodSync = chmodFixSync(fs4.chmodSync);
      fs4.fchmodSync = chmodFixSync(fs4.fchmodSync);
      fs4.lchmodSync = chmodFixSync(fs4.lchmodSync);
      fs4.stat = statFix(fs4.stat);
      fs4.fstat = statFix(fs4.fstat);
      fs4.lstat = statFix(fs4.lstat);
      fs4.statSync = statFixSync(fs4.statSync);
      fs4.fstatSync = statFixSync(fs4.fstatSync);
      fs4.lstatSync = statFixSync(fs4.lstatSync);
      if (fs4.chmod && !fs4.lchmod) {
        fs4.lchmod = function(path3, mode, cb) {
          if (cb) process.nextTick(cb);
        };
        fs4.lchmodSync = function() {
        };
      }
      if (fs4.chown && !fs4.lchown) {
        fs4.lchown = function(path3, uid, gid, cb) {
          if (cb) process.nextTick(cb);
        };
        fs4.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs4.rename = typeof fs4.rename !== "function" ? fs4.rename : (function(fs$rename) {
          function rename2(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs4.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb) cb(er);
            });
          }
          if (Object.setPrototypeOf) Object.setPrototypeOf(rename2, fs$rename);
          return rename2;
        })(fs4.rename);
      }
      fs4.read = typeof fs4.read !== "function" ? fs4.read : (function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs4, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs4, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
        return read;
      })(fs4.read);
      fs4.readSync = typeof fs4.readSync !== "function" ? fs4.readSync : /* @__PURE__ */ (function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs4, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      })(fs4.readSync);
      function patchLchmod(fs5) {
        fs5.lchmod = function(path3, mode, callback) {
          fs5.open(
            path3,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback) callback(err);
                return;
              }
              fs5.fchmod(fd, mode, function(err2) {
                fs5.close(fd, function(err22) {
                  if (callback) callback(err2 || err22);
                });
              });
            }
          );
        };
        fs5.lchmodSync = function(path3, mode) {
          var fd = fs5.openSync(path3, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs5.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs5.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs5.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs5) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs5.futimes) {
          fs5.lutimes = function(path3, at, mt, cb) {
            fs5.open(path3, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb) cb(er);
                return;
              }
              fs5.futimes(fd, at, mt, function(er2) {
                fs5.close(fd, function(er22) {
                  if (cb) cb(er2 || er22);
                });
              });
            });
          };
          fs5.lutimesSync = function(path3, at, mt) {
            var fd = fs5.openSync(path3, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs5.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs5.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs5.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs5.futimes) {
          fs5.lutimes = function(_a, _b, _c, cb) {
            if (cb) process.nextTick(cb);
          };
          fs5.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig) return orig;
        return function(target, mode, cb) {
          return orig.call(fs4, target, mode, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig) return orig;
        return function(target, mode) {
          try {
            return orig.call(fs4, target, mode);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig) return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs4, target, uid, gid, function(er) {
            if (chownErOk(er)) er = null;
            if (cb) cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig) return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs4, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er)) throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig) return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0) stats.uid += 4294967296;
              if (stats.gid < 0) stats.gid += 4294967296;
            }
            if (cb) cb.apply(this, arguments);
          }
          return options ? orig.call(fs4, target, options, callback) : orig.call(fs4, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig) return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs4, target, options) : orig.call(fs4, target);
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams2 = __commonJS2({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs4) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path3, options) {
        if (!(this instanceof ReadStream)) return new ReadStream(path3, options);
        Stream.call(this);
        var self2 = this;
        this.path = path3;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding) this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs4.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path3, options) {
        if (!(this instanceof WriteStream)) return new WriteStream(path3, options);
        Stream.call(this);
        this.path = path3;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs4.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone2 = __commonJS2({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy2 = { __proto__: getPrototypeOf(obj) };
      else
        var copy2 = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy2;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs2 = __commonJS2({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs4 = require("fs");
    var polyfills = require_polyfills2();
    var legacy = require_legacy_streams2();
    var clone = require_clone2();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug2 = noop;
    if (util.debuglog)
      debug2 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug2 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs4[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs4, queue);
      fs4.close = (function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs4, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      })(fs4.close);
      fs4.closeSync = (function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs4, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      })(fs4.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug2(fs4[gracefulQueue]);
          require("assert").equal(fs4[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs4[gracefulQueue]);
    }
    module2.exports = patch(clone(fs4));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs4.__patched) {
      module2.exports = patch(fs4);
      fs4.__patched = true;
    }
    function patch(fs5) {
      polyfills(fs5);
      fs5.gracefulify = patch;
      fs5.createReadStream = createReadStream;
      fs5.createWriteStream = createWriteStream;
      var fs$readFile = fs5.readFile;
      fs5.readFile = readFile2;
      function readFile2(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path3, options, cb);
        function go$readFile(path4, options2, cb2, startTime) {
          return fs$readFile(path4, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path4, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs5.writeFile;
      fs5.writeFile = writeFile;
      function writeFile(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path3, data, options, cb);
        function go$writeFile(path4, data2, options2, cb2, startTime) {
          return fs$writeFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs5.appendFile;
      if (fs$appendFile)
        fs5.appendFile = appendFile;
      function appendFile(path3, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path3, data, options, cb);
        function go$appendFile(path4, data2, options2, cb2, startTime) {
          return fs$appendFile(path4, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path4, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs5.copyFile;
      if (fs$copyFile)
        fs5.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs5.readdir;
      fs5.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path3, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path4, options2, cb2, startTime) {
          return fs$readdir(path4, options2, fs$readdirCallback(
            path4,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path3, options, cb);
        function fs$readdirCallback(path4, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path4, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs5);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs5.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs5.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs5, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs5, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs5, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs5, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path3, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path3, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path3, options) {
        return new fs5.ReadStream(path3, options);
      }
      function createWriteStream(path3, options) {
        return new fs5.WriteStream(path3, options);
      }
      var fs$open = fs5.open;
      fs5.open = open;
      function open(path3, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path3, flags, mode, cb);
        function go$open(path4, flags2, mode2, cb2, startTime) {
          return fs$open(path4, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path4, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs5;
    }
    function enqueue(elem) {
      debug2("ENQUEUE", elem[0].name, elem[1]);
      fs4[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs4[gracefulQueue].length; ++i) {
        if (fs4[gracefulQueue][i].length > 2) {
          fs4[gracefulQueue][i][3] = now;
          fs4[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs4[gracefulQueue].length === 0)
        return;
      var elem = fs4[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug2("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug2("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug2("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs4[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/fs/index.js
var require_fs3 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify2().fromCallback;
    var fs4 = require_graceful_fs2();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs4[key] === "function";
    });
    Object.assign(exports2, fs4);
    api.forEach((method) => {
      exports2[method] = u(fs4[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs4.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs4.exists(filename, resolve);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs4.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs4.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs4.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs4.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports2.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs4.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs4.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports2.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs4.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs4.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err) return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs4.realpath.native === "function") {
      exports2.realpath.native = u(fs4.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils5 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
    "use strict";
    var path3 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path3.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs4 = require_fs3();
    var { checkPath } = require_utils5();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number") return options;
      return { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs4.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs4.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir2();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var fs4 = require_fs3();
    function pathExists(path3) {
      return fs4.access(path3).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs4.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs4 = require_fs3();
    var u = require_universalify2().fromPromise;
    async function utimesMillis(path3, atime, mtime2) {
      const fd = await fs4.open(path3, "r+");
      let closeErr = null;
      try {
        await fs4.futimes(fd, atime, mtime2);
      } finally {
        try {
          await fs4.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path3, atime, mtime2) {
      const fd = fs4.openSync(path3, "r+");
      fs4.futimesSync(fd, atime, mtime2);
      return fs4.closeSync(fd);
    }
    module2.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/stat.js
var require_stat2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs4 = require_fs3();
    var path3 = require("path");
    var u = require_universalify2().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs4.stat(file, { bigint: true }) : (file) => fs4.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT") return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs4.statSync(file, { bigint: true }) : (file) => fs4.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT") return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path3.basename(src);
          const destBaseName = path3.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path3.basename(src);
          const destBaseName = path3.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root) return;
      let destStat;
      try {
        destStat = await fs4.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path3.resolve(path3.dirname(src));
      const destParent = path3.resolve(path3.dirname(dest));
      if (destParent === srcParent || destParent === path3.parse(destParent).root) return;
      let destStat;
      try {
        destStat = fs4.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT") return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path3.resolve(src).split(path3.sep).filter((i) => i);
      const destArr = path3.resolve(dest).split(path3.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy3 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs4 = require_fs3();
    var path3 = require("path");
    var { mkdirs } = require_mkdirs2();
    var { pathExists } = require_path_exists2();
    var { utimesMillis } = require_utimes2();
    var stat = require_stat2();
    async function copy2(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
      await stat.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include) return;
      const destParent = path3.dirname(dest);
      const dirExists = await pathExists(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter) return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs4.stat : fs4.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs4.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs4.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs4.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs4.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs4.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs4.mkdir(dest);
      }
      const items = await fs4.readdir(src);
      await Promise.all(items.map(async (item) => {
        const srcItem = path3.join(src, item);
        const destItem = path3.join(dest, item);
        const include = await runFilter(srcItem, destItem, opts);
        if (!include) return;
        const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
        return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
      }));
      if (!destStat) {
        await fs4.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs4.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs4.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs4.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN") return fs4.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path3.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs4.unlink(dest);
      return fs4.symlink(resolvedSrc, dest);
    }
    module2.exports = copy2;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync3 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs4 = require_graceful_fs2();
    var path3 = require("path");
    var mkdirsSync = require_mkdirs2().mkdirsSync;
    var utimesMillisSync = require_utimes2().utimesMillisSync;
    var stat = require_stat2();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest)) return;
      const destParent = path3.dirname(dest);
      if (!fs4.existsSync(destParent)) mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs4.statSync : fs4.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat) return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs4.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs4.copyFileSync(src, dest);
      if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs4.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs4.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs4.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs4.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path3.join(src, item);
      const destItem = path3.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem)) return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs4.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path3.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs4.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs4.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs4.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path3.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs4.unlinkSync(dest);
      return fs4.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/index.js
var require_copy4 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    module2.exports = {
      copy: u(require_copy3()),
      copySync: require_copy_sync3()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/remove/index.js
var require_remove2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var fs4 = require_graceful_fs2();
    var u = require_universalify2().fromCallback;
    function remove(path3, callback) {
      fs4.rm(path3, { recursive: true, force: true }, callback);
    }
    function removeSync(path3) {
      fs4.rmSync(path3, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/empty/index.js
var require_empty2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var fs4 = require_fs3();
    var path3 = require("path");
    var mkdir = require_mkdirs2();
    var remove = require_remove2();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs4.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path3.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs4.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path3.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/file.js
var require_file2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var path3 = require("path");
    var fs4 = require_fs3();
    var mkdir = require_mkdirs2();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs4.stat(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path3.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs4.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs4.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs4.writeFile(file, "");
      } else {
        await fs4.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs4.statSync(file);
      } catch {
      }
      if (stats && stats.isFile()) return;
      const dir = path3.dirname(file);
      try {
        if (!fs4.statSync(dir).isDirectory()) {
          fs4.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT") mkdir.mkdirsSync(dir);
        else throw err;
      }
      fs4.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/link.js
var require_link2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var path3 = require("path");
    var fs4 = require_fs3();
    var mkdir = require_mkdirs2();
    var { pathExists } = require_path_exists2();
    var { areIdentical } = require_stat2();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs4.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs4.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat)) return;
      const dir = path3.dirname(dstpath);
      const dirExists = await pathExists(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs4.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs4.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs4.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat)) return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path3.dirname(dstpath);
      const dirExists = fs4.existsSync(dir);
      if (dirExists) return fs4.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs4.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path3 = require("path");
    var fs4 = require_fs3();
    var { pathExists } = require_path_exists2();
    var u = require_universalify2().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path3.isAbsolute(srcpath)) {
        try {
          await fs4.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path3.dirname(dstpath);
      const relativeToDst = path3.join(dstdir, srcpath);
      const exists = await pathExists(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs4.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path3.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path3.isAbsolute(srcpath)) {
        const exists2 = fs4.existsSync(srcpath);
        if (!exists2) throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path3.dirname(dstpath);
      const relativeToDst = path3.join(dstdir, srcpath);
      const exists = fs4.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs4.existsSync(srcpath);
      if (!srcExists) throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path3.relative(dstdir, srcpath)
      };
    }
    module2.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs4 = require_fs3();
    var u = require_universalify2().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = await fs4.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type) return type;
      let stats;
      try {
        stats = fs4.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var path3 = require("path");
    var fs4 = require_fs3();
    var { mkdirs, mkdirsSync } = require_mkdirs2();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths2();
    var { symlinkType, symlinkTypeSync } = require_symlink_type2();
    var { pathExists } = require_path_exists2();
    var { areIdentical } = require_stat2();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs4.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs4.stat(srcpath),
          fs4.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path3.dirname(dstpath);
      if (!await pathExists(dir)) {
        await mkdirs(dir);
      }
      return fs4.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs4.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs4.statSync(srcpath);
        const dstStat = fs4.statSync(dstpath);
        if (areIdentical(srcStat, dstStat)) return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path3.dirname(dstpath);
      const exists = fs4.existsSync(dir);
      if (exists) return fs4.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs4.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file2();
    var { createLink, createLinkSync } = require_link2();
    var { createSymlink, createSymlinkSync } = require_symlink2();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/utils.js
var require_utils6 = __commonJS2({
  "../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content)) content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// ../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/index.js
var require_jsonfile3 = __commonJS2({
  "../../node_modules/.pnpm/jsonfile@6.2.0/node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs2();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify2();
    var { stringify, stripBom } = require_utils6();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs4 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs4.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs4 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs4.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs4 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs4.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs4 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs4.writeFileSync(file, str, options);
    }
    module2.exports = {
      readFile: readFile2,
      readFileSync,
      writeFile,
      writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile4 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile3();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/output-file/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var fs4 = require_fs3();
    var path3 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists2().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path3.dirname(file);
      if (!await pathExists(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs4.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path3.dirname(file);
      if (!fs4.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs4.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils6();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync2 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils6();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/index.js
var require_json3 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    var jsonFile = require_jsonfile4();
    jsonFile.outputJson = u(require_output_json2());
    jsonFile.outputJsonSync = require_output_json_sync2();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move.js
var require_move3 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs4 = require_fs3();
    var path3 = require("path");
    var { copy: copy2 } = require_copy4();
    var { remove } = require_remove2();
    var { mkdirp } = require_mkdirs2();
    var { pathExists } = require_path_exists2();
    var stat = require_stat2();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
      await stat.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path3.dirname(dest);
      const parsedParentPath = path3.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs4.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy2(src, dest, opts);
      return remove(src);
    }
    module2.exports = move;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync3 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/move-sync.js"(exports2, module2) {
    "use strict";
    var fs4 = require_graceful_fs2();
    var path3 = require("path");
    var copySync = require_copy4().copySync;
    var removeSync = require_remove2().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirpSync;
    var stat = require_stat2();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest)) mkdirpSync(path3.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path3.dirname(dest);
      const parsedPath = path3.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase) return rename2(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename2(src, dest, overwrite);
      }
      if (fs4.existsSync(dest)) throw new Error("dest already exists.");
      return rename2(src, dest, overwrite);
    }
    function rename2(src, dest, overwrite) {
      try {
        fs4.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/index.js
var require_move4 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify2().fromPromise;
    module2.exports = {
      move: u(require_move3()),
      moveSync: require_move_sync3()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/index.js
var require_lib6 = __commonJS2({
  "../../node_modules/.pnpm/fs-extra@11.2.0/node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs3(),
      // Export extra methods:
      ...require_copy4(),
      ...require_empty2(),
      ...require_ensure2(),
      ...require_json3(),
      ...require_mkdirs2(),
      ...require_move4(),
      ...require_output_file(),
      ...require_path_exists2(),
      ...require_remove2()
    };
  }
});

// ../../node_modules/.pnpm/async-sema@3.1.1/node_modules/async-sema/lib/index.js
var require_lib7 = __commonJS2({
  "../../node_modules/.pnpm/async-sema@3.1.1/node_modules/async-sema/lib/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RateLimit = exports2.Sema = void 0;
    var events_1 = __importDefault(require("events"));
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (let j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function pow2AtLeast(n) {
      n = n >>> 0;
      n = n - 1;
      n = n | n >> 1;
      n = n | n >> 2;
      n = n | n >> 4;
      n = n | n >> 8;
      n = n | n >> 16;
      return n + 1;
    }
    function getCapacity(capacity) {
      return pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824));
    }
    var Deque = class {
      constructor(capacity) {
        this._capacity = getCapacity(capacity);
        this._length = 0;
        this._front = 0;
        this.arr = [];
      }
      push(item) {
        const length = this._length;
        this.checkCapacity(length + 1);
        const i = this._front + length & this._capacity - 1;
        this.arr[i] = item;
        this._length = length + 1;
        return length + 1;
      }
      pop() {
        const length = this._length;
        if (length === 0) {
          return void 0;
        }
        const i = this._front + length - 1 & this._capacity - 1;
        const ret = this.arr[i];
        this.arr[i] = void 0;
        this._length = length - 1;
        return ret;
      }
      shift() {
        const length = this._length;
        if (length === 0) {
          return void 0;
        }
        const front = this._front;
        const ret = this.arr[front];
        this.arr[front] = void 0;
        this._front = front + 1 & this._capacity - 1;
        this._length = length - 1;
        return ret;
      }
      get length() {
        return this._length;
      }
      checkCapacity(size) {
        if (this._capacity < size) {
          this.resizeTo(getCapacity(this._capacity * 1.5 + 16));
        }
      }
      resizeTo(capacity) {
        const oldCapacity = this._capacity;
        this._capacity = capacity;
        const front = this._front;
        const length = this._length;
        if (front + length > oldCapacity) {
          const moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this.arr, 0, this.arr, oldCapacity, moveItemsCount);
        }
      }
    };
    var ReleaseEmitter = class extends events_1.default {
    };
    function isFn(x) {
      return typeof x === "function";
    }
    function defaultInit() {
      return "1";
    }
    var Sema2 = class {
      constructor(nr, { initFn = defaultInit, pauseFn, resumeFn, capacity = 10 } = {}) {
        if (isFn(pauseFn) !== isFn(resumeFn)) {
          throw new Error("pauseFn and resumeFn must be both set for pausing");
        }
        this.nrTokens = nr;
        this.free = new Deque(nr);
        this.waiting = new Deque(capacity);
        this.releaseEmitter = new ReleaseEmitter();
        this.noTokens = initFn === defaultInit;
        this.pauseFn = pauseFn;
        this.resumeFn = resumeFn;
        this.paused = false;
        this.releaseEmitter.on("release", (token) => {
          const p = this.waiting.shift();
          if (p) {
            p.resolve(token);
          } else {
            if (this.resumeFn && this.paused) {
              this.paused = false;
              this.resumeFn();
            }
            this.free.push(token);
          }
        });
        for (let i = 0; i < nr; i++) {
          this.free.push(initFn());
        }
      }
      tryAcquire() {
        return this.free.pop();
      }
      async acquire() {
        let token = this.tryAcquire();
        if (token !== void 0) {
          return token;
        }
        return new Promise((resolve, reject) => {
          if (this.pauseFn && !this.paused) {
            this.paused = true;
            this.pauseFn();
          }
          this.waiting.push({ resolve, reject });
        });
      }
      release(token) {
        this.releaseEmitter.emit("release", this.noTokens ? "1" : token);
      }
      drain() {
        const a = new Array(this.nrTokens);
        for (let i = 0; i < this.nrTokens; i++) {
          a[i] = this.acquire();
        }
        return Promise.all(a);
      }
      nrWaiting() {
        return this.waiting.length;
      }
    };
    exports2.Sema = Sema2;
    function RateLimit(rps, { timeUnit = 1e3, uniformDistribution = false } = {}) {
      const sema2 = new Sema2(uniformDistribution ? 1 : rps);
      const delay = uniformDistribution ? timeUnit / rps : timeUnit;
      return async function rl() {
        await sema2.acquire();
        setTimeout(() => sema2.release(), delay);
      };
    }
    exports2.RateLimit = RateLimit;
  }
});

// ../../node_modules/.pnpm/@vercel+build-utils@12.2.2/node_modules/@vercel/build-utils/dist/index.js
var require_dist2 = __commonJS2({
  "../../node_modules/.pnpm/@vercel+build-utils@12.2.2/node_modules/@vercel/build-utils/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __commonJS = (cb, mod) => function __require() {
      return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
    };
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var require_process_nextick_args = __commonJS({
      "../../node_modules/.pnpm/process-nextick-args@2.0.1/node_modules/process-nextick-args/index.js"(exports2, module2) {
        "use strict";
        if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
          module2.exports = { nextTick };
        } else {
          module2.exports = process;
        }
        function nextTick(fn, arg1, arg2, arg3) {
          if (typeof fn !== "function") {
            throw new TypeError('"callback" argument must be a function');
          }
          var len = arguments.length;
          var args, i;
          switch (len) {
            case 0:
            case 1:
              return process.nextTick(fn);
            case 2:
              return process.nextTick(function afterTickOne() {
                fn.call(null, arg1);
              });
            case 3:
              return process.nextTick(function afterTickTwo() {
                fn.call(null, arg1, arg2);
              });
            case 4:
              return process.nextTick(function afterTickThree() {
                fn.call(null, arg1, arg2, arg3);
              });
            default:
              args = new Array(len - 1);
              i = 0;
              while (i < args.length) {
                args[i++] = arguments[i];
              }
              return process.nextTick(function afterTick() {
                fn.apply(null, args);
              });
          }
        }
      }
    });
    var require_isarray = __commonJS({
      "../../node_modules/.pnpm/isarray@1.0.0/node_modules/isarray/index.js"(exports2, module2) {
        var toString = {}.toString;
        module2.exports = Array.isArray || function(arr) {
          return toString.call(arr) == "[object Array]";
        };
      }
    });
    var require_stream = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
        module2.exports = require("stream");
      }
    });
    var require_safe_buffer = __commonJS({
      "../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports2, module2) {
        var buffer = require("buffer");
        var Buffer2 = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
          module2.exports = buffer;
        } else {
          copyProps(buffer, exports2);
          exports2.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer2(arg, encodingOrOffset, length);
        }
        copyProps(Buffer2, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer2(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer2(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer2(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }
    });
    var require_util = __commonJS({
      "../../node_modules/.pnpm/core-util-is@1.0.3/node_modules/core-util-is/lib/util.js"(exports2) {
        function isArray(arg) {
          if (Array.isArray) {
            return Array.isArray(arg);
          }
          return objectToString(arg) === "[object Array]";
        }
        exports2.isArray = isArray;
        function isBoolean(arg) {
          return typeof arg === "boolean";
        }
        exports2.isBoolean = isBoolean;
        function isNull(arg) {
          return arg === null;
        }
        exports2.isNull = isNull;
        function isNullOrUndefined(arg) {
          return arg == null;
        }
        exports2.isNullOrUndefined = isNullOrUndefined;
        function isNumber(arg) {
          return typeof arg === "number";
        }
        exports2.isNumber = isNumber;
        function isString(arg) {
          return typeof arg === "string";
        }
        exports2.isString = isString;
        function isSymbol(arg) {
          return typeof arg === "symbol";
        }
        exports2.isSymbol = isSymbol;
        function isUndefined(arg) {
          return arg === void 0;
        }
        exports2.isUndefined = isUndefined;
        function isRegExp(re) {
          return objectToString(re) === "[object RegExp]";
        }
        exports2.isRegExp = isRegExp;
        function isObject(arg) {
          return typeof arg === "object" && arg !== null;
        }
        exports2.isObject = isObject;
        function isDate(d) {
          return objectToString(d) === "[object Date]";
        }
        exports2.isDate = isDate;
        function isError(e) {
          return objectToString(e) === "[object Error]" || e instanceof Error;
        }
        exports2.isError = isError;
        function isFunction(arg) {
          return typeof arg === "function";
        }
        exports2.isFunction = isFunction;
        function isPrimitive(arg) {
          return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
          typeof arg === "undefined";
        }
        exports2.isPrimitive = isPrimitive;
        exports2.isBuffer = require("buffer").Buffer.isBuffer;
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
      }
    });
    var require_inherits_browser = __commonJS({
      "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports2, module2) {
        if (typeof Object.create === "function") {
          module2.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            }
          };
        } else {
          module2.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      }
    });
    var require_inherits = __commonJS({
      "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports2, module2) {
        try {
          util = require("util");
          if (typeof util.inherits !== "function")
            throw "";
          module2.exports = util.inherits;
        } catch (e) {
          module2.exports = require_inherits_browser();
        }
        var util;
      }
    });
    var require_BufferList = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Buffer2 = require_safe_buffer().Buffer;
        var util = require("util");
        function copyBuffer(src, target, offset) {
          src.copy(target, offset);
        }
        module2.exports = (function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          };
          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          };
          BufferList.prototype.shift = function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          };
          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
          };
          BufferList.prototype.join = function join4(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          };
          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0)
              return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          };
          return BufferList;
        })();
        if (util && util.inspect && util.inspect.custom) {
          module2.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length });
            return this.constructor.name + " " + obj;
          };
        }
      }
    });
    var require_destroy = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
        "use strict";
        var pna = require_process_nextick_args();
        function destroy(err, cb) {
          var _this = this;
          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;
          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (err) {
              if (!this._writableState) {
                pna.nextTick(emitErrorNT, this, err);
              } else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, this, err);
              }
            }
            return this;
          }
          if (this._readableState) {
            this._readableState.destroyed = true;
          }
          if (this._writableState) {
            this._writableState.destroyed = true;
          }
          this._destroy(err || null, function(err2) {
            if (!cb && err2) {
              if (!_this._writableState) {
                pna.nextTick(emitErrorNT, _this, err2);
              } else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                pna.nextTick(emitErrorNT, _this, err2);
              }
            } else if (cb) {
              cb(err2);
            }
          });
          return this;
        }
        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }
          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finalCalled = false;
            this._writableState.prefinished = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }
        function emitErrorNT(self2, err) {
          self2.emit("error", err);
        }
        module2.exports = {
          destroy,
          undestroy
        };
      }
    });
    var require_node = __commonJS({
      "../../node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/node.js"(exports2, module2) {
        module2.exports = require("util").deprecate;
      }
    });
    var require_stream_writable = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
        "use strict";
        var pna = require_process_nextick_args();
        module2.exports = Writable;
        function CorkedRequest(state) {
          var _this = this;
          this.next = null;
          this.entry = null;
          this.finish = function() {
            onCorkedFinish(_this, state);
          };
        }
        var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
        var Duplex;
        Writable.WritableState = WritableState;
        var util = Object.create(require_util());
        util.inherits = require_inherits();
        var internalUtil = {
          deprecate: require_node()
        };
        var Stream = require_stream();
        var Buffer2 = require_safe_buffer().Buffer;
        var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
        };
        function _uint8ArrayToBuffer(chunk) {
          return Buffer2.from(chunk);
        }
        function _isUint8Array(obj) {
          return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var destroyImpl = require_destroy();
        util.inherits(Writable, Stream);
        function nop() {
        }
        function WritableState(options, stream) {
          Duplex = Duplex || require_stream_duplex();
          options = options || {};
          var isDuplex = stream instanceof Duplex;
          this.objectMode = !!options.objectMode;
          if (isDuplex)
            this.objectMode = this.objectMode || !!options.writableObjectMode;
          var hwm = options.highWaterMark;
          var writableHwm = options.writableHighWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          if (hwm || hwm === 0)
            this.highWaterMark = hwm;
          else if (isDuplex && (writableHwm || writableHwm === 0))
            this.highWaterMark = writableHwm;
          else
            this.highWaterMark = defaultHwm;
          this.highWaterMark = Math.floor(this.highWaterMark);
          this.finalCalled = false;
          this.needDrain = false;
          this.ending = false;
          this.ended = false;
          this.finished = false;
          this.destroyed = false;
          var noDecode = options.decodeStrings === false;
          this.decodeStrings = !noDecode;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.length = 0;
          this.writing = false;
          this.corked = 0;
          this.sync = true;
          this.bufferProcessing = false;
          this.onwrite = function(er) {
            onwrite(stream, er);
          };
          this.writecb = null;
          this.writelen = 0;
          this.bufferedRequest = null;
          this.lastBufferedRequest = null;
          this.pendingcb = 0;
          this.prefinished = false;
          this.errorEmitted = false;
          this.bufferedRequestCount = 0;
          this.corkedRequestsFree = new CorkedRequest(this);
        }
        WritableState.prototype.getBuffer = function getBuffer() {
          var current = this.bufferedRequest;
          var out = [];
          while (current) {
            out.push(current);
            current = current.next;
          }
          return out;
        };
        (function() {
          try {
            Object.defineProperty(WritableState.prototype, "buffer", {
              get: internalUtil.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
            });
          } catch (_) {
          }
        })();
        var realHasInstance;
        if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
          realHasInstance = Function.prototype[Symbol.hasInstance];
          Object.defineProperty(Writable, Symbol.hasInstance, {
            value: function(object) {
              if (realHasInstance.call(this, object))
                return true;
              if (this !== Writable)
                return false;
              return object && object._writableState instanceof WritableState;
            }
          });
        } else {
          realHasInstance = function(object) {
            return object instanceof this;
          };
        }
        function Writable(options) {
          Duplex = Duplex || require_stream_duplex();
          if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
            return new Writable(options);
          }
          this._writableState = new WritableState(options, this);
          this.writable = true;
          if (options) {
            if (typeof options.write === "function")
              this._write = options.write;
            if (typeof options.writev === "function")
              this._writev = options.writev;
            if (typeof options.destroy === "function")
              this._destroy = options.destroy;
            if (typeof options.final === "function")
              this._final = options.final;
          }
          Stream.call(this);
        }
        Writable.prototype.pipe = function() {
          this.emit("error", new Error("Cannot pipe, not readable"));
        };
        function writeAfterEnd(stream, cb) {
          var er = new Error("write after end");
          stream.emit("error", er);
          pna.nextTick(cb, er);
        }
        function validChunk(stream, state, chunk, cb) {
          var valid = true;
          var er = false;
          if (chunk === null) {
            er = new TypeError("May not write null values to stream");
          } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk");
          }
          if (er) {
            stream.emit("error", er);
            pna.nextTick(cb, er);
            valid = false;
          }
          return valid;
        }
        Writable.prototype.write = function(chunk, encoding, cb) {
          var state = this._writableState;
          var ret = false;
          var isBuf = !state.objectMode && _isUint8Array(chunk);
          if (isBuf && !Buffer2.isBuffer(chunk)) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (isBuf)
            encoding = "buffer";
          else if (!encoding)
            encoding = state.defaultEncoding;
          if (typeof cb !== "function")
            cb = nop;
          if (state.ended)
            writeAfterEnd(this, cb);
          else if (isBuf || validChunk(this, state, chunk, cb)) {
            state.pendingcb++;
            ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
          }
          return ret;
        };
        Writable.prototype.cork = function() {
          var state = this._writableState;
          state.corked++;
        };
        Writable.prototype.uncork = function() {
          var state = this._writableState;
          if (state.corked) {
            state.corked--;
            if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
              clearBuffer(this, state);
          }
        };
        Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
          if (typeof encoding === "string")
            encoding = encoding.toLowerCase();
          if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
            throw new TypeError("Unknown encoding: " + encoding);
          this._writableState.defaultEncoding = encoding;
          return this;
        };
        function decodeChunk(state, chunk, encoding) {
          if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
            chunk = Buffer2.from(chunk, encoding);
          }
          return chunk;
        }
        Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
          if (!isBuf) {
            var newChunk = decodeChunk(state, chunk, encoding);
            if (chunk !== newChunk) {
              isBuf = true;
              encoding = "buffer";
              chunk = newChunk;
            }
          }
          var len = state.objectMode ? 1 : chunk.length;
          state.length += len;
          var ret = state.length < state.highWaterMark;
          if (!ret)
            state.needDrain = true;
          if (state.writing || state.corked) {
            var last = state.lastBufferedRequest;
            state.lastBufferedRequest = {
              chunk,
              encoding,
              isBuf,
              callback: cb,
              next: null
            };
            if (last) {
              last.next = state.lastBufferedRequest;
            } else {
              state.bufferedRequest = state.lastBufferedRequest;
            }
            state.bufferedRequestCount += 1;
          } else {
            doWrite(stream, state, false, len, chunk, encoding, cb);
          }
          return ret;
        }
        function doWrite(stream, state, writev, len, chunk, encoding, cb) {
          state.writelen = len;
          state.writecb = cb;
          state.writing = true;
          state.sync = true;
          if (writev)
            stream._writev(chunk, state.onwrite);
          else
            stream._write(chunk, encoding, state.onwrite);
          state.sync = false;
        }
        function onwriteError(stream, state, sync, er, cb) {
          --state.pendingcb;
          if (sync) {
            pna.nextTick(cb, er);
            pna.nextTick(finishMaybe, stream, state);
            stream._writableState.errorEmitted = true;
            stream.emit("error", er);
          } else {
            cb(er);
            stream._writableState.errorEmitted = true;
            stream.emit("error", er);
            finishMaybe(stream, state);
          }
        }
        function onwriteStateUpdate(state) {
          state.writing = false;
          state.writecb = null;
          state.length -= state.writelen;
          state.writelen = 0;
        }
        function onwrite(stream, er) {
          var state = stream._writableState;
          var sync = state.sync;
          var cb = state.writecb;
          onwriteStateUpdate(state);
          if (er)
            onwriteError(stream, state, sync, er, cb);
          else {
            var finished = needFinish(state);
            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
              clearBuffer(stream, state);
            }
            if (sync) {
              asyncWrite(afterWrite, stream, state, finished, cb);
            } else {
              afterWrite(stream, state, finished, cb);
            }
          }
        }
        function afterWrite(stream, state, finished, cb) {
          if (!finished)
            onwriteDrain(stream, state);
          state.pendingcb--;
          cb();
          finishMaybe(stream, state);
        }
        function onwriteDrain(stream, state) {
          if (state.length === 0 && state.needDrain) {
            state.needDrain = false;
            stream.emit("drain");
          }
        }
        function clearBuffer(stream, state) {
          state.bufferProcessing = true;
          var entry = state.bufferedRequest;
          if (stream._writev && entry && entry.next) {
            var l = state.bufferedRequestCount;
            var buffer = new Array(l);
            var holder = state.corkedRequestsFree;
            holder.entry = entry;
            var count = 0;
            var allBuffers = true;
            while (entry) {
              buffer[count] = entry;
              if (!entry.isBuf)
                allBuffers = false;
              entry = entry.next;
              count += 1;
            }
            buffer.allBuffers = allBuffers;
            doWrite(stream, state, true, state.length, buffer, "", holder.finish);
            state.pendingcb++;
            state.lastBufferedRequest = null;
            if (holder.next) {
              state.corkedRequestsFree = holder.next;
              holder.next = null;
            } else {
              state.corkedRequestsFree = new CorkedRequest(state);
            }
            state.bufferedRequestCount = 0;
          } else {
            while (entry) {
              var chunk = entry.chunk;
              var encoding = entry.encoding;
              var cb = entry.callback;
              var len = state.objectMode ? 1 : chunk.length;
              doWrite(stream, state, false, len, chunk, encoding, cb);
              entry = entry.next;
              state.bufferedRequestCount--;
              if (state.writing) {
                break;
              }
            }
            if (entry === null)
              state.lastBufferedRequest = null;
          }
          state.bufferedRequest = entry;
          state.bufferProcessing = false;
        }
        Writable.prototype._write = function(chunk, encoding, cb) {
          cb(new Error("_write() is not implemented"));
        };
        Writable.prototype._writev = null;
        Writable.prototype.end = function(chunk, encoding, cb) {
          var state = this._writableState;
          if (typeof chunk === "function") {
            cb = chunk;
            chunk = null;
            encoding = null;
          } else if (typeof encoding === "function") {
            cb = encoding;
            encoding = null;
          }
          if (chunk !== null && chunk !== void 0)
            this.write(chunk, encoding);
          if (state.corked) {
            state.corked = 1;
            this.uncork();
          }
          if (!state.ending)
            endWritable(this, state, cb);
        };
        function needFinish(state) {
          return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
        }
        function callFinal(stream, state) {
          stream._final(function(err) {
            state.pendingcb--;
            if (err) {
              stream.emit("error", err);
            }
            state.prefinished = true;
            stream.emit("prefinish");
            finishMaybe(stream, state);
          });
        }
        function prefinish(stream, state) {
          if (!state.prefinished && !state.finalCalled) {
            if (typeof stream._final === "function") {
              state.pendingcb++;
              state.finalCalled = true;
              pna.nextTick(callFinal, stream, state);
            } else {
              state.prefinished = true;
              stream.emit("prefinish");
            }
          }
        }
        function finishMaybe(stream, state) {
          var need = needFinish(state);
          if (need) {
            prefinish(stream, state);
            if (state.pendingcb === 0) {
              state.finished = true;
              stream.emit("finish");
            }
          }
          return need;
        }
        function endWritable(stream, state, cb) {
          state.ending = true;
          finishMaybe(stream, state);
          if (cb) {
            if (state.finished)
              pna.nextTick(cb);
            else
              stream.once("finish", cb);
          }
          state.ended = true;
          stream.writable = false;
        }
        function onCorkedFinish(corkReq, state, err) {
          var entry = corkReq.entry;
          corkReq.entry = null;
          while (entry) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(err);
            entry = entry.next;
          }
          state.corkedRequestsFree.next = corkReq;
        }
        Object.defineProperty(Writable.prototype, "destroyed", {
          get: function() {
            if (this._writableState === void 0) {
              return false;
            }
            return this._writableState.destroyed;
          },
          set: function(value) {
            if (!this._writableState) {
              return;
            }
            this._writableState.destroyed = value;
          }
        });
        Writable.prototype.destroy = destroyImpl.destroy;
        Writable.prototype._undestroy = destroyImpl.undestroy;
        Writable.prototype._destroy = function(err, cb) {
          this.end();
          cb(err);
        };
      }
    });
    var require_stream_duplex = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
        "use strict";
        var pna = require_process_nextick_args();
        var objectKeys = Object.keys || function(obj) {
          var keys2 = [];
          for (var key in obj) {
            keys2.push(key);
          }
          return keys2;
        };
        module2.exports = Duplex;
        var util = Object.create(require_util());
        util.inherits = require_inherits();
        var Readable = require_stream_readable();
        var Writable = require_stream_writable();
        util.inherits(Duplex, Readable);
        {
          keys = objectKeys(Writable.prototype);
          for (v = 0; v < keys.length; v++) {
            method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }
        var keys;
        var method;
        var v;
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false)
            this.readable = false;
          if (options && options.writable === false)
            this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;
          this.once("end", onend);
        }
        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function onend() {
          if (this.allowHalfOpen || this._writableState.ended)
            return;
          pna.nextTick(onEndNT, this);
        }
        function onEndNT(self2) {
          self2.end();
        }
        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function() {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function(value) {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return;
            }
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        });
        Duplex.prototype._destroy = function(err, cb) {
          this.push(null);
          this.end();
          pna.nextTick(cb, err);
        };
      }
    });
    var require_string_decoder = __commonJS({
      "../../node_modules/.pnpm/string_decoder@1.1.1/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
        "use strict";
        var Buffer2 = require_safe_buffer().Buffer;
        var isEncoding = Buffer2.isEncoding || function(encoding) {
          encoding = "" + encoding;
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports2.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer2.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === void 0)
              return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return byte >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "\uFFFD";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "\uFFFD";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "\uFFFD";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf, p);
          if (r !== void 0)
            return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + "\uFFFD";
          return r;
        }
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }
        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0)
            return buf.toString("base64", i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n);
        }
        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }
    });
    var require_stream_readable = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
        "use strict";
        var pna = require_process_nextick_args();
        module2.exports = Readable;
        var isArray = require_isarray();
        var Duplex;
        Readable.ReadableState = ReadableState;
        var EE = require("events").EventEmitter;
        var EElistenerCount = function(emitter, type) {
          return emitter.listeners(type).length;
        };
        var Stream = require_stream();
        var Buffer2 = require_safe_buffer().Buffer;
        var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
        };
        function _uint8ArrayToBuffer(chunk) {
          return Buffer2.from(chunk);
        }
        function _isUint8Array(obj) {
          return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
        }
        var util = Object.create(require_util());
        util.inherits = require_inherits();
        var debugUtil = require("util");
        var debug2 = void 0;
        if (debugUtil && debugUtil.debuglog) {
          debug2 = debugUtil.debuglog("stream");
        } else {
          debug2 = function() {
          };
        }
        var BufferList = require_BufferList();
        var destroyImpl = require_destroy();
        var StringDecoder;
        util.inherits(Readable, Stream);
        var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
        function prependListener(emitter, event, fn) {
          if (typeof emitter.prependListener === "function")
            return emitter.prependListener(event, fn);
          if (!emitter._events || !emitter._events[event])
            emitter.on(event, fn);
          else if (isArray(emitter._events[event]))
            emitter._events[event].unshift(fn);
          else
            emitter._events[event] = [fn, emitter._events[event]];
        }
        function ReadableState(options, stream) {
          Duplex = Duplex || require_stream_duplex();
          options = options || {};
          var isDuplex = stream instanceof Duplex;
          this.objectMode = !!options.objectMode;
          if (isDuplex)
            this.objectMode = this.objectMode || !!options.readableObjectMode;
          var hwm = options.highWaterMark;
          var readableHwm = options.readableHighWaterMark;
          var defaultHwm = this.objectMode ? 16 : 16 * 1024;
          if (hwm || hwm === 0)
            this.highWaterMark = hwm;
          else if (isDuplex && (readableHwm || readableHwm === 0))
            this.highWaterMark = readableHwm;
          else
            this.highWaterMark = defaultHwm;
          this.highWaterMark = Math.floor(this.highWaterMark);
          this.buffer = new BufferList();
          this.length = 0;
          this.pipes = null;
          this.pipesCount = 0;
          this.flowing = null;
          this.ended = false;
          this.endEmitted = false;
          this.reading = false;
          this.sync = true;
          this.needReadable = false;
          this.emittedReadable = false;
          this.readableListening = false;
          this.resumeScheduled = false;
          this.destroyed = false;
          this.defaultEncoding = options.defaultEncoding || "utf8";
          this.awaitDrain = 0;
          this.readingMore = false;
          this.decoder = null;
          this.encoding = null;
          if (options.encoding) {
            if (!StringDecoder)
              StringDecoder = require_string_decoder().StringDecoder;
            this.decoder = new StringDecoder(options.encoding);
            this.encoding = options.encoding;
          }
        }
        function Readable(options) {
          Duplex = Duplex || require_stream_duplex();
          if (!(this instanceof Readable))
            return new Readable(options);
          this._readableState = new ReadableState(options, this);
          this.readable = true;
          if (options) {
            if (typeof options.read === "function")
              this._read = options.read;
            if (typeof options.destroy === "function")
              this._destroy = options.destroy;
          }
          Stream.call(this);
        }
        Object.defineProperty(Readable.prototype, "destroyed", {
          get: function() {
            if (this._readableState === void 0) {
              return false;
            }
            return this._readableState.destroyed;
          },
          set: function(value) {
            if (!this._readableState) {
              return;
            }
            this._readableState.destroyed = value;
          }
        });
        Readable.prototype.destroy = destroyImpl.destroy;
        Readable.prototype._undestroy = destroyImpl.undestroy;
        Readable.prototype._destroy = function(err, cb) {
          this.push(null);
          cb(err);
        };
        Readable.prototype.push = function(chunk, encoding) {
          var state = this._readableState;
          var skipChunkCheck;
          if (!state.objectMode) {
            if (typeof chunk === "string") {
              encoding = encoding || state.defaultEncoding;
              if (encoding !== state.encoding) {
                chunk = Buffer2.from(chunk, encoding);
                encoding = "";
              }
              skipChunkCheck = true;
            }
          } else {
            skipChunkCheck = true;
          }
          return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
        };
        Readable.prototype.unshift = function(chunk) {
          return readableAddChunk(this, chunk, null, true, false);
        };
        function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
          var state = stream._readableState;
          if (chunk === null) {
            state.reading = false;
            onEofChunk(stream, state);
          } else {
            var er;
            if (!skipChunkCheck)
              er = chunkInvalid(state, chunk);
            if (er) {
              stream.emit("error", er);
            } else if (state.objectMode || chunk && chunk.length > 0) {
              if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
              }
              if (addToFront) {
                if (state.endEmitted)
                  stream.emit("error", new Error("stream.unshift() after end event"));
                else
                  addChunk(stream, state, chunk, true);
              } else if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
              } else {
                state.reading = false;
                if (state.decoder && !encoding) {
                  chunk = state.decoder.write(chunk);
                  if (state.objectMode || chunk.length !== 0)
                    addChunk(stream, state, chunk, false);
                  else
                    maybeReadMore(stream, state);
                } else {
                  addChunk(stream, state, chunk, false);
                }
              }
            } else if (!addToFront) {
              state.reading = false;
            }
          }
          return needMoreData(state);
        }
        function addChunk(stream, state, chunk, addToFront) {
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
        function chunkInvalid(state, chunk) {
          var er;
          if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
            er = new TypeError("Invalid non-string/buffer chunk");
          }
          return er;
        }
        function needMoreData(state) {
          return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
        }
        Readable.prototype.isPaused = function() {
          return this._readableState.flowing === false;
        };
        Readable.prototype.setEncoding = function(enc) {
          if (!StringDecoder)
            StringDecoder = require_string_decoder().StringDecoder;
          this._readableState.decoder = new StringDecoder(enc);
          this._readableState.encoding = enc;
          return this;
        };
        var MAX_HWM = 8388608;
        function computeNewHighWaterMark(n) {
          if (n >= MAX_HWM) {
            n = MAX_HWM;
          } else {
            n--;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            n++;
          }
          return n;
        }
        function howMuchToRead(n, state) {
          if (n <= 0 || state.length === 0 && state.ended)
            return 0;
          if (state.objectMode)
            return 1;
          if (n !== n) {
            if (state.flowing && state.length)
              return state.buffer.head.data.length;
            else
              return state.length;
          }
          if (n > state.highWaterMark)
            state.highWaterMark = computeNewHighWaterMark(n);
          if (n <= state.length)
            return n;
          if (!state.ended) {
            state.needReadable = true;
            return 0;
          }
          return state.length;
        }
        Readable.prototype.read = function(n) {
          debug2("read", n);
          n = parseInt(n, 10);
          var state = this._readableState;
          var nOrig = n;
          if (n !== 0)
            state.emittedReadable = false;
          if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
            debug2("read: emitReadable", state.length, state.ended);
            if (state.length === 0 && state.ended)
              endReadable(this);
            else
              emitReadable(this);
            return null;
          }
          n = howMuchToRead(n, state);
          if (n === 0 && state.ended) {
            if (state.length === 0)
              endReadable(this);
            return null;
          }
          var doRead = state.needReadable;
          debug2("need readable", doRead);
          if (state.length === 0 || state.length - n < state.highWaterMark) {
            doRead = true;
            debug2("length less than watermark", doRead);
          }
          if (state.ended || state.reading) {
            doRead = false;
            debug2("reading or ended", doRead);
          } else if (doRead) {
            debug2("do read");
            state.reading = true;
            state.sync = true;
            if (state.length === 0)
              state.needReadable = true;
            this._read(state.highWaterMark);
            state.sync = false;
            if (!state.reading)
              n = howMuchToRead(nOrig, state);
          }
          var ret;
          if (n > 0)
            ret = fromList(n, state);
          else
            ret = null;
          if (ret === null) {
            state.needReadable = true;
            n = 0;
          } else {
            state.length -= n;
          }
          if (state.length === 0) {
            if (!state.ended)
              state.needReadable = true;
            if (nOrig !== n && state.ended)
              endReadable(this);
          }
          if (ret !== null)
            this.emit("data", ret);
          return ret;
        };
        function onEofChunk(stream, state) {
          if (state.ended)
            return;
          if (state.decoder) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }
          state.ended = true;
          emitReadable(stream);
        }
        function emitReadable(stream) {
          var state = stream._readableState;
          state.needReadable = false;
          if (!state.emittedReadable) {
            debug2("emitReadable", state.flowing);
            state.emittedReadable = true;
            if (state.sync)
              pna.nextTick(emitReadable_, stream);
            else
              emitReadable_(stream);
          }
        }
        function emitReadable_(stream) {
          debug2("emit readable");
          stream.emit("readable");
          flow(stream);
        }
        function maybeReadMore(stream, state) {
          if (!state.readingMore) {
            state.readingMore = true;
            pna.nextTick(maybeReadMore_, stream, state);
          }
        }
        function maybeReadMore_(stream, state) {
          var len = state.length;
          while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
            debug2("maybeReadMore read 0");
            stream.read(0);
            if (len === state.length)
              break;
            else
              len = state.length;
          }
          state.readingMore = false;
        }
        Readable.prototype._read = function(n) {
          this.emit("error", new Error("_read() is not implemented"));
        };
        Readable.prototype.pipe = function(dest, pipeOpts) {
          var src = this;
          var state = this._readableState;
          switch (state.pipesCount) {
            case 0:
              state.pipes = dest;
              break;
            case 1:
              state.pipes = [state.pipes, dest];
              break;
            default:
              state.pipes.push(dest);
              break;
          }
          state.pipesCount += 1;
          debug2("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
          var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
          var endFn = doEnd ? onend : unpipe;
          if (state.endEmitted)
            pna.nextTick(endFn);
          else
            src.once("end", endFn);
          dest.on("unpipe", onunpipe);
          function onunpipe(readable, unpipeInfo) {
            debug2("onunpipe");
            if (readable === src) {
              if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
              }
            }
          }
          function onend() {
            debug2("onend");
            dest.end();
          }
          var ondrain = pipeOnDrain(src);
          dest.on("drain", ondrain);
          var cleanedUp = false;
          function cleanup() {
            debug2("cleanup");
            dest.removeListener("close", onclose);
            dest.removeListener("finish", onfinish);
            dest.removeListener("drain", ondrain);
            dest.removeListener("error", onerror);
            dest.removeListener("unpipe", onunpipe);
            src.removeListener("end", onend);
            src.removeListener("end", unpipe);
            src.removeListener("data", ondata);
            cleanedUp = true;
            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
              ondrain();
          }
          var increasedAwaitDrain = false;
          src.on("data", ondata);
          function ondata(chunk) {
            debug2("ondata");
            increasedAwaitDrain = false;
            var ret = dest.write(chunk);
            if (false === ret && !increasedAwaitDrain) {
              if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug2("false write response, pause", state.awaitDrain);
                state.awaitDrain++;
                increasedAwaitDrain = true;
              }
              src.pause();
            }
          }
          function onerror(er) {
            debug2("onerror", er);
            unpipe();
            dest.removeListener("error", onerror);
            if (EElistenerCount(dest, "error") === 0)
              dest.emit("error", er);
          }
          prependListener(dest, "error", onerror);
          function onclose() {
            dest.removeListener("finish", onfinish);
            unpipe();
          }
          dest.once("close", onclose);
          function onfinish() {
            debug2("onfinish");
            dest.removeListener("close", onclose);
            unpipe();
          }
          dest.once("finish", onfinish);
          function unpipe() {
            debug2("unpipe");
            src.unpipe(dest);
          }
          dest.emit("pipe", src);
          if (!state.flowing) {
            debug2("pipe resume");
            src.resume();
          }
          return dest;
        };
        function pipeOnDrain(src) {
          return function() {
            var state = src._readableState;
            debug2("pipeOnDrain", state.awaitDrain);
            if (state.awaitDrain)
              state.awaitDrain--;
            if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
              state.flowing = true;
              flow(src);
            }
          };
        }
        Readable.prototype.unpipe = function(dest) {
          var state = this._readableState;
          var unpipeInfo = { hasUnpiped: false };
          if (state.pipesCount === 0)
            return this;
          if (state.pipesCount === 1) {
            if (dest && dest !== state.pipes)
              return this;
            if (!dest)
              dest = state.pipes;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            if (dest)
              dest.emit("unpipe", this, unpipeInfo);
            return this;
          }
          if (!dest) {
            var dests = state.pipes;
            var len = state.pipesCount;
            state.pipes = null;
            state.pipesCount = 0;
            state.flowing = false;
            for (var i = 0; i < len; i++) {
              dests[i].emit("unpipe", this, { hasUnpiped: false });
            }
            return this;
          }
          var index = indexOf(state.pipes, dest);
          if (index === -1)
            return this;
          state.pipes.splice(index, 1);
          state.pipesCount -= 1;
          if (state.pipesCount === 1)
            state.pipes = state.pipes[0];
          dest.emit("unpipe", this, unpipeInfo);
          return this;
        };
        Readable.prototype.on = function(ev, fn) {
          var res = Stream.prototype.on.call(this, ev, fn);
          if (ev === "data") {
            if (this._readableState.flowing !== false)
              this.resume();
          } else if (ev === "readable") {
            var state = this._readableState;
            if (!state.endEmitted && !state.readableListening) {
              state.readableListening = state.needReadable = true;
              state.emittedReadable = false;
              if (!state.reading) {
                pna.nextTick(nReadingNextTick, this);
              } else if (state.length) {
                emitReadable(this);
              }
            }
          }
          return res;
        };
        Readable.prototype.addListener = Readable.prototype.on;
        function nReadingNextTick(self2) {
          debug2("readable nexttick read 0");
          self2.read(0);
        }
        Readable.prototype.resume = function() {
          var state = this._readableState;
          if (!state.flowing) {
            debug2("resume");
            state.flowing = true;
            resume(this, state);
          }
          return this;
        };
        function resume(stream, state) {
          if (!state.resumeScheduled) {
            state.resumeScheduled = true;
            pna.nextTick(resume_, stream, state);
          }
        }
        function resume_(stream, state) {
          if (!state.reading) {
            debug2("resume read 0");
            stream.read(0);
          }
          state.resumeScheduled = false;
          state.awaitDrain = 0;
          stream.emit("resume");
          flow(stream);
          if (state.flowing && !state.reading)
            stream.read(0);
        }
        Readable.prototype.pause = function() {
          debug2("call pause flowing=%j", this._readableState.flowing);
          if (false !== this._readableState.flowing) {
            debug2("pause");
            this._readableState.flowing = false;
            this.emit("pause");
          }
          return this;
        };
        function flow(stream) {
          var state = stream._readableState;
          debug2("flow", state.flowing);
          while (state.flowing && stream.read() !== null) {
          }
        }
        Readable.prototype.wrap = function(stream) {
          var _this = this;
          var state = this._readableState;
          var paused = false;
          stream.on("end", function() {
            debug2("wrapped end");
            if (state.decoder && !state.ended) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length)
                _this.push(chunk);
            }
            _this.push(null);
          });
          stream.on("data", function(chunk) {
            debug2("wrapped data");
            if (state.decoder)
              chunk = state.decoder.write(chunk);
            if (state.objectMode && (chunk === null || chunk === void 0))
              return;
            else if (!state.objectMode && (!chunk || !chunk.length))
              return;
            var ret = _this.push(chunk);
            if (!ret) {
              paused = true;
              stream.pause();
            }
          });
          for (var i in stream) {
            if (this[i] === void 0 && typeof stream[i] === "function") {
              this[i] = /* @__PURE__ */ (function(method) {
                return function() {
                  return stream[method].apply(stream, arguments);
                };
              })(i);
            }
          }
          for (var n = 0; n < kProxyEvents.length; n++) {
            stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
          }
          this._read = function(n2) {
            debug2("wrapped _read", n2);
            if (paused) {
              paused = false;
              stream.resume();
            }
          };
          return this;
        };
        Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._readableState.highWaterMark;
          }
        });
        Readable._fromList = fromList;
        function fromList(n, state) {
          if (state.length === 0)
            return null;
          var ret;
          if (state.objectMode)
            ret = state.buffer.shift();
          else if (!n || n >= state.length) {
            if (state.decoder)
              ret = state.buffer.join("");
            else if (state.buffer.length === 1)
              ret = state.buffer.head.data;
            else
              ret = state.buffer.concat(state.length);
            state.buffer.clear();
          } else {
            ret = fromListPartial(n, state.buffer, state.decoder);
          }
          return ret;
        }
        function fromListPartial(n, list, hasStrings) {
          var ret;
          if (n < list.head.data.length) {
            ret = list.head.data.slice(0, n);
            list.head.data = list.head.data.slice(n);
          } else if (n === list.head.data.length) {
            ret = list.shift();
          } else {
            ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
          }
          return ret;
        }
        function copyFromBufferString(n, list) {
          var p = list.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  list.head = p.next;
                else
                  list.head = list.tail = null;
              } else {
                list.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          list.length -= c;
          return ret;
        }
        function copyFromBuffer(n, list) {
          var ret = Buffer2.allocUnsafe(n);
          var p = list.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  list.head = p.next;
                else
                  list.head = list.tail = null;
              } else {
                list.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          list.length -= c;
          return ret;
        }
        function endReadable(stream) {
          var state = stream._readableState;
          if (state.length > 0)
            throw new Error('"endReadable()" called on non-empty stream');
          if (!state.endEmitted) {
            state.ended = true;
            pna.nextTick(endReadableNT, state, stream);
          }
        }
        function endReadableNT(state, stream) {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        }
        function indexOf(xs, x) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (xs[i] === x)
              return i;
          }
          return -1;
        }
      }
    });
    var require_stream_transform = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
        "use strict";
        module2.exports = Transform;
        var Duplex = require_stream_duplex();
        var util = Object.create(require_util());
        util.inherits = require_inherits();
        util.inherits(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb) {
            return this.emit("error", new Error("write callback called multiple times"));
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented");
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          var _this2 = this;
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
            _this2.emit("close");
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
          return stream.push(null);
        }
      }
    });
    var require_stream_passthrough = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
        "use strict";
        module2.exports = PassThrough;
        var Transform = require_stream_transform();
        var util = Object.create(require_util());
        util.inherits = require_inherits();
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }
    });
    var require_readable = __commonJS({
      "../../node_modules/.pnpm/readable-stream@2.3.8/node_modules/readable-stream/readable.js"(exports2, module2) {
        var Stream = require("stream");
        if (process.env.READABLE_STREAM === "disable" && Stream) {
          module2.exports = Stream;
          exports2 = module2.exports = Stream.Readable;
          exports2.Readable = Stream.Readable;
          exports2.Writable = Stream.Writable;
          exports2.Duplex = Stream.Duplex;
          exports2.Transform = Stream.Transform;
          exports2.PassThrough = Stream.PassThrough;
          exports2.Stream = Stream;
        } else {
          exports2 = module2.exports = require_stream_readable();
          exports2.Stream = Stream || exports2;
          exports2.Readable = exports2;
          exports2.Writable = require_stream_writable();
          exports2.Duplex = require_stream_duplex();
          exports2.Transform = require_stream_transform();
          exports2.PassThrough = require_stream_passthrough();
        }
      }
    });
    var require_from2 = __commonJS({
      "../../node_modules/.pnpm/from2@2.3.0/node_modules/from2/index.js"(exports2, module2) {
        var Readable = require_readable().Readable;
        var inherits = require_inherits();
        module2.exports = from2;
        from2.ctor = ctor;
        from2.obj = obj;
        var Proto = ctor();
        function toFunction(list) {
          list = list.slice();
          return function(_, cb) {
            var err = null;
            var item = list.length ? list.shift() : null;
            if (item instanceof Error) {
              err = item;
              item = null;
            }
            cb(err, item);
          };
        }
        function from2(opts, read) {
          if (typeof opts !== "object" || Array.isArray(opts)) {
            read = opts;
            opts = {};
          }
          var rs = new Proto(opts);
          rs._from = Array.isArray(read) ? toFunction(read) : read || noop;
          return rs;
        }
        function ctor(opts, read) {
          if (typeof opts === "function") {
            read = opts;
            opts = {};
          }
          opts = defaults(opts);
          inherits(Class, Readable);
          function Class(override) {
            if (!(this instanceof Class))
              return new Class(override);
            this._reading = false;
            this._callback = check;
            this.destroyed = false;
            Readable.call(this, override || opts);
            var self2 = this;
            var hwm = this._readableState.highWaterMark;
            function check(err, data) {
              if (self2.destroyed)
                return;
              if (err)
                return self2.destroy(err);
              if (data === null)
                return self2.push(null);
              self2._reading = false;
              if (self2.push(data))
                self2._read(hwm);
            }
          }
          Class.prototype._from = read || noop;
          Class.prototype._read = function(size) {
            if (this._reading || this.destroyed)
              return;
            this._reading = true;
            this._from(size, this._callback);
          };
          Class.prototype.destroy = function(err) {
            if (this.destroyed)
              return;
            this.destroyed = true;
            var self2 = this;
            process.nextTick(function() {
              if (err)
                self2.emit("error", err);
              self2.emit("close");
            });
          };
          return Class;
        }
        function obj(opts, read) {
          if (typeof opts === "function" || Array.isArray(opts)) {
            read = opts;
            opts = {};
          }
          opts = defaults(opts);
          opts.objectMode = true;
          opts.highWaterMark = 16;
          return from2(opts, read);
        }
        function noop() {
        }
        function defaults(opts) {
          opts = opts || {};
          return opts;
        }
      }
    });
    var require_p_is_promise = __commonJS({
      "../../node_modules/.pnpm/p-is-promise@2.1.0/node_modules/p-is-promise/index.js"(exports2, module2) {
        "use strict";
        var isPromise = (input) => input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
        module2.exports = isPromise;
        module2.exports.default = isPromise;
      }
    });
    var require_into_stream = __commonJS({
      "../../node_modules/.pnpm/into-stream@5.0.0/node_modules/into-stream/index.js"(exports2, module2) {
        "use strict";
        var from = require_from2();
        var pIsPromise = require_p_is_promise();
        var intoStream2 = (input) => {
          if (Array.isArray(input)) {
            input = input.slice();
          }
          let promise;
          let iterator;
          prepare(input);
          function prepare(value) {
            input = value;
            if (input instanceof ArrayBuffer || ArrayBuffer.isView(input) && !Buffer.isBuffer(input)) {
              input = Buffer.from(input);
            }
            promise = pIsPromise(input) ? input : null;
            const shouldIterate = !promise && input[Symbol.iterator] && typeof input !== "string" && !Buffer.isBuffer(input);
            iterator = shouldIterate ? input[Symbol.iterator]() : null;
          }
          return from(function reader(size, callback) {
            if (promise) {
              (async () => {
                try {
                  await prepare(await promise);
                  reader.call(this, size, callback);
                } catch (error) {
                  callback(error);
                }
              })();
              return;
            }
            if (iterator) {
              const object = iterator.next();
              setImmediate(callback, null, object.done ? null : object.value);
              return;
            }
            if (input.length === 0) {
              setImmediate(callback, null, null);
              return;
            }
            const chunk = input.slice(0, size);
            input = input.slice(size);
            setImmediate(callback, null, chunk);
          });
        };
        module2.exports = intoStream2;
        module2.exports.default = intoStream2;
        module2.exports.object = (input) => {
          if (Array.isArray(input)) {
            input = input.slice();
          }
          let promise;
          let iterator;
          prepare(input);
          function prepare(value) {
            input = value;
            promise = pIsPromise(input) ? input : null;
            iterator = !promise && input[Symbol.iterator] ? input[Symbol.iterator]() : null;
          }
          return from.obj(function reader(size, callback) {
            if (promise) {
              (async () => {
                try {
                  await prepare(await promise);
                  reader.call(this, size, callback);
                } catch (error) {
                  callback(error);
                }
              })();
              return;
            }
            if (iterator) {
              const object = iterator.next();
              setImmediate(callback, null, object.done ? null : object.value);
              return;
            }
            this.push(input);
            setImmediate(callback, null, null);
          });
        };
      }
    });
    var require_universalify = __commonJS({
      "../../node_modules/.pnpm/universalify@2.0.1/node_modules/universalify/index.js"(exports2) {
        "use strict";
        exports2.fromCallback = function(fn) {
          return Object.defineProperty(function(...args) {
            if (typeof args[args.length - 1] === "function")
              fn.apply(this, args);
            else {
              return new Promise((resolve, reject) => {
                args.push((err, res) => err != null ? reject(err) : resolve(res));
                fn.apply(this, args);
              });
            }
          }, "name", { value: fn.name });
        };
        exports2.fromPromise = function(fn) {
          return Object.defineProperty(function(...args) {
            const cb = args[args.length - 1];
            if (typeof cb !== "function")
              return fn.apply(this, args);
            else {
              args.pop();
              fn.apply(this, args).then((r) => cb(null, r), cb);
            }
          }, "name", { value: fn.name });
        };
      }
    });
    var require_polyfills = __commonJS({
      "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports2, module2) {
        var constants = require("constants");
        var origCwd = process.cwd;
        var cwd = null;
        var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
        process.cwd = function() {
          if (!cwd)
            cwd = origCwd.call(process);
          return cwd;
        };
        try {
          process.cwd();
        } catch (er) {
        }
        if (typeof process.chdir === "function") {
          chdir = process.chdir;
          process.chdir = function(d) {
            cwd = null;
            chdir.call(process, d);
          };
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(process.chdir, chdir);
        }
        var chdir;
        module2.exports = patch;
        function patch(fs6) {
          if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
            patchLchmod(fs6);
          }
          if (!fs6.lutimes) {
            patchLutimes(fs6);
          }
          fs6.chown = chownFix(fs6.chown);
          fs6.fchown = chownFix(fs6.fchown);
          fs6.lchown = chownFix(fs6.lchown);
          fs6.chmod = chmodFix(fs6.chmod);
          fs6.fchmod = chmodFix(fs6.fchmod);
          fs6.lchmod = chmodFix(fs6.lchmod);
          fs6.chownSync = chownFixSync(fs6.chownSync);
          fs6.fchownSync = chownFixSync(fs6.fchownSync);
          fs6.lchownSync = chownFixSync(fs6.lchownSync);
          fs6.chmodSync = chmodFixSync(fs6.chmodSync);
          fs6.fchmodSync = chmodFixSync(fs6.fchmodSync);
          fs6.lchmodSync = chmodFixSync(fs6.lchmodSync);
          fs6.stat = statFix(fs6.stat);
          fs6.fstat = statFix(fs6.fstat);
          fs6.lstat = statFix(fs6.lstat);
          fs6.statSync = statFixSync(fs6.statSync);
          fs6.fstatSync = statFixSync(fs6.fstatSync);
          fs6.lstatSync = statFixSync(fs6.lstatSync);
          if (fs6.chmod && !fs6.lchmod) {
            fs6.lchmod = function(path7, mode, cb) {
              if (cb)
                process.nextTick(cb);
            };
            fs6.lchmodSync = function() {
            };
          }
          if (fs6.chown && !fs6.lchown) {
            fs6.lchown = function(path7, uid, gid, cb) {
              if (cb)
                process.nextTick(cb);
            };
            fs6.lchownSync = function() {
            };
          }
          if (platform === "win32") {
            fs6.rename = typeof fs6.rename !== "function" ? fs6.rename : (function(fs$rename) {
              function rename2(from, to, cb) {
                var start = Date.now();
                var backoff = 0;
                fs$rename(from, to, function CB(er) {
                  if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                    setTimeout(function() {
                      fs6.stat(to, function(stater, st) {
                        if (stater && stater.code === "ENOENT")
                          fs$rename(from, to, CB);
                        else
                          cb(er);
                      });
                    }, backoff);
                    if (backoff < 100)
                      backoff += 10;
                    return;
                  }
                  if (cb)
                    cb(er);
                });
              }
              if (Object.setPrototypeOf)
                Object.setPrototypeOf(rename2, fs$rename);
              return rename2;
            })(fs6.rename);
          }
          fs6.read = typeof fs6.read !== "function" ? fs6.read : (function(fs$read) {
            function read(fd, buffer, offset, length, position, callback_) {
              var callback;
              if (callback_ && typeof callback_ === "function") {
                var eagCounter = 0;
                callback = function(er, _, __) {
                  if (er && er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    return fs$read.call(fs6, fd, buffer, offset, length, position, callback);
                  }
                  callback_.apply(this, arguments);
                };
              }
              return fs$read.call(fs6, fd, buffer, offset, length, position, callback);
            }
            if (Object.setPrototypeOf)
              Object.setPrototypeOf(read, fs$read);
            return read;
          })(fs6.read);
          fs6.readSync = typeof fs6.readSync !== "function" ? fs6.readSync : /* @__PURE__ */ (function(fs$readSync) {
            return function(fd, buffer, offset, length, position) {
              var eagCounter = 0;
              while (true) {
                try {
                  return fs$readSync.call(fs6, fd, buffer, offset, length, position);
                } catch (er) {
                  if (er.code === "EAGAIN" && eagCounter < 10) {
                    eagCounter++;
                    continue;
                  }
                  throw er;
                }
              }
            };
          })(fs6.readSync);
          function patchLchmod(fs7) {
            fs7.lchmod = function(path7, mode, callback) {
              fs7.open(
                path7,
                constants.O_WRONLY | constants.O_SYMLINK,
                mode,
                function(err, fd) {
                  if (err) {
                    if (callback)
                      callback(err);
                    return;
                  }
                  fs7.fchmod(fd, mode, function(err2) {
                    fs7.close(fd, function(err22) {
                      if (callback)
                        callback(err2 || err22);
                    });
                  });
                }
              );
            };
            fs7.lchmodSync = function(path7, mode) {
              var fd = fs7.openSync(path7, constants.O_WRONLY | constants.O_SYMLINK, mode);
              var threw = true;
              var ret;
              try {
                ret = fs7.fchmodSync(fd, mode);
                threw = false;
              } finally {
                if (threw) {
                  try {
                    fs7.closeSync(fd);
                  } catch (er) {
                  }
                } else {
                  fs7.closeSync(fd);
                }
              }
              return ret;
            };
          }
          function patchLutimes(fs7) {
            if (constants.hasOwnProperty("O_SYMLINK") && fs7.futimes) {
              fs7.lutimes = function(path7, at, mt, cb) {
                fs7.open(path7, constants.O_SYMLINK, function(er, fd) {
                  if (er) {
                    if (cb)
                      cb(er);
                    return;
                  }
                  fs7.futimes(fd, at, mt, function(er2) {
                    fs7.close(fd, function(er22) {
                      if (cb)
                        cb(er2 || er22);
                    });
                  });
                });
              };
              fs7.lutimesSync = function(path7, at, mt) {
                var fd = fs7.openSync(path7, constants.O_SYMLINK);
                var ret;
                var threw = true;
                try {
                  ret = fs7.futimesSync(fd, at, mt);
                  threw = false;
                } finally {
                  if (threw) {
                    try {
                      fs7.closeSync(fd);
                    } catch (er) {
                    }
                  } else {
                    fs7.closeSync(fd);
                  }
                }
                return ret;
              };
            } else if (fs7.futimes) {
              fs7.lutimes = function(_a, _b, _c, cb) {
                if (cb)
                  process.nextTick(cb);
              };
              fs7.lutimesSync = function() {
              };
            }
          }
          function chmodFix(orig) {
            if (!orig)
              return orig;
            return function(target, mode, cb) {
              return orig.call(fs6, target, mode, function(er) {
                if (chownErOk(er))
                  er = null;
                if (cb)
                  cb.apply(this, arguments);
              });
            };
          }
          function chmodFixSync(orig) {
            if (!orig)
              return orig;
            return function(target, mode) {
              try {
                return orig.call(fs6, target, mode);
              } catch (er) {
                if (!chownErOk(er))
                  throw er;
              }
            };
          }
          function chownFix(orig) {
            if (!orig)
              return orig;
            return function(target, uid, gid, cb) {
              return orig.call(fs6, target, uid, gid, function(er) {
                if (chownErOk(er))
                  er = null;
                if (cb)
                  cb.apply(this, arguments);
              });
            };
          }
          function chownFixSync(orig) {
            if (!orig)
              return orig;
            return function(target, uid, gid) {
              try {
                return orig.call(fs6, target, uid, gid);
              } catch (er) {
                if (!chownErOk(er))
                  throw er;
              }
            };
          }
          function statFix(orig) {
            if (!orig)
              return orig;
            return function(target, options, cb) {
              if (typeof options === "function") {
                cb = options;
                options = null;
              }
              function callback(er, stats) {
                if (stats) {
                  if (stats.uid < 0)
                    stats.uid += 4294967296;
                  if (stats.gid < 0)
                    stats.gid += 4294967296;
                }
                if (cb)
                  cb.apply(this, arguments);
              }
              return options ? orig.call(fs6, target, options, callback) : orig.call(fs6, target, callback);
            };
          }
          function statFixSync(orig) {
            if (!orig)
              return orig;
            return function(target, options) {
              var stats = options ? orig.call(fs6, target, options) : orig.call(fs6, target);
              if (stats) {
                if (stats.uid < 0)
                  stats.uid += 4294967296;
                if (stats.gid < 0)
                  stats.gid += 4294967296;
              }
              return stats;
            };
          }
          function chownErOk(er) {
            if (!er)
              return true;
            if (er.code === "ENOSYS")
              return true;
            var nonroot = !process.getuid || process.getuid() !== 0;
            if (nonroot) {
              if (er.code === "EINVAL" || er.code === "EPERM")
                return true;
            }
            return false;
          }
        }
      }
    });
    var require_legacy_streams = __commonJS({
      "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
        var Stream = require("stream").Stream;
        module2.exports = legacy;
        function legacy(fs6) {
          return {
            ReadStream,
            WriteStream
          };
          function ReadStream(path7, options) {
            if (!(this instanceof ReadStream))
              return new ReadStream(path7, options);
            Stream.call(this);
            var self2 = this;
            this.path = path7;
            this.fd = null;
            this.readable = true;
            this.paused = false;
            this.flags = "r";
            this.mode = 438;
            this.bufferSize = 64 * 1024;
            options = options || {};
            var keys = Object.keys(options);
            for (var index = 0, length = keys.length; index < length; index++) {
              var key = keys[index];
              this[key] = options[key];
            }
            if (this.encoding)
              this.setEncoding(this.encoding);
            if (this.start !== void 0) {
              if ("number" !== typeof this.start) {
                throw TypeError("start must be a Number");
              }
              if (this.end === void 0) {
                this.end = Infinity;
              } else if ("number" !== typeof this.end) {
                throw TypeError("end must be a Number");
              }
              if (this.start > this.end) {
                throw new Error("start must be <= end");
              }
              this.pos = this.start;
            }
            if (this.fd !== null) {
              process.nextTick(function() {
                self2._read();
              });
              return;
            }
            fs6.open(this.path, this.flags, this.mode, function(err, fd) {
              if (err) {
                self2.emit("error", err);
                self2.readable = false;
                return;
              }
              self2.fd = fd;
              self2.emit("open", fd);
              self2._read();
            });
          }
          function WriteStream(path7, options) {
            if (!(this instanceof WriteStream))
              return new WriteStream(path7, options);
            Stream.call(this);
            this.path = path7;
            this.fd = null;
            this.writable = true;
            this.flags = "w";
            this.encoding = "binary";
            this.mode = 438;
            this.bytesWritten = 0;
            options = options || {};
            var keys = Object.keys(options);
            for (var index = 0, length = keys.length; index < length; index++) {
              var key = keys[index];
              this[key] = options[key];
            }
            if (this.start !== void 0) {
              if ("number" !== typeof this.start) {
                throw TypeError("start must be a Number");
              }
              if (this.start < 0) {
                throw new Error("start must be >= zero");
              }
              this.pos = this.start;
            }
            this.busy = false;
            this._queue = [];
            if (this.fd === null) {
              this._open = fs6.open;
              this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
              this.flush();
            }
          }
        }
      }
    });
    var require_clone = __commonJS({
      "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports2, module2) {
        "use strict";
        module2.exports = clone;
        var getPrototypeOf = Object.getPrototypeOf || function(obj) {
          return obj.__proto__;
        };
        function clone(obj) {
          if (obj === null || typeof obj !== "object")
            return obj;
          if (obj instanceof Object)
            var copy2 = { __proto__: getPrototypeOf(obj) };
          else
            var copy2 = /* @__PURE__ */ Object.create(null);
          Object.getOwnPropertyNames(obj).forEach(function(key) {
            Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
          });
          return copy2;
        }
      }
    });
    var require_graceful_fs = __commonJS({
      "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
        var fs6 = require("fs");
        var polyfills = require_polyfills();
        var legacy = require_legacy_streams();
        var clone = require_clone();
        var util = require("util");
        var gracefulQueue;
        var previousSymbol;
        if (typeof Symbol === "function" && typeof Symbol.for === "function") {
          gracefulQueue = Symbol.for("graceful-fs.queue");
          previousSymbol = Symbol.for("graceful-fs.previous");
        } else {
          gracefulQueue = "___graceful-fs.queue";
          previousSymbol = "___graceful-fs.previous";
        }
        function noop() {
        }
        function publishQueue(context, queue2) {
          Object.defineProperty(context, gracefulQueue, {
            get: function() {
              return queue2;
            }
          });
        }
        var debug2 = noop;
        if (util.debuglog)
          debug2 = util.debuglog("gfs4");
        else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
          debug2 = function() {
            var m = util.format.apply(util, arguments);
            m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
            console.error(m);
          };
        if (!fs6[gracefulQueue]) {
          queue = global[gracefulQueue] || [];
          publishQueue(fs6, queue);
          fs6.close = (function(fs$close) {
            function close(fd, cb) {
              return fs$close.call(fs6, fd, function(err) {
                if (!err) {
                  resetQueue();
                }
                if (typeof cb === "function")
                  cb.apply(this, arguments);
              });
            }
            Object.defineProperty(close, previousSymbol, {
              value: fs$close
            });
            return close;
          })(fs6.close);
          fs6.closeSync = (function(fs$closeSync) {
            function closeSync(fd) {
              fs$closeSync.apply(fs6, arguments);
              resetQueue();
            }
            Object.defineProperty(closeSync, previousSymbol, {
              value: fs$closeSync
            });
            return closeSync;
          })(fs6.closeSync);
          if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
            process.on("exit", function() {
              debug2(fs6[gracefulQueue]);
              require("assert").equal(fs6[gracefulQueue].length, 0);
            });
          }
        }
        var queue;
        if (!global[gracefulQueue]) {
          publishQueue(global, fs6[gracefulQueue]);
        }
        module2.exports = patch(clone(fs6));
        if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs6.__patched) {
          module2.exports = patch(fs6);
          fs6.__patched = true;
        }
        function patch(fs7) {
          polyfills(fs7);
          fs7.gracefulify = patch;
          fs7.createReadStream = createReadStream;
          fs7.createWriteStream = createWriteStream;
          var fs$readFile = fs7.readFile;
          fs7.readFile = readFile4;
          function readFile4(path7, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            return go$readFile(path7, options, cb);
            function go$readFile(path8, options2, cb2, startTime) {
              return fs$readFile(path8, options2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$readFile, [path8, options2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$writeFile = fs7.writeFile;
          fs7.writeFile = writeFile;
          function writeFile(path7, data, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            return go$writeFile(path7, data, options, cb);
            function go$writeFile(path8, data2, options2, cb2, startTime) {
              return fs$writeFile(path8, data2, options2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$writeFile, [path8, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$appendFile = fs7.appendFile;
          if (fs$appendFile)
            fs7.appendFile = appendFile;
          function appendFile(path7, data, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            return go$appendFile(path7, data, options, cb);
            function go$appendFile(path8, data2, options2, cb2, startTime) {
              return fs$appendFile(path8, data2, options2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$appendFile, [path8, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$copyFile = fs7.copyFile;
          if (fs$copyFile)
            fs7.copyFile = copyFile;
          function copyFile(src, dest, flags, cb) {
            if (typeof flags === "function") {
              cb = flags;
              flags = 0;
            }
            return go$copyFile(src, dest, flags, cb);
            function go$copyFile(src2, dest2, flags2, cb2, startTime) {
              return fs$copyFile(src2, dest2, flags2, function(err) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          var fs$readdir = fs7.readdir;
          fs7.readdir = readdir;
          var noReaddirOptionVersions = /^v[0-5]\./;
          function readdir(path7, options, cb) {
            if (typeof options === "function")
              cb = options, options = null;
            var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path8, options2, cb2, startTime) {
              return fs$readdir(path8, fs$readdirCallback(
                path8,
                options2,
                cb2,
                startTime
              ));
            } : function go$readdir2(path8, options2, cb2, startTime) {
              return fs$readdir(path8, options2, fs$readdirCallback(
                path8,
                options2,
                cb2,
                startTime
              ));
            };
            return go$readdir(path7, options, cb);
            function fs$readdirCallback(path8, options2, cb2, startTime) {
              return function(err, files) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([
                    go$readdir,
                    [path8, options2, cb2],
                    err,
                    startTime || Date.now(),
                    Date.now()
                  ]);
                else {
                  if (files && files.sort)
                    files.sort();
                  if (typeof cb2 === "function")
                    cb2.call(this, err, files);
                }
              };
            }
          }
          if (process.version.substr(0, 4) === "v0.8") {
            var legStreams = legacy(fs7);
            ReadStream = legStreams.ReadStream;
            WriteStream = legStreams.WriteStream;
          }
          var fs$ReadStream = fs7.ReadStream;
          if (fs$ReadStream) {
            ReadStream.prototype = Object.create(fs$ReadStream.prototype);
            ReadStream.prototype.open = ReadStream$open;
          }
          var fs$WriteStream = fs7.WriteStream;
          if (fs$WriteStream) {
            WriteStream.prototype = Object.create(fs$WriteStream.prototype);
            WriteStream.prototype.open = WriteStream$open;
          }
          Object.defineProperty(fs7, "ReadStream", {
            get: function() {
              return ReadStream;
            },
            set: function(val) {
              ReadStream = val;
            },
            enumerable: true,
            configurable: true
          });
          Object.defineProperty(fs7, "WriteStream", {
            get: function() {
              return WriteStream;
            },
            set: function(val) {
              WriteStream = val;
            },
            enumerable: true,
            configurable: true
          });
          var FileReadStream = ReadStream;
          Object.defineProperty(fs7, "FileReadStream", {
            get: function() {
              return FileReadStream;
            },
            set: function(val) {
              FileReadStream = val;
            },
            enumerable: true,
            configurable: true
          });
          var FileWriteStream = WriteStream;
          Object.defineProperty(fs7, "FileWriteStream", {
            get: function() {
              return FileWriteStream;
            },
            set: function(val) {
              FileWriteStream = val;
            },
            enumerable: true,
            configurable: true
          });
          function ReadStream(path7, options) {
            if (this instanceof ReadStream)
              return fs$ReadStream.apply(this, arguments), this;
            else
              return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
          }
          function ReadStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
              if (err) {
                if (that.autoClose)
                  that.destroy();
                that.emit("error", err);
              } else {
                that.fd = fd;
                that.emit("open", fd);
                that.read();
              }
            });
          }
          function WriteStream(path7, options) {
            if (this instanceof WriteStream)
              return fs$WriteStream.apply(this, arguments), this;
            else
              return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
          }
          function WriteStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
              if (err) {
                that.destroy();
                that.emit("error", err);
              } else {
                that.fd = fd;
                that.emit("open", fd);
              }
            });
          }
          function createReadStream(path7, options) {
            return new fs7.ReadStream(path7, options);
          }
          function createWriteStream(path7, options) {
            return new fs7.WriteStream(path7, options);
          }
          var fs$open = fs7.open;
          fs7.open = open;
          function open(path7, flags, mode, cb) {
            if (typeof mode === "function")
              cb = mode, mode = null;
            return go$open(path7, flags, mode, cb);
            function go$open(path8, flags2, mode2, cb2, startTime) {
              return fs$open(path8, flags2, mode2, function(err, fd) {
                if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
                  enqueue([go$open, [path8, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
                else {
                  if (typeof cb2 === "function")
                    cb2.apply(this, arguments);
                }
              });
            }
          }
          return fs7;
        }
        function enqueue(elem) {
          debug2("ENQUEUE", elem[0].name, elem[1]);
          fs6[gracefulQueue].push(elem);
          retry2();
        }
        var retryTimer;
        function resetQueue() {
          var now = Date.now();
          for (var i = 0; i < fs6[gracefulQueue].length; ++i) {
            if (fs6[gracefulQueue][i].length > 2) {
              fs6[gracefulQueue][i][3] = now;
              fs6[gracefulQueue][i][4] = now;
            }
          }
          retry2();
        }
        function retry2() {
          clearTimeout(retryTimer);
          retryTimer = void 0;
          if (fs6[gracefulQueue].length === 0)
            return;
          var elem = fs6[gracefulQueue].shift();
          var fn = elem[0];
          var args = elem[1];
          var err = elem[2];
          var startTime = elem[3];
          var lastTime = elem[4];
          if (startTime === void 0) {
            debug2("RETRY", fn.name, args);
            fn.apply(null, args);
          } else if (Date.now() - startTime >= 6e4) {
            debug2("TIMEOUT", fn.name, args);
            var cb = args.pop();
            if (typeof cb === "function")
              cb.call(null, err);
          } else {
            var sinceAttempt = Date.now() - lastTime;
            var sinceStart = Math.max(lastTime - startTime, 1);
            var desiredDelay = Math.min(sinceStart * 1.2, 100);
            if (sinceAttempt >= desiredDelay) {
              debug2("RETRY", fn.name, args);
              fn.apply(null, args.concat([startTime]));
            } else {
              fs6[gracefulQueue].push(elem);
            }
          }
          if (retryTimer === void 0) {
            retryTimer = setTimeout(retry2, 0);
          }
        }
      }
    });
    var require_fs = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/fs/index.js"(exports2) {
        "use strict";
        var u = require_universalify().fromCallback;
        var fs6 = require_graceful_fs();
        var api = [
          "access",
          "appendFile",
          "chmod",
          "chown",
          "close",
          "copyFile",
          "fchmod",
          "fchown",
          "fdatasync",
          "fstat",
          "fsync",
          "ftruncate",
          "futimes",
          "lchmod",
          "lchown",
          "link",
          "lstat",
          "mkdir",
          "mkdtemp",
          "open",
          "opendir",
          "readdir",
          "readFile",
          "readlink",
          "realpath",
          "rename",
          "rm",
          "rmdir",
          "stat",
          "symlink",
          "truncate",
          "unlink",
          "utimes",
          "writeFile"
        ].filter((key) => {
          return typeof fs6[key] === "function";
        });
        Object.assign(exports2, fs6);
        api.forEach((method) => {
          exports2[method] = u(fs6[method]);
        });
        exports2.realpath.native = u(fs6.realpath.native);
        exports2.exists = function(filename, callback) {
          if (typeof callback === "function") {
            return fs6.exists(filename, callback);
          }
          return new Promise((resolve) => {
            return fs6.exists(filename, resolve);
          });
        };
        exports2.read = function(fd, buffer, offset, length, position, callback) {
          if (typeof callback === "function") {
            return fs6.read(fd, buffer, offset, length, position, callback);
          }
          return new Promise((resolve, reject) => {
            fs6.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
              if (err)
                return reject(err);
              resolve({ bytesRead, buffer: buffer2 });
            });
          });
        };
        exports2.write = function(fd, buffer, ...args) {
          if (typeof args[args.length - 1] === "function") {
            return fs6.write(fd, buffer, ...args);
          }
          return new Promise((resolve, reject) => {
            fs6.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
              if (err)
                return reject(err);
              resolve({ bytesWritten, buffer: buffer2 });
            });
          });
        };
        if (typeof fs6.writev === "function") {
          exports2.writev = function(fd, buffers, ...args) {
            if (typeof args[args.length - 1] === "function") {
              return fs6.writev(fd, buffers, ...args);
            }
            return new Promise((resolve, reject) => {
              fs6.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
                if (err)
                  return reject(err);
                resolve({ bytesWritten, buffers: buffers2 });
              });
            });
          };
        }
      }
    });
    var require_utils = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/mkdirs/utils.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        module2.exports.checkPath = function checkPath(pth) {
          if (process.platform === "win32") {
            const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path7.parse(pth).root, ""));
            if (pathHasInvalidWinCharacters) {
              const error = new Error(`Path contains invalid characters: ${pth}`);
              error.code = "EINVAL";
              throw error;
            }
          }
        };
      }
    });
    var require_make_dir = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
        "use strict";
        var fs6 = require_fs();
        var { checkPath } = require_utils();
        var getMode = (options) => {
          const defaults = { mode: 511 };
          if (typeof options === "number")
            return options;
          return { ...defaults, ...options }.mode;
        };
        module2.exports.makeDir = async (dir, options) => {
          checkPath(dir);
          return fs6.mkdir(dir, {
            mode: getMode(options),
            recursive: true
          });
        };
        module2.exports.makeDirSync = (dir, options) => {
          checkPath(dir);
          return fs6.mkdirSync(dir, {
            mode: getMode(options),
            recursive: true
          });
        };
      }
    });
    var require_mkdirs = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromPromise;
        var { makeDir: _makeDir, makeDirSync } = require_make_dir();
        var makeDir = u(_makeDir);
        module2.exports = {
          mkdirs: makeDir,
          mkdirsSync: makeDirSync,
          // alias
          mkdirp: makeDir,
          mkdirpSync: makeDirSync,
          ensureDir: makeDir,
          ensureDirSync: makeDirSync
        };
      }
    });
    var require_utimes = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        function utimesMillis(path7, atime, mtime2, callback) {
          fs6.open(path7, "r+", (err, fd) => {
            if (err)
              return callback(err);
            fs6.futimes(fd, atime, mtime2, (futimesErr) => {
              fs6.close(fd, (closeErr) => {
                if (callback)
                  callback(futimesErr || closeErr);
              });
            });
          });
        }
        function utimesMillisSync(path7, atime, mtime2) {
          const fd = fs6.openSync(path7, "r+");
          fs6.futimesSync(fd, atime, mtime2);
          return fs6.closeSync(fd);
        }
        module2.exports = {
          utimesMillis,
          utimesMillisSync
        };
      }
    });
    var require_stat = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
        "use strict";
        var fs6 = require_fs();
        var path7 = require("path");
        var util = require("util");
        function getStats(src, dest, opts) {
          const statFunc = opts.dereference ? (file) => fs6.stat(file, { bigint: true }) : (file) => fs6.lstat(file, { bigint: true });
          return Promise.all([
            statFunc(src),
            statFunc(dest).catch((err) => {
              if (err.code === "ENOENT")
                return null;
              throw err;
            })
          ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
        }
        function getStatsSync(src, dest, opts) {
          let destStat;
          const statFunc = opts.dereference ? (file) => fs6.statSync(file, { bigint: true }) : (file) => fs6.lstatSync(file, { bigint: true });
          const srcStat = statFunc(src);
          try {
            destStat = statFunc(dest);
          } catch (err) {
            if (err.code === "ENOENT")
              return { srcStat, destStat: null };
            throw err;
          }
          return { srcStat, destStat };
        }
        function checkPaths(src, dest, funcName, opts, cb) {
          util.callbackify(getStats)(src, dest, opts, (err, stats) => {
            if (err)
              return cb(err);
            const { srcStat, destStat } = stats;
            if (destStat) {
              if (areIdentical(srcStat, destStat)) {
                const srcBaseName = path7.basename(src);
                const destBaseName = path7.basename(dest);
                if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
                  return cb(null, { srcStat, destStat, isChangingCase: true });
                }
                return cb(new Error("Source and destination must not be the same."));
              }
              if (srcStat.isDirectory() && !destStat.isDirectory()) {
                return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
              }
              if (!srcStat.isDirectory() && destStat.isDirectory()) {
                return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
              }
            }
            if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
              return cb(new Error(errMsg(src, dest, funcName)));
            }
            return cb(null, { srcStat, destStat });
          });
        }
        function checkPathsSync(src, dest, funcName, opts) {
          const { srcStat, destStat } = getStatsSync(src, dest, opts);
          if (destStat) {
            if (areIdentical(srcStat, destStat)) {
              const srcBaseName = path7.basename(src);
              const destBaseName = path7.basename(dest);
              if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
                return { srcStat, destStat, isChangingCase: true };
              }
              throw new Error("Source and destination must not be the same.");
            }
            if (srcStat.isDirectory() && !destStat.isDirectory()) {
              throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
            }
            if (!srcStat.isDirectory() && destStat.isDirectory()) {
              throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
            }
          }
          if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            throw new Error(errMsg(src, dest, funcName));
          }
          return { srcStat, destStat };
        }
        function checkParentPaths(src, srcStat, dest, funcName, cb) {
          const srcParent = path7.resolve(path7.dirname(src));
          const destParent = path7.resolve(path7.dirname(dest));
          if (destParent === srcParent || destParent === path7.parse(destParent).root)
            return cb();
          fs6.stat(destParent, { bigint: true }, (err, destStat) => {
            if (err) {
              if (err.code === "ENOENT")
                return cb();
              return cb(err);
            }
            if (areIdentical(srcStat, destStat)) {
              return cb(new Error(errMsg(src, dest, funcName)));
            }
            return checkParentPaths(src, srcStat, destParent, funcName, cb);
          });
        }
        function checkParentPathsSync(src, srcStat, dest, funcName) {
          const srcParent = path7.resolve(path7.dirname(src));
          const destParent = path7.resolve(path7.dirname(dest));
          if (destParent === srcParent || destParent === path7.parse(destParent).root)
            return;
          let destStat;
          try {
            destStat = fs6.statSync(destParent, { bigint: true });
          } catch (err) {
            if (err.code === "ENOENT")
              return;
            throw err;
          }
          if (areIdentical(srcStat, destStat)) {
            throw new Error(errMsg(src, dest, funcName));
          }
          return checkParentPathsSync(src, srcStat, destParent, funcName);
        }
        function areIdentical(srcStat, destStat) {
          return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
        }
        function isSrcSubdir(src, dest) {
          const srcArr = path7.resolve(src).split(path7.sep).filter((i) => i);
          const destArr = path7.resolve(dest).split(path7.sep).filter((i) => i);
          return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
        }
        function errMsg(src, dest, funcName) {
          return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
        }
        module2.exports = {
          checkPaths,
          checkPathsSync,
          checkParentPaths,
          checkParentPathsSync,
          isSrcSubdir,
          areIdentical
        };
      }
    });
    var require_copy_sync = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        var path7 = require("path");
        var mkdirsSync = require_mkdirs().mkdirsSync;
        var utimesMillisSync = require_utimes().utimesMillisSync;
        var stat = require_stat();
        function copySync(src, dest, opts) {
          if (typeof opts === "function") {
            opts = { filter: opts };
          }
          opts = opts || {};
          opts.clobber = "clobber" in opts ? !!opts.clobber : true;
          opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
          if (opts.preserveTimestamps && process.arch === "ia32") {
            console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
          }
          const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
          stat.checkParentPathsSync(src, srcStat, dest, "copy");
          return handleFilterAndCopy(destStat, src, dest, opts);
        }
        function handleFilterAndCopy(destStat, src, dest, opts) {
          if (opts.filter && !opts.filter(src, dest))
            return;
          const destParent = path7.dirname(dest);
          if (!fs6.existsSync(destParent))
            mkdirsSync(destParent);
          return getStats(destStat, src, dest, opts);
        }
        function startCopy(destStat, src, dest, opts) {
          if (opts.filter && !opts.filter(src, dest))
            return;
          return getStats(destStat, src, dest, opts);
        }
        function getStats(destStat, src, dest, opts) {
          const statSync2 = opts.dereference ? fs6.statSync : fs6.lstatSync;
          const srcStat = statSync2(src);
          if (srcStat.isDirectory())
            return onDir(srcStat, destStat, src, dest, opts);
          else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
            return onFile(srcStat, destStat, src, dest, opts);
          else if (srcStat.isSymbolicLink())
            return onLink(destStat, src, dest, opts);
          else if (srcStat.isSocket())
            throw new Error(`Cannot copy a socket file: ${src}`);
          else if (srcStat.isFIFO())
            throw new Error(`Cannot copy a FIFO pipe: ${src}`);
          throw new Error(`Unknown file: ${src}`);
        }
        function onFile(srcStat, destStat, src, dest, opts) {
          if (!destStat)
            return copyFile(srcStat, src, dest, opts);
          return mayCopyFile(srcStat, src, dest, opts);
        }
        function mayCopyFile(srcStat, src, dest, opts) {
          if (opts.overwrite) {
            fs6.unlinkSync(dest);
            return copyFile(srcStat, src, dest, opts);
          } else if (opts.errorOnExist) {
            throw new Error(`'${dest}' already exists`);
          }
        }
        function copyFile(srcStat, src, dest, opts) {
          fs6.copyFileSync(src, dest);
          if (opts.preserveTimestamps)
            handleTimestamps(srcStat.mode, src, dest);
          return setDestMode(dest, srcStat.mode);
        }
        function handleTimestamps(srcMode, src, dest) {
          if (fileIsNotWritable(srcMode))
            makeFileWritable(dest, srcMode);
          return setDestTimestamps(src, dest);
        }
        function fileIsNotWritable(srcMode) {
          return (srcMode & 128) === 0;
        }
        function makeFileWritable(dest, srcMode) {
          return setDestMode(dest, srcMode | 128);
        }
        function setDestMode(dest, srcMode) {
          return fs6.chmodSync(dest, srcMode);
        }
        function setDestTimestamps(src, dest) {
          const updatedSrcStat = fs6.statSync(src);
          return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
        }
        function onDir(srcStat, destStat, src, dest, opts) {
          if (!destStat)
            return mkDirAndCopy(srcStat.mode, src, dest, opts);
          return copyDir(src, dest, opts);
        }
        function mkDirAndCopy(srcMode, src, dest, opts) {
          fs6.mkdirSync(dest);
          copyDir(src, dest, opts);
          return setDestMode(dest, srcMode);
        }
        function copyDir(src, dest, opts) {
          fs6.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
        }
        function copyDirItem(item, src, dest, opts) {
          const srcItem = path7.join(src, item);
          const destItem = path7.join(dest, item);
          const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
          return startCopy(destStat, srcItem, destItem, opts);
        }
        function onLink(destStat, src, dest, opts) {
          let resolvedSrc = fs6.readlinkSync(src);
          if (opts.dereference) {
            resolvedSrc = path7.resolve(process.cwd(), resolvedSrc);
          }
          if (!destStat) {
            return fs6.symlinkSync(resolvedSrc, dest);
          } else {
            let resolvedDest;
            try {
              resolvedDest = fs6.readlinkSync(dest);
            } catch (err) {
              if (err.code === "EINVAL" || err.code === "UNKNOWN")
                return fs6.symlinkSync(resolvedSrc, dest);
              throw err;
            }
            if (opts.dereference) {
              resolvedDest = path7.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
            }
            if (fs6.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
            }
            return copyLink(resolvedSrc, dest);
          }
        }
        function copyLink(resolvedSrc, dest) {
          fs6.unlinkSync(dest);
          return fs6.symlinkSync(resolvedSrc, dest);
        }
        module2.exports = copySync;
      }
    });
    var require_copy_sync2 = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          copySync: require_copy_sync()
        };
      }
    });
    var require_path_exists = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromPromise;
        var fs6 = require_fs();
        function pathExists(path7) {
          return fs6.access(path7).then(() => true).catch(() => false);
        }
        module2.exports = {
          pathExists: u(pathExists),
          pathExistsSync: fs6.existsSync
        };
      }
    });
    var require_copy = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        var path7 = require("path");
        var mkdirs = require_mkdirs().mkdirs;
        var pathExists = require_path_exists().pathExists;
        var utimesMillis = require_utimes().utimesMillis;
        var stat = require_stat();
        function copy2(src, dest, opts, cb) {
          if (typeof opts === "function" && !cb) {
            cb = opts;
            opts = {};
          } else if (typeof opts === "function") {
            opts = { filter: opts };
          }
          cb = cb || function() {
          };
          opts = opts || {};
          opts.clobber = "clobber" in opts ? !!opts.clobber : true;
          opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
          if (opts.preserveTimestamps && process.arch === "ia32") {
            console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
          }
          stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
            if (err)
              return cb(err);
            const { srcStat, destStat } = stats;
            stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
              if (err2)
                return cb(err2);
              if (opts.filter)
                return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
              return checkParentDir(destStat, src, dest, opts, cb);
            });
          });
        }
        function checkParentDir(destStat, src, dest, opts, cb) {
          const destParent = path7.dirname(dest);
          pathExists(destParent, (err, dirExists) => {
            if (err)
              return cb(err);
            if (dirExists)
              return getStats(destStat, src, dest, opts, cb);
            mkdirs(destParent, (err2) => {
              if (err2)
                return cb(err2);
              return getStats(destStat, src, dest, opts, cb);
            });
          });
        }
        function handleFilter(onInclude, destStat, src, dest, opts, cb) {
          Promise.resolve(opts.filter(src, dest)).then((include) => {
            if (include)
              return onInclude(destStat, src, dest, opts, cb);
            return cb();
          }, (error) => cb(error));
        }
        function startCopy(destStat, src, dest, opts, cb) {
          if (opts.filter)
            return handleFilter(getStats, destStat, src, dest, opts, cb);
          return getStats(destStat, src, dest, opts, cb);
        }
        function getStats(destStat, src, dest, opts, cb) {
          const stat2 = opts.dereference ? fs6.stat : fs6.lstat;
          stat2(src, (err, srcStat) => {
            if (err)
              return cb(err);
            if (srcStat.isDirectory())
              return onDir(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
              return onFile(srcStat, destStat, src, dest, opts, cb);
            else if (srcStat.isSymbolicLink())
              return onLink(destStat, src, dest, opts, cb);
            else if (srcStat.isSocket())
              return cb(new Error(`Cannot copy a socket file: ${src}`));
            else if (srcStat.isFIFO())
              return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
            return cb(new Error(`Unknown file: ${src}`));
          });
        }
        function onFile(srcStat, destStat, src, dest, opts, cb) {
          if (!destStat)
            return copyFile(srcStat, src, dest, opts, cb);
          return mayCopyFile(srcStat, src, dest, opts, cb);
        }
        function mayCopyFile(srcStat, src, dest, opts, cb) {
          if (opts.overwrite) {
            fs6.unlink(dest, (err) => {
              if (err)
                return cb(err);
              return copyFile(srcStat, src, dest, opts, cb);
            });
          } else if (opts.errorOnExist) {
            return cb(new Error(`'${dest}' already exists`));
          } else
            return cb();
        }
        function copyFile(srcStat, src, dest, opts, cb) {
          fs6.copyFile(src, dest, (err) => {
            if (err)
              return cb(err);
            if (opts.preserveTimestamps)
              return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
            return setDestMode(dest, srcStat.mode, cb);
          });
        }
        function handleTimestampsAndMode(srcMode, src, dest, cb) {
          if (fileIsNotWritable(srcMode)) {
            return makeFileWritable(dest, srcMode, (err) => {
              if (err)
                return cb(err);
              return setDestTimestampsAndMode(srcMode, src, dest, cb);
            });
          }
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        }
        function fileIsNotWritable(srcMode) {
          return (srcMode & 128) === 0;
        }
        function makeFileWritable(dest, srcMode, cb) {
          return setDestMode(dest, srcMode | 128, cb);
        }
        function setDestTimestampsAndMode(srcMode, src, dest, cb) {
          setDestTimestamps(src, dest, (err) => {
            if (err)
              return cb(err);
            return setDestMode(dest, srcMode, cb);
          });
        }
        function setDestMode(dest, srcMode, cb) {
          return fs6.chmod(dest, srcMode, cb);
        }
        function setDestTimestamps(src, dest, cb) {
          fs6.stat(src, (err, updatedSrcStat) => {
            if (err)
              return cb(err);
            return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
          });
        }
        function onDir(srcStat, destStat, src, dest, opts, cb) {
          if (!destStat)
            return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
          return copyDir(src, dest, opts, cb);
        }
        function mkDirAndCopy(srcMode, src, dest, opts, cb) {
          fs6.mkdir(dest, (err) => {
            if (err)
              return cb(err);
            copyDir(src, dest, opts, (err2) => {
              if (err2)
                return cb(err2);
              return setDestMode(dest, srcMode, cb);
            });
          });
        }
        function copyDir(src, dest, opts, cb) {
          fs6.readdir(src, (err, items) => {
            if (err)
              return cb(err);
            return copyDirItems(items, src, dest, opts, cb);
          });
        }
        function copyDirItems(items, src, dest, opts, cb) {
          const item = items.pop();
          if (!item)
            return cb();
          return copyDirItem(items, item, src, dest, opts, cb);
        }
        function copyDirItem(items, item, src, dest, opts, cb) {
          const srcItem = path7.join(src, item);
          const destItem = path7.join(dest, item);
          stat.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
            if (err)
              return cb(err);
            const { destStat } = stats;
            startCopy(destStat, srcItem, destItem, opts, (err2) => {
              if (err2)
                return cb(err2);
              return copyDirItems(items, src, dest, opts, cb);
            });
          });
        }
        function onLink(destStat, src, dest, opts, cb) {
          fs6.readlink(src, (err, resolvedSrc) => {
            if (err)
              return cb(err);
            if (opts.dereference) {
              resolvedSrc = path7.resolve(process.cwd(), resolvedSrc);
            }
            if (!destStat) {
              return fs6.symlink(resolvedSrc, dest, cb);
            } else {
              fs6.readlink(dest, (err2, resolvedDest) => {
                if (err2) {
                  if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                    return fs6.symlink(resolvedSrc, dest, cb);
                  return cb(err2);
                }
                if (opts.dereference) {
                  resolvedDest = path7.resolve(process.cwd(), resolvedDest);
                }
                if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
                  return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
                }
                if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
                  return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
                }
                return copyLink(resolvedSrc, dest, cb);
              });
            }
          });
        }
        function copyLink(resolvedSrc, dest, cb) {
          fs6.unlink(dest, (err) => {
            if (err)
              return cb(err);
            return fs6.symlink(resolvedSrc, dest, cb);
          });
        }
        module2.exports = copy2;
      }
    });
    var require_copy2 = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromCallback;
        module2.exports = {
          copy: u(require_copy())
        };
      }
    });
    var require_rimraf = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        var path7 = require("path");
        var assert7 = require("assert");
        var isWindows = process.platform === "win32";
        function defaults(options) {
          const methods = [
            "unlink",
            "chmod",
            "stat",
            "lstat",
            "rmdir",
            "readdir"
          ];
          methods.forEach((m) => {
            options[m] = options[m] || fs6[m];
            m = m + "Sync";
            options[m] = options[m] || fs6[m];
          });
          options.maxBusyTries = options.maxBusyTries || 3;
        }
        function rimraf(p, options, cb) {
          let busyTries = 0;
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          assert7(p, "rimraf: missing path");
          assert7.strictEqual(typeof p, "string", "rimraf: path should be a string");
          assert7.strictEqual(typeof cb, "function", "rimraf: callback function required");
          assert7(options, "rimraf: invalid options argument provided");
          assert7.strictEqual(typeof options, "object", "rimraf: options should be object");
          defaults(options);
          rimraf_(p, options, function CB(er) {
            if (er) {
              if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                const time = busyTries * 100;
                return setTimeout(() => rimraf_(p, options, CB), time);
              }
              if (er.code === "ENOENT")
                er = null;
            }
            cb(er);
          });
        }
        function rimraf_(p, options, cb) {
          assert7(p);
          assert7(options);
          assert7(typeof cb === "function");
          options.lstat(p, (er, st) => {
            if (er && er.code === "ENOENT") {
              return cb(null);
            }
            if (er && er.code === "EPERM" && isWindows) {
              return fixWinEPERM(p, options, er, cb);
            }
            if (st && st.isDirectory()) {
              return rmdir(p, options, er, cb);
            }
            options.unlink(p, (er2) => {
              if (er2) {
                if (er2.code === "ENOENT") {
                  return cb(null);
                }
                if (er2.code === "EPERM") {
                  return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
                }
                if (er2.code === "EISDIR") {
                  return rmdir(p, options, er2, cb);
                }
              }
              return cb(er2);
            });
          });
        }
        function fixWinEPERM(p, options, er, cb) {
          assert7(p);
          assert7(options);
          assert7(typeof cb === "function");
          options.chmod(p, 438, (er2) => {
            if (er2) {
              cb(er2.code === "ENOENT" ? null : er);
            } else {
              options.stat(p, (er3, stats) => {
                if (er3) {
                  cb(er3.code === "ENOENT" ? null : er);
                } else if (stats.isDirectory()) {
                  rmdir(p, options, er, cb);
                } else {
                  options.unlink(p, cb);
                }
              });
            }
          });
        }
        function fixWinEPERMSync(p, options, er) {
          let stats;
          assert7(p);
          assert7(options);
          try {
            options.chmodSync(p, 438);
          } catch (er2) {
            if (er2.code === "ENOENT") {
              return;
            } else {
              throw er;
            }
          }
          try {
            stats = options.statSync(p);
          } catch (er3) {
            if (er3.code === "ENOENT") {
              return;
            } else {
              throw er;
            }
          }
          if (stats.isDirectory()) {
            rmdirSync(p, options, er);
          } else {
            options.unlinkSync(p);
          }
        }
        function rmdir(p, options, originalEr, cb) {
          assert7(p);
          assert7(options);
          assert7(typeof cb === "function");
          options.rmdir(p, (er) => {
            if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
              rmkids(p, options, cb);
            } else if (er && er.code === "ENOTDIR") {
              cb(originalEr);
            } else {
              cb(er);
            }
          });
        }
        function rmkids(p, options, cb) {
          assert7(p);
          assert7(options);
          assert7(typeof cb === "function");
          options.readdir(p, (er, files) => {
            if (er)
              return cb(er);
            let n = files.length;
            let errState;
            if (n === 0)
              return options.rmdir(p, cb);
            files.forEach((f) => {
              rimraf(path7.join(p, f), options, (er2) => {
                if (errState) {
                  return;
                }
                if (er2)
                  return cb(errState = er2);
                if (--n === 0) {
                  options.rmdir(p, cb);
                }
              });
            });
          });
        }
        function rimrafSync(p, options) {
          let st;
          options = options || {};
          defaults(options);
          assert7(p, "rimraf: missing path");
          assert7.strictEqual(typeof p, "string", "rimraf: path should be a string");
          assert7(options, "rimraf: missing options");
          assert7.strictEqual(typeof options, "object", "rimraf: options should be object");
          try {
            st = options.lstatSync(p);
          } catch (er) {
            if (er.code === "ENOENT") {
              return;
            }
            if (er.code === "EPERM" && isWindows) {
              fixWinEPERMSync(p, options, er);
            }
          }
          try {
            if (st && st.isDirectory()) {
              rmdirSync(p, options, null);
            } else {
              options.unlinkSync(p);
            }
          } catch (er) {
            if (er.code === "ENOENT") {
              return;
            } else if (er.code === "EPERM") {
              return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
            } else if (er.code !== "EISDIR") {
              throw er;
            }
            rmdirSync(p, options, er);
          }
        }
        function rmdirSync(p, options, originalEr) {
          assert7(p);
          assert7(options);
          try {
            options.rmdirSync(p);
          } catch (er) {
            if (er.code === "ENOTDIR") {
              throw originalEr;
            } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
              rmkidsSync(p, options);
            } else if (er.code !== "ENOENT") {
              throw er;
            }
          }
        }
        function rmkidsSync(p, options) {
          assert7(p);
          assert7(options);
          options.readdirSync(p).forEach((f) => rimrafSync(path7.join(p, f), options));
          if (isWindows) {
            const startTime = Date.now();
            do {
              try {
                const ret = options.rmdirSync(p, options);
                return ret;
              } catch {
              }
            } while (Date.now() - startTime < 500);
          } else {
            const ret = options.rmdirSync(p, options);
            return ret;
          }
        }
        module2.exports = rimraf;
        rimraf.sync = rimrafSync;
      }
    });
    var require_remove = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        var u = require_universalify().fromCallback;
        var rimraf = require_rimraf();
        function remove2(path7, callback) {
          if (fs6.rm)
            return fs6.rm(path7, { recursive: true, force: true }, callback);
          rimraf(path7, callback);
        }
        function removeSync(path7) {
          if (fs6.rmSync)
            return fs6.rmSync(path7, { recursive: true, force: true });
          rimraf.sync(path7);
        }
        module2.exports = {
          remove: u(remove2),
          removeSync
        };
      }
    });
    var require_empty = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromPromise;
        var fs6 = require_fs();
        var path7 = require("path");
        var mkdir = require_mkdirs();
        var remove2 = require_remove();
        var emptyDir = u(async function emptyDir2(dir) {
          let items;
          try {
            items = await fs6.readdir(dir);
          } catch {
            return mkdir.mkdirs(dir);
          }
          return Promise.all(items.map((item) => remove2.remove(path7.join(dir, item))));
        });
        function emptyDirSync(dir) {
          let items;
          try {
            items = fs6.readdirSync(dir);
          } catch {
            return mkdir.mkdirsSync(dir);
          }
          items.forEach((item) => {
            item = path7.join(dir, item);
            remove2.removeSync(item);
          });
        }
        module2.exports = {
          emptyDirSync,
          emptydirSync: emptyDirSync,
          emptyDir,
          emptydir: emptyDir
        };
      }
    });
    var require_file = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromCallback;
        var path7 = require("path");
        var fs6 = require_graceful_fs();
        var mkdir = require_mkdirs();
        function createFile(file, callback) {
          function makeFile() {
            fs6.writeFile(file, "", (err) => {
              if (err)
                return callback(err);
              callback();
            });
          }
          fs6.stat(file, (err, stats) => {
            if (!err && stats.isFile())
              return callback();
            const dir = path7.dirname(file);
            fs6.stat(dir, (err2, stats2) => {
              if (err2) {
                if (err2.code === "ENOENT") {
                  return mkdir.mkdirs(dir, (err3) => {
                    if (err3)
                      return callback(err3);
                    makeFile();
                  });
                }
                return callback(err2);
              }
              if (stats2.isDirectory())
                makeFile();
              else {
                fs6.readdir(dir, (err3) => {
                  if (err3)
                    return callback(err3);
                });
              }
            });
          });
        }
        function createFileSync(file) {
          let stats;
          try {
            stats = fs6.statSync(file);
          } catch {
          }
          if (stats && stats.isFile())
            return;
          const dir = path7.dirname(file);
          try {
            if (!fs6.statSync(dir).isDirectory()) {
              fs6.readdirSync(dir);
            }
          } catch (err) {
            if (err && err.code === "ENOENT")
              mkdir.mkdirsSync(dir);
            else
              throw err;
          }
          fs6.writeFileSync(file, "");
        }
        module2.exports = {
          createFile: u(createFile),
          createFileSync
        };
      }
    });
    var require_link = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromCallback;
        var path7 = require("path");
        var fs6 = require_graceful_fs();
        var mkdir = require_mkdirs();
        var pathExists = require_path_exists().pathExists;
        var { areIdentical } = require_stat();
        function createLink(srcpath, dstpath, callback) {
          function makeLink(srcpath2, dstpath2) {
            fs6.link(srcpath2, dstpath2, (err) => {
              if (err)
                return callback(err);
              callback(null);
            });
          }
          fs6.lstat(dstpath, (_, dstStat) => {
            fs6.lstat(srcpath, (err, srcStat) => {
              if (err) {
                err.message = err.message.replace("lstat", "ensureLink");
                return callback(err);
              }
              if (dstStat && areIdentical(srcStat, dstStat))
                return callback(null);
              const dir = path7.dirname(dstpath);
              pathExists(dir, (err2, dirExists) => {
                if (err2)
                  return callback(err2);
                if (dirExists)
                  return makeLink(srcpath, dstpath);
                mkdir.mkdirs(dir, (err3) => {
                  if (err3)
                    return callback(err3);
                  makeLink(srcpath, dstpath);
                });
              });
            });
          });
        }
        function createLinkSync(srcpath, dstpath) {
          let dstStat;
          try {
            dstStat = fs6.lstatSync(dstpath);
          } catch {
          }
          try {
            const srcStat = fs6.lstatSync(srcpath);
            if (dstStat && areIdentical(srcStat, dstStat))
              return;
          } catch (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            throw err;
          }
          const dir = path7.dirname(dstpath);
          const dirExists = fs6.existsSync(dir);
          if (dirExists)
            return fs6.linkSync(srcpath, dstpath);
          mkdir.mkdirsSync(dir);
          return fs6.linkSync(srcpath, dstpath);
        }
        module2.exports = {
          createLink: u(createLink),
          createLinkSync
        };
      }
    });
    var require_symlink_paths = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var fs6 = require_graceful_fs();
        var pathExists = require_path_exists().pathExists;
        function symlinkPaths(srcpath, dstpath, callback) {
          if (path7.isAbsolute(srcpath)) {
            return fs6.lstat(srcpath, (err) => {
              if (err) {
                err.message = err.message.replace("lstat", "ensureSymlink");
                return callback(err);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: srcpath
              });
            });
          } else {
            const dstdir = path7.dirname(dstpath);
            const relativeToDst = path7.join(dstdir, srcpath);
            return pathExists(relativeToDst, (err, exists) => {
              if (err)
                return callback(err);
              if (exists) {
                return callback(null, {
                  toCwd: relativeToDst,
                  toDst: srcpath
                });
              } else {
                return fs6.lstat(srcpath, (err2) => {
                  if (err2) {
                    err2.message = err2.message.replace("lstat", "ensureSymlink");
                    return callback(err2);
                  }
                  return callback(null, {
                    toCwd: srcpath,
                    toDst: path7.relative(dstdir, srcpath)
                  });
                });
              }
            });
          }
        }
        function symlinkPathsSync(srcpath, dstpath) {
          let exists;
          if (path7.isAbsolute(srcpath)) {
            exists = fs6.existsSync(srcpath);
            if (!exists)
              throw new Error("absolute srcpath does not exist");
            return {
              toCwd: srcpath,
              toDst: srcpath
            };
          } else {
            const dstdir = path7.dirname(dstpath);
            const relativeToDst = path7.join(dstdir, srcpath);
            exists = fs6.existsSync(relativeToDst);
            if (exists) {
              return {
                toCwd: relativeToDst,
                toDst: srcpath
              };
            } else {
              exists = fs6.existsSync(srcpath);
              if (!exists)
                throw new Error("relative srcpath does not exist");
              return {
                toCwd: srcpath,
                toDst: path7.relative(dstdir, srcpath)
              };
            }
          }
        }
        module2.exports = {
          symlinkPaths,
          symlinkPathsSync
        };
      }
    });
    var require_symlink_type = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        function symlinkType(srcpath, type, callback) {
          callback = typeof type === "function" ? type : callback;
          type = typeof type === "function" ? false : type;
          if (type)
            return callback(null, type);
          fs6.lstat(srcpath, (err, stats) => {
            if (err)
              return callback(null, "file");
            type = stats && stats.isDirectory() ? "dir" : "file";
            callback(null, type);
          });
        }
        function symlinkTypeSync(srcpath, type) {
          let stats;
          if (type)
            return type;
          try {
            stats = fs6.lstatSync(srcpath);
          } catch {
            return "file";
          }
          return stats && stats.isDirectory() ? "dir" : "file";
        }
        module2.exports = {
          symlinkType,
          symlinkTypeSync
        };
      }
    });
    var require_symlink = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromCallback;
        var path7 = require("path");
        var fs6 = require_fs();
        var _mkdirs = require_mkdirs();
        var mkdirs = _mkdirs.mkdirs;
        var mkdirsSync = _mkdirs.mkdirsSync;
        var _symlinkPaths = require_symlink_paths();
        var symlinkPaths = _symlinkPaths.symlinkPaths;
        var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
        var _symlinkType = require_symlink_type();
        var symlinkType = _symlinkType.symlinkType;
        var symlinkTypeSync = _symlinkType.symlinkTypeSync;
        var pathExists = require_path_exists().pathExists;
        var { areIdentical } = require_stat();
        function createSymlink(srcpath, dstpath, type, callback) {
          callback = typeof type === "function" ? type : callback;
          type = typeof type === "function" ? false : type;
          fs6.lstat(dstpath, (err, stats) => {
            if (!err && stats.isSymbolicLink()) {
              Promise.all([
                fs6.stat(srcpath),
                fs6.stat(dstpath)
              ]).then(([srcStat, dstStat]) => {
                if (areIdentical(srcStat, dstStat))
                  return callback(null);
                _createSymlink(srcpath, dstpath, type, callback);
              });
            } else
              _createSymlink(srcpath, dstpath, type, callback);
          });
        }
        function _createSymlink(srcpath, dstpath, type, callback) {
          symlinkPaths(srcpath, dstpath, (err, relative) => {
            if (err)
              return callback(err);
            srcpath = relative.toDst;
            symlinkType(relative.toCwd, type, (err2, type2) => {
              if (err2)
                return callback(err2);
              const dir = path7.dirname(dstpath);
              pathExists(dir, (err3, dirExists) => {
                if (err3)
                  return callback(err3);
                if (dirExists)
                  return fs6.symlink(srcpath, dstpath, type2, callback);
                mkdirs(dir, (err4) => {
                  if (err4)
                    return callback(err4);
                  fs6.symlink(srcpath, dstpath, type2, callback);
                });
              });
            });
          });
        }
        function createSymlinkSync(srcpath, dstpath, type) {
          let stats;
          try {
            stats = fs6.lstatSync(dstpath);
          } catch {
          }
          if (stats && stats.isSymbolicLink()) {
            const srcStat = fs6.statSync(srcpath);
            const dstStat = fs6.statSync(dstpath);
            if (areIdentical(srcStat, dstStat))
              return;
          }
          const relative = symlinkPathsSync(srcpath, dstpath);
          srcpath = relative.toDst;
          type = symlinkTypeSync(relative.toCwd, type);
          const dir = path7.dirname(dstpath);
          const exists = fs6.existsSync(dir);
          if (exists)
            return fs6.symlinkSync(srcpath, dstpath, type);
          mkdirsSync(dir);
          return fs6.symlinkSync(srcpath, dstpath, type);
        }
        module2.exports = {
          createSymlink: u(createSymlink),
          createSymlinkSync
        };
      }
    });
    var require_ensure = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
        "use strict";
        var file = require_file();
        var link = require_link();
        var symlink2 = require_symlink();
        module2.exports = {
          // file
          createFile: file.createFile,
          createFileSync: file.createFileSync,
          ensureFile: file.createFile,
          ensureFileSync: file.createFileSync,
          // link
          createLink: link.createLink,
          createLinkSync: link.createLinkSync,
          ensureLink: link.createLink,
          ensureLinkSync: link.createLinkSync,
          // symlink
          createSymlink: symlink2.createSymlink,
          createSymlinkSync: symlink2.createSymlinkSync,
          ensureSymlink: symlink2.createSymlink,
          ensureSymlinkSync: symlink2.createSymlinkSync
        };
      }
    });
    var require_utils2 = __commonJS({
      "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports2, module2) {
        function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
          const EOF = finalEOL ? EOL : "";
          const str = JSON.stringify(obj, replacer, spaces);
          return str.replace(/\n/g, EOL) + EOF;
        }
        function stripBom(content) {
          if (Buffer.isBuffer(content))
            content = content.toString("utf8");
          return content.replace(/^\uFEFF/, "");
        }
        module2.exports = { stringify, stripBom };
      }
    });
    var require_jsonfile = __commonJS({
      "../../node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports2, module2) {
        var _fs;
        try {
          _fs = require_graceful_fs();
        } catch (_) {
          _fs = require("fs");
        }
        var universalify = require_universalify();
        var { stringify, stripBom } = require_utils2();
        async function _readFile(file, options = {}) {
          if (typeof options === "string") {
            options = { encoding: options };
          }
          const fs6 = options.fs || _fs;
          const shouldThrow = "throws" in options ? options.throws : true;
          let data = await universalify.fromCallback(fs6.readFile)(file, options);
          data = stripBom(data);
          let obj;
          try {
            obj = JSON.parse(data, options ? options.reviver : null);
          } catch (err) {
            if (shouldThrow) {
              err.message = `${file}: ${err.message}`;
              throw err;
            } else {
              return null;
            }
          }
          return obj;
        }
        var readFile4 = universalify.fromPromise(_readFile);
        function readFileSync(file, options = {}) {
          if (typeof options === "string") {
            options = { encoding: options };
          }
          const fs6 = options.fs || _fs;
          const shouldThrow = "throws" in options ? options.throws : true;
          try {
            let content = fs6.readFileSync(file, options);
            content = stripBom(content);
            return JSON.parse(content, options.reviver);
          } catch (err) {
            if (shouldThrow) {
              err.message = `${file}: ${err.message}`;
              throw err;
            } else {
              return null;
            }
          }
        }
        async function _writeFile(file, obj, options = {}) {
          const fs6 = options.fs || _fs;
          const str = stringify(obj, options);
          await universalify.fromCallback(fs6.writeFile)(file, str, options);
        }
        var writeFile = universalify.fromPromise(_writeFile);
        function writeFileSync(file, obj, options = {}) {
          const fs6 = options.fs || _fs;
          const str = stringify(obj, options);
          return fs6.writeFileSync(file, str, options);
        }
        var jsonfile = {
          readFile: readFile4,
          readFileSync,
          writeFile,
          writeFileSync
        };
        module2.exports = jsonfile;
      }
    });
    var require_jsonfile2 = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
        "use strict";
        var jsonFile = require_jsonfile();
        module2.exports = {
          // jsonfile exports
          readJson: jsonFile.readFile,
          readJsonSync: jsonFile.readFileSync,
          writeJson: jsonFile.writeFile,
          writeJsonSync: jsonFile.writeFileSync
        };
      }
    });
    var require_output = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromCallback;
        var fs6 = require_graceful_fs();
        var path7 = require("path");
        var mkdir = require_mkdirs();
        var pathExists = require_path_exists().pathExists;
        function outputFile(file, data, encoding, callback) {
          if (typeof encoding === "function") {
            callback = encoding;
            encoding = "utf8";
          }
          const dir = path7.dirname(file);
          pathExists(dir, (err, itDoes) => {
            if (err)
              return callback(err);
            if (itDoes)
              return fs6.writeFile(file, data, encoding, callback);
            mkdir.mkdirs(dir, (err2) => {
              if (err2)
                return callback(err2);
              fs6.writeFile(file, data, encoding, callback);
            });
          });
        }
        function outputFileSync(file, ...args) {
          const dir = path7.dirname(file);
          if (fs6.existsSync(dir)) {
            return fs6.writeFileSync(file, ...args);
          }
          mkdir.mkdirsSync(dir);
          fs6.writeFileSync(file, ...args);
        }
        module2.exports = {
          outputFile: u(outputFile),
          outputFileSync
        };
      }
    });
    var require_output_json = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
        "use strict";
        var { stringify } = require_utils2();
        var { outputFile } = require_output();
        async function outputJson(file, data, options = {}) {
          const str = stringify(data, options);
          await outputFile(file, str, options);
        }
        module2.exports = outputJson;
      }
    });
    var require_output_json_sync = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
        "use strict";
        var { stringify } = require_utils2();
        var { outputFileSync } = require_output();
        function outputJsonSync(file, data, options) {
          const str = stringify(data, options);
          outputFileSync(file, str, options);
        }
        module2.exports = outputJsonSync;
      }
    });
    var require_json = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromPromise;
        var jsonFile = require_jsonfile2();
        jsonFile.outputJson = u(require_output_json());
        jsonFile.outputJsonSync = require_output_json_sync();
        jsonFile.outputJSON = jsonFile.outputJson;
        jsonFile.outputJSONSync = jsonFile.outputJsonSync;
        jsonFile.writeJSON = jsonFile.writeJson;
        jsonFile.writeJSONSync = jsonFile.writeJsonSync;
        jsonFile.readJSON = jsonFile.readJson;
        jsonFile.readJSONSync = jsonFile.readJsonSync;
        module2.exports = jsonFile;
      }
    });
    var require_move_sync = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        var path7 = require("path");
        var copySync = require_copy_sync2().copySync;
        var removeSync = require_remove().removeSync;
        var mkdirpSync = require_mkdirs().mkdirpSync;
        var stat = require_stat();
        function moveSync(src, dest, opts) {
          opts = opts || {};
          const overwrite = opts.overwrite || opts.clobber || false;
          const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
          stat.checkParentPathsSync(src, srcStat, dest, "move");
          if (!isParentRoot(dest))
            mkdirpSync(path7.dirname(dest));
          return doRename(src, dest, overwrite, isChangingCase);
        }
        function isParentRoot(dest) {
          const parent = path7.dirname(dest);
          const parsedPath = path7.parse(parent);
          return parsedPath.root === parent;
        }
        function doRename(src, dest, overwrite, isChangingCase) {
          if (isChangingCase)
            return rename2(src, dest, overwrite);
          if (overwrite) {
            removeSync(dest);
            return rename2(src, dest, overwrite);
          }
          if (fs6.existsSync(dest))
            throw new Error("dest already exists.");
          return rename2(src, dest, overwrite);
        }
        function rename2(src, dest, overwrite) {
          try {
            fs6.renameSync(src, dest);
          } catch (err) {
            if (err.code !== "EXDEV")
              throw err;
            return moveAcrossDevice(src, dest, overwrite);
          }
        }
        function moveAcrossDevice(src, dest, overwrite) {
          const opts = {
            overwrite,
            errorOnExist: true
          };
          copySync(src, dest, opts);
          return removeSync(src);
        }
        module2.exports = moveSync;
      }
    });
    var require_move_sync2 = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          moveSync: require_move_sync()
        };
      }
    });
    var require_move = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
        "use strict";
        var fs6 = require_graceful_fs();
        var path7 = require("path");
        var copy2 = require_copy2().copy;
        var remove2 = require_remove().remove;
        var mkdirp3 = require_mkdirs().mkdirp;
        var pathExists = require_path_exists().pathExists;
        var stat = require_stat();
        function move(src, dest, opts, cb) {
          if (typeof opts === "function") {
            cb = opts;
            opts = {};
          }
          const overwrite = opts.overwrite || opts.clobber || false;
          stat.checkPaths(src, dest, "move", opts, (err, stats) => {
            if (err)
              return cb(err);
            const { srcStat, isChangingCase = false } = stats;
            stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
              if (err2)
                return cb(err2);
              if (isParentRoot(dest))
                return doRename(src, dest, overwrite, isChangingCase, cb);
              mkdirp3(path7.dirname(dest), (err3) => {
                if (err3)
                  return cb(err3);
                return doRename(src, dest, overwrite, isChangingCase, cb);
              });
            });
          });
        }
        function isParentRoot(dest) {
          const parent = path7.dirname(dest);
          const parsedPath = path7.parse(parent);
          return parsedPath.root === parent;
        }
        function doRename(src, dest, overwrite, isChangingCase, cb) {
          if (isChangingCase)
            return rename2(src, dest, overwrite, cb);
          if (overwrite) {
            return remove2(dest, (err) => {
              if (err)
                return cb(err);
              return rename2(src, dest, overwrite, cb);
            });
          }
          pathExists(dest, (err, destExists) => {
            if (err)
              return cb(err);
            if (destExists)
              return cb(new Error("dest already exists."));
            return rename2(src, dest, overwrite, cb);
          });
        }
        function rename2(src, dest, overwrite, cb) {
          fs6.rename(src, dest, (err) => {
            if (!err)
              return cb();
            if (err.code !== "EXDEV")
              return cb(err);
            return moveAcrossDevice(src, dest, overwrite, cb);
          });
        }
        function moveAcrossDevice(src, dest, overwrite, cb) {
          const opts = {
            overwrite,
            errorOnExist: true
          };
          copy2(src, dest, opts, (err) => {
            if (err)
              return cb(err);
            return remove2(src, cb);
          });
        }
        module2.exports = move;
      }
    });
    var require_move2 = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
        "use strict";
        var u = require_universalify().fromCallback;
        module2.exports = {
          move: u(require_move())
        };
      }
    });
    var require_lib = __commonJS({
      "../../node_modules/.pnpm/fs-extra@10.0.0/node_modules/fs-extra/lib/index.js"(exports2, module2) {
        "use strict";
        module2.exports = {
          // Export promiseified graceful-fs:
          ...require_fs(),
          // Export extra methods:
          ...require_copy_sync2(),
          ...require_copy2(),
          ...require_empty(),
          ...require_ensure(),
          ...require_json(),
          ...require_mkdirs(),
          ...require_move_sync2(),
          ...require_move2(),
          ...require_output(),
          ...require_path_exists(),
          ...require_remove()
        };
      }
    });
    var require_multistream = __commonJS({
      "../../node_modules/.pnpm/multistream@2.1.1/node_modules/multistream/index.js"(exports2, module2) {
        module2.exports = MultiStream;
        var inherits = require_inherits();
        var stream = require_readable();
        inherits(MultiStream, stream.Readable);
        function MultiStream(streams, opts) {
          var self2 = this;
          if (!(self2 instanceof MultiStream))
            return new MultiStream(streams, opts);
          stream.Readable.call(self2, opts);
          self2.destroyed = false;
          self2._drained = false;
          self2._forwarding = false;
          self2._current = null;
          self2._toStreams2 = opts && opts.objectMode ? toStreams2Obj : toStreams2Buf;
          if (typeof streams === "function") {
            self2._queue = streams;
          } else {
            self2._queue = streams.map(self2._toStreams2);
            self2._queue.forEach(function(stream2) {
              if (typeof stream2 !== "function")
                self2._attachErrorListener(stream2);
            });
          }
          self2._next();
        }
        MultiStream.obj = function(streams) {
          return new MultiStream(streams, { objectMode: true, highWaterMark: 16 });
        };
        MultiStream.prototype._read = function() {
          this._drained = true;
          this._forward();
        };
        MultiStream.prototype._forward = function() {
          if (this._forwarding || !this._drained || !this._current)
            return;
          this._forwarding = true;
          var chunk;
          while ((chunk = this._current.read()) !== null) {
            this._drained = this.push(chunk);
          }
          this._forwarding = false;
        };
        MultiStream.prototype.destroy = function(err) {
          if (this.destroyed)
            return;
          this.destroyed = true;
          if (this._current && this._current.destroy)
            this._current.destroy();
          if (typeof this._queue !== "function") {
            this._queue.forEach(function(stream2) {
              if (stream2.destroy)
                stream2.destroy();
            });
          }
          if (err)
            this.emit("error", err);
          this.emit("close");
        };
        MultiStream.prototype._next = function() {
          var self2 = this;
          self2._current = null;
          if (typeof self2._queue === "function") {
            self2._queue(function(err, stream3) {
              if (err)
                return self2.destroy(err);
              stream3 = self2._toStreams2(stream3);
              self2._attachErrorListener(stream3);
              self2._gotNextStream(stream3);
            });
          } else {
            var stream2 = self2._queue.shift();
            if (typeof stream2 === "function") {
              stream2 = self2._toStreams2(stream2());
              self2._attachErrorListener(stream2);
            }
            self2._gotNextStream(stream2);
          }
        };
        MultiStream.prototype._gotNextStream = function(stream2) {
          var self2 = this;
          if (!stream2) {
            self2.push(null);
            self2.destroy();
            return;
          }
          self2._current = stream2;
          self2._forward();
          stream2.on("readable", onReadable);
          stream2.once("end", onEnd);
          stream2.once("close", onClose);
          function onReadable() {
            self2._forward();
          }
          function onClose() {
            if (!stream2._readableState.ended) {
              self2.destroy();
            }
          }
          function onEnd() {
            self2._current = null;
            stream2.removeListener("readable", onReadable);
            stream2.removeListener("end", onEnd);
            stream2.removeListener("close", onClose);
            self2._next();
          }
        };
        MultiStream.prototype._attachErrorListener = function(stream2) {
          var self2 = this;
          if (!stream2)
            return;
          stream2.once("error", onError);
          function onError(err) {
            stream2.removeListener("error", onError);
            self2.destroy(err);
          }
        };
        function toStreams2Obj(s) {
          return toStreams2(s, { objectMode: true, highWaterMark: 16 });
        }
        function toStreams2Buf(s) {
          return toStreams2(s);
        }
        function toStreams2(s, opts) {
          if (!s || typeof s === "function" || s._readableState)
            return s;
          var wrap = new stream.Readable(opts).wrap(s);
          if (s.destroy) {
            wrap.destroy = s.destroy.bind(s);
          }
          return wrap;
        }
      }
    });
    var require_deque = __commonJS({
      "../../node_modules/.pnpm/double-ended-queue@2.1.0-0/node_modules/double-ended-queue/js/deque.js"(exports2, module2) {
        "use strict";
        function Deque(capacity) {
          this._capacity = getCapacity(capacity);
          this._length = 0;
          this._front = 0;
          if (isArray(capacity)) {
            var len = capacity.length;
            for (var i = 0; i < len; ++i) {
              this[i] = capacity[i];
            }
            this._length = len;
          }
        }
        Deque.prototype.toArray = function Deque$toArray() {
          var len = this._length;
          var ret = new Array(len);
          var front = this._front;
          var capacity = this._capacity;
          for (var j = 0; j < len; ++j) {
            ret[j] = this[front + j & capacity - 1];
          }
          return ret;
        };
        Deque.prototype.push = function Deque$push(item) {
          var argsLength = arguments.length;
          var length = this._length;
          if (argsLength > 1) {
            var capacity = this._capacity;
            if (length + argsLength > capacity) {
              for (var i = 0; i < argsLength; ++i) {
                this._checkCapacity(length + 1);
                var j = this._front + length & this._capacity - 1;
                this[j] = arguments[i];
                length++;
                this._length = length;
              }
              return length;
            } else {
              var j = this._front;
              for (var i = 0; i < argsLength; ++i) {
                this[j + length & capacity - 1] = arguments[i];
                j++;
              }
              this._length = length + argsLength;
              return length + argsLength;
            }
          }
          if (argsLength === 0)
            return length;
          this._checkCapacity(length + 1);
          var i = this._front + length & this._capacity - 1;
          this[i] = item;
          this._length = length + 1;
          return length + 1;
        };
        Deque.prototype.pop = function Deque$pop() {
          var length = this._length;
          if (length === 0) {
            return void 0;
          }
          var i = this._front + length - 1 & this._capacity - 1;
          var ret = this[i];
          this[i] = void 0;
          this._length = length - 1;
          return ret;
        };
        Deque.prototype.shift = function Deque$shift() {
          var length = this._length;
          if (length === 0) {
            return void 0;
          }
          var front = this._front;
          var ret = this[front];
          this[front] = void 0;
          this._front = front + 1 & this._capacity - 1;
          this._length = length - 1;
          return ret;
        };
        Deque.prototype.unshift = function Deque$unshift(item) {
          var length = this._length;
          var argsLength = arguments.length;
          if (argsLength > 1) {
            var capacity = this._capacity;
            if (length + argsLength > capacity) {
              for (var i = argsLength - 1; i >= 0; i--) {
                this._checkCapacity(length + 1);
                var capacity = this._capacity;
                var j = (this._front - 1 & capacity - 1 ^ capacity) - capacity;
                this[j] = arguments[i];
                length++;
                this._length = length;
                this._front = j;
              }
              return length;
            } else {
              var front = this._front;
              for (var i = argsLength - 1; i >= 0; i--) {
                var j = (front - 1 & capacity - 1 ^ capacity) - capacity;
                this[j] = arguments[i];
                front = j;
              }
              this._front = front;
              this._length = length + argsLength;
              return length + argsLength;
            }
          }
          if (argsLength === 0)
            return length;
          this._checkCapacity(length + 1);
          var capacity = this._capacity;
          var i = (this._front - 1 & capacity - 1 ^ capacity) - capacity;
          this[i] = item;
          this._length = length + 1;
          this._front = i;
          return length + 1;
        };
        Deque.prototype.peekBack = function Deque$peekBack() {
          var length = this._length;
          if (length === 0) {
            return void 0;
          }
          var index = this._front + length - 1 & this._capacity - 1;
          return this[index];
        };
        Deque.prototype.peekFront = function Deque$peekFront() {
          if (this._length === 0) {
            return void 0;
          }
          return this[this._front];
        };
        Deque.prototype.get = function Deque$get(index) {
          var i = index;
          if (i !== (i | 0)) {
            return void 0;
          }
          var len = this._length;
          if (i < 0) {
            i = i + len;
          }
          if (i < 0 || i >= len) {
            return void 0;
          }
          return this[this._front + i & this._capacity - 1];
        };
        Deque.prototype.isEmpty = function Deque$isEmpty() {
          return this._length === 0;
        };
        Deque.prototype.clear = function Deque$clear() {
          var len = this._length;
          var front = this._front;
          var capacity = this._capacity;
          for (var j = 0; j < len; ++j) {
            this[front + j & capacity - 1] = void 0;
          }
          this._length = 0;
          this._front = 0;
        };
        Deque.prototype.toString = function Deque$toString() {
          return this.toArray().toString();
        };
        Deque.prototype.valueOf = Deque.prototype.toString;
        Deque.prototype.removeFront = Deque.prototype.shift;
        Deque.prototype.removeBack = Deque.prototype.pop;
        Deque.prototype.insertFront = Deque.prototype.unshift;
        Deque.prototype.insertBack = Deque.prototype.push;
        Deque.prototype.enqueue = Deque.prototype.push;
        Deque.prototype.dequeue = Deque.prototype.shift;
        Deque.prototype.toJSON = Deque.prototype.toArray;
        Object.defineProperty(Deque.prototype, "length", {
          get: function() {
            return this._length;
          },
          set: function() {
            throw new RangeError("");
          }
        });
        Deque.prototype._checkCapacity = function Deque$_checkCapacity(size) {
          if (this._capacity < size) {
            this._resizeTo(getCapacity(this._capacity * 1.5 + 16));
          }
        };
        Deque.prototype._resizeTo = function Deque$_resizeTo(capacity) {
          var oldCapacity = this._capacity;
          this._capacity = capacity;
          var front = this._front;
          var length = this._length;
          if (front + length > oldCapacity) {
            var moveItemsCount = front + length & oldCapacity - 1;
            arrayMove(this, 0, this, oldCapacity, moveItemsCount);
          }
        };
        var isArray = Array.isArray;
        function arrayMove(src, srcIndex, dst, dstIndex, len) {
          for (var j = 0; j < len; ++j) {
            dst[j + dstIndex] = src[j + srcIndex];
            src[j + srcIndex] = void 0;
          }
        }
        function pow2AtLeast(n) {
          n = n >>> 0;
          n = n - 1;
          n = n | n >> 1;
          n = n | n >> 2;
          n = n | n >> 4;
          n = n | n >> 8;
          n = n | n >> 16;
          return n + 1;
        }
        function getCapacity(capacity) {
          if (typeof capacity !== "number") {
            if (isArray(capacity)) {
              capacity = capacity.length;
            } else {
              return 16;
            }
          }
          return pow2AtLeast(
            Math.min(
              Math.max(16, capacity),
              1073741824
            )
          );
        }
        module2.exports = Deque;
      }
    });
    var require_async_sema = __commonJS({
      "../../node_modules/.pnpm/async-sema@2.1.4/node_modules/async-sema/index.js"(exports2, module2) {
        var EventEmitter = require("events");
        var util = require("util");
        var Deque = require_deque();
        var ReleaseEmitter = class extends EventEmitter {
        };
        function isFn(x) {
          return typeof x === "function";
        }
        function defaultInit() {
          return "1";
        }
        var Sema5 = class {
          constructor(nr, { initFn = defaultInit, pauseFn, resumeFn, capacity = 10 } = {}) {
            if (isFn(pauseFn) ^ isFn(resumeFn)) {
              throw new Error("pauseFn and resumeFn must be both set for pausing");
            }
            this.nrTokens = nr;
            this.free = new Deque(nr);
            this.waiting = new Deque(capacity);
            this.releaseEmitter = new ReleaseEmitter();
            this.noTokens = initFn === defaultInit;
            this.pauseFn = pauseFn;
            this.resumeFn = resumeFn;
            this.releaseEmitter.on("release", (token) => {
              const p = this.waiting.shift();
              if (p) {
                p.resolve(token);
              } else {
                if (this.resumeFn && this.paused) {
                  this.paused = false;
                  this.resumeFn();
                }
                this.free.push(token);
              }
            });
            for (let i = 0; i < nr; i++) {
              this.free.push(initFn());
            }
          }
          async acquire() {
            let token = this.free.pop();
            if (token) {
              return token;
            }
            return new Promise((resolve, reject) => {
              if (this.pauseFn && !this.paused) {
                this.paused = true;
                this.pauseFn();
              }
              this.waiting.push({ resolve, reject });
            });
          }
          async v() {
            return this.acquire();
          }
          release(token) {
            this.releaseEmitter.emit("release", this.noTokens ? "1" : token);
          }
          p(token) {
            return this.release(token);
          }
          drain() {
            const a = new Array(this.nrTokens);
            for (let i = 0; i < this.nrTokens; i++) {
              a[i] = this.acquire();
            }
            return Promise.all(a);
          }
          nrWaiting() {
            return this.waiting.length;
          }
        };
        Sema5.prototype.v = util.deprecate(Sema5.prototype.v, "`v()` is deperecated; use `acquire()` instead");
        Sema5.prototype.p = util.deprecate(Sema5.prototype.p, "`p()` is deprecated; use `release()` instead");
        module2.exports = Sema5;
      }
    });
    var require_lib2 = __commonJS({
      "../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js"(exports2, module2) {
        "use strict";
        var conversions = {};
        module2.exports = conversions;
        function sign(x) {
          return x < 0 ? -1 : 1;
        }
        function evenRound(x) {
          if (x % 1 === 0.5 && (x & 1) === 0) {
            return Math.floor(x);
          } else {
            return Math.round(x);
          }
        }
        function createNumberConversion(bitLength, typeOpts) {
          if (!typeOpts.unsigned) {
            --bitLength;
          }
          const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
          const upperBound = Math.pow(2, bitLength) - 1;
          const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
          const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
          return function(V, opts) {
            if (!opts)
              opts = {};
            let x = +V;
            if (opts.enforceRange) {
              if (!Number.isFinite(x)) {
                throw new TypeError("Argument is not a finite number");
              }
              x = sign(x) * Math.floor(Math.abs(x));
              if (x < lowerBound || x > upperBound) {
                throw new TypeError("Argument is not in byte range");
              }
              return x;
            }
            if (!isNaN(x) && opts.clamp) {
              x = evenRound(x);
              if (x < lowerBound)
                x = lowerBound;
              if (x > upperBound)
                x = upperBound;
              return x;
            }
            if (!Number.isFinite(x) || x === 0) {
              return 0;
            }
            x = sign(x) * Math.floor(Math.abs(x));
            x = x % moduloVal;
            if (!typeOpts.unsigned && x >= moduloBound) {
              return x - moduloVal;
            } else if (typeOpts.unsigned) {
              if (x < 0) {
                x += moduloVal;
              } else if (x === -0) {
                return 0;
              }
            }
            return x;
          };
        }
        conversions["void"] = function() {
          return void 0;
        };
        conversions["boolean"] = function(val) {
          return !!val;
        };
        conversions["byte"] = createNumberConversion(8, { unsigned: false });
        conversions["octet"] = createNumberConversion(8, { unsigned: true });
        conversions["short"] = createNumberConversion(16, { unsigned: false });
        conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
        conversions["long"] = createNumberConversion(32, { unsigned: false });
        conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
        conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
        conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
        conversions["double"] = function(V) {
          const x = +V;
          if (!Number.isFinite(x)) {
            throw new TypeError("Argument is not a finite floating-point value");
          }
          return x;
        };
        conversions["unrestricted double"] = function(V) {
          const x = +V;
          if (isNaN(x)) {
            throw new TypeError("Argument is NaN");
          }
          return x;
        };
        conversions["float"] = conversions["double"];
        conversions["unrestricted float"] = conversions["unrestricted double"];
        conversions["DOMString"] = function(V, opts) {
          if (!opts)
            opts = {};
          if (opts.treatNullAsEmptyString && V === null) {
            return "";
          }
          return String(V);
        };
        conversions["ByteString"] = function(V, opts) {
          const x = String(V);
          let c = void 0;
          for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
            if (c > 255) {
              throw new TypeError("Argument is not a valid bytestring");
            }
          }
          return x;
        };
        conversions["USVString"] = function(V) {
          const S = String(V);
          const n = S.length;
          const U = [];
          for (let i = 0; i < n; ++i) {
            const c = S.charCodeAt(i);
            if (c < 55296 || c > 57343) {
              U.push(String.fromCodePoint(c));
            } else if (56320 <= c && c <= 57343) {
              U.push(String.fromCodePoint(65533));
            } else {
              if (i === n - 1) {
                U.push(String.fromCodePoint(65533));
              } else {
                const d = S.charCodeAt(i + 1);
                if (56320 <= d && d <= 57343) {
                  const a = c & 1023;
                  const b = d & 1023;
                  U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                  ++i;
                } else {
                  U.push(String.fromCodePoint(65533));
                }
              }
            }
          }
          return U.join("");
        };
        conversions["Date"] = function(V, opts) {
          if (!(V instanceof Date)) {
            throw new TypeError("Argument is not a Date object");
          }
          if (isNaN(V)) {
            return void 0;
          }
          return V;
        };
        conversions["RegExp"] = function(V, opts) {
          if (!(V instanceof RegExp)) {
            V = new RegExp(V);
          }
          return V;
        };
      }
    });
    var require_utils3 = __commonJS({
      "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js"(exports2, module2) {
        "use strict";
        module2.exports.mixin = function mixin(target, source) {
          const keys = Object.getOwnPropertyNames(source);
          for (let i = 0; i < keys.length; ++i) {
            Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
          }
        };
        module2.exports.wrapperSymbol = Symbol("wrapper");
        module2.exports.implSymbol = Symbol("impl");
        module2.exports.wrapperForImpl = function(impl) {
          return impl[module2.exports.wrapperSymbol];
        };
        module2.exports.implForWrapper = function(wrapper) {
          return wrapper[module2.exports.implSymbol];
        };
      }
    });
    var require_mappingTable = __commonJS({
      "../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json"(exports2, module2) {
        module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
      }
    });
    var require_tr46 = __commonJS({
      "../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js"(exports2, module2) {
        "use strict";
        var punycode = require("punycode");
        var mappingTable = require_mappingTable();
        var PROCESSING_OPTIONS = {
          TRANSITIONAL: 0,
          NONTRANSITIONAL: 1
        };
        function normalize(str) {
          return str.split("\0").map(function(s) {
            return s.normalize("NFC");
          }).join("\0");
        }
        function findStatus(val) {
          var start = 0;
          var end = mappingTable.length - 1;
          while (start <= end) {
            var mid = Math.floor((start + end) / 2);
            var target = mappingTable[mid];
            if (target[0][0] <= val && target[0][1] >= val) {
              return target;
            } else if (target[0][0] > val) {
              end = mid - 1;
            } else {
              start = mid + 1;
            }
          }
          return null;
        }
        var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        function countSymbols(string) {
          return string.replace(regexAstralSymbols, "_").length;
        }
        function mapChars(domain_name, useSTD3, processing_option) {
          var hasError = false;
          var processed = "";
          var len = countSymbols(domain_name);
          for (var i = 0; i < len; ++i) {
            var codePoint = domain_name.codePointAt(i);
            var status = findStatus(codePoint);
            switch (status[1]) {
              case "disallowed":
                hasError = true;
                processed += String.fromCodePoint(codePoint);
                break;
              case "ignored":
                break;
              case "mapped":
                processed += String.fromCodePoint.apply(String, status[2]);
                break;
              case "deviation":
                if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                  processed += String.fromCodePoint.apply(String, status[2]);
                } else {
                  processed += String.fromCodePoint(codePoint);
                }
                break;
              case "valid":
                processed += String.fromCodePoint(codePoint);
                break;
              case "disallowed_STD3_mapped":
                if (useSTD3) {
                  hasError = true;
                  processed += String.fromCodePoint(codePoint);
                } else {
                  processed += String.fromCodePoint.apply(String, status[2]);
                }
                break;
              case "disallowed_STD3_valid":
                if (useSTD3) {
                  hasError = true;
                }
                processed += String.fromCodePoint(codePoint);
                break;
            }
          }
          return {
            string: processed,
            error: hasError
          };
        }
        var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
        function validateLabel(label, processing_option) {
          if (label.substr(0, 4) === "xn--") {
            label = punycode.toUnicode(label);
            processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
          }
          var error = false;
          if (normalize(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
            error = true;
          }
          var len = countSymbols(label);
          for (var i = 0; i < len; ++i) {
            var status = findStatus(label.codePointAt(i));
            if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
              error = true;
              break;
            }
          }
          return {
            label,
            error
          };
        }
        function processing(domain_name, useSTD3, processing_option) {
          var result = mapChars(domain_name, useSTD3, processing_option);
          result.string = normalize(result.string);
          var labels = result.string.split(".");
          for (var i = 0; i < labels.length; ++i) {
            try {
              var validation = validateLabel(labels[i]);
              labels[i] = validation.label;
              result.error = result.error || validation.error;
            } catch (e) {
              result.error = true;
            }
          }
          return {
            string: labels.join("."),
            error: result.error
          };
        }
        module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
          var result = processing(domain_name, useSTD3, processing_option);
          var labels = result.string.split(".");
          labels = labels.map(function(l) {
            try {
              return punycode.toASCII(l);
            } catch (e) {
              result.error = true;
              return l;
            }
          });
          if (verifyDnsLength) {
            var total = labels.slice(0, labels.length - 1).join(".").length;
            if (total.length > 253 || total.length === 0) {
              result.error = true;
            }
            for (var i = 0; i < labels.length; ++i) {
              if (labels.length > 63 || labels.length === 0) {
                result.error = true;
                break;
              }
            }
          }
          if (result.error)
            return null;
          return labels.join(".");
        };
        module2.exports.toUnicode = function(domain_name, useSTD3) {
          var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
          return {
            domain: result.string,
            error: result.error
          };
        };
        module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
      }
    });
    var require_url_state_machine = __commonJS({
      "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports2, module2) {
        "use strict";
        var punycode = require("punycode");
        var tr46 = require_tr46();
        var specialSchemes = {
          ftp: 21,
          file: null,
          gopher: 70,
          http: 80,
          https: 443,
          ws: 80,
          wss: 443
        };
        var failure = Symbol("failure");
        function countSymbols(str) {
          return punycode.ucs2.decode(str).length;
        }
        function at(input, idx) {
          const c = input[idx];
          return isNaN(c) ? void 0 : String.fromCodePoint(c);
        }
        function isASCIIDigit(c) {
          return c >= 48 && c <= 57;
        }
        function isASCIIAlpha(c) {
          return c >= 65 && c <= 90 || c >= 97 && c <= 122;
        }
        function isASCIIAlphanumeric(c) {
          return isASCIIAlpha(c) || isASCIIDigit(c);
        }
        function isASCIIHex(c) {
          return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
        }
        function isSingleDot(buffer) {
          return buffer === "." || buffer.toLowerCase() === "%2e";
        }
        function isDoubleDot(buffer) {
          buffer = buffer.toLowerCase();
          return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
        }
        function isWindowsDriveLetterCodePoints(cp1, cp2) {
          return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
        }
        function isWindowsDriveLetterString(string) {
          return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
        }
        function isNormalizedWindowsDriveLetterString(string) {
          return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
        }
        function containsForbiddenHostCodePoint(string) {
          return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
        }
        function containsForbiddenHostCodePointExcludingPercent(string) {
          return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
        }
        function isSpecialScheme(scheme) {
          return specialSchemes[scheme] !== void 0;
        }
        function isSpecial(url) {
          return isSpecialScheme(url.scheme);
        }
        function defaultPort(scheme) {
          return specialSchemes[scheme];
        }
        function percentEncode(c) {
          let hex = c.toString(16).toUpperCase();
          if (hex.length === 1) {
            hex = "0" + hex;
          }
          return "%" + hex;
        }
        function utf8PercentEncode(c) {
          const buf = new Buffer(c);
          let str = "";
          for (let i = 0; i < buf.length; ++i) {
            str += percentEncode(buf[i]);
          }
          return str;
        }
        function utf8PercentDecode(str) {
          const input = new Buffer(str);
          const output = [];
          for (let i = 0; i < input.length; ++i) {
            if (input[i] !== 37) {
              output.push(input[i]);
            } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
              output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
              i += 2;
            } else {
              output.push(input[i]);
            }
          }
          return new Buffer(output).toString();
        }
        function isC0ControlPercentEncode(c) {
          return c <= 31 || c > 126;
        }
        var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
        function isPathPercentEncode(c) {
          return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
        }
        var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
        function isUserinfoPercentEncode(c) {
          return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
        }
        function percentEncodeChar(c, encodeSetPredicate) {
          const cStr = String.fromCodePoint(c);
          if (encodeSetPredicate(c)) {
            return utf8PercentEncode(cStr);
          }
          return cStr;
        }
        function parseIPv4Number(input) {
          let R = 10;
          if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
            input = input.substring(2);
            R = 16;
          } else if (input.length >= 2 && input.charAt(0) === "0") {
            input = input.substring(1);
            R = 8;
          }
          if (input === "") {
            return 0;
          }
          const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
          if (regex.test(input)) {
            return failure;
          }
          return parseInt(input, R);
        }
        function parseIPv4(input) {
          const parts = input.split(".");
          if (parts[parts.length - 1] === "") {
            if (parts.length > 1) {
              parts.pop();
            }
          }
          if (parts.length > 4) {
            return input;
          }
          const numbers = [];
          for (const part of parts) {
            if (part === "") {
              return input;
            }
            const n = parseIPv4Number(part);
            if (n === failure) {
              return input;
            }
            numbers.push(n);
          }
          for (let i = 0; i < numbers.length - 1; ++i) {
            if (numbers[i] > 255) {
              return failure;
            }
          }
          if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
            return failure;
          }
          let ipv4 = numbers.pop();
          let counter = 0;
          for (const n of numbers) {
            ipv4 += n * Math.pow(256, 3 - counter);
            ++counter;
          }
          return ipv4;
        }
        function serializeIPv4(address) {
          let output = "";
          let n = address;
          for (let i = 1; i <= 4; ++i) {
            output = String(n % 256) + output;
            if (i !== 4) {
              output = "." + output;
            }
            n = Math.floor(n / 256);
          }
          return output;
        }
        function parseIPv6(input) {
          const address = [0, 0, 0, 0, 0, 0, 0, 0];
          let pieceIndex = 0;
          let compress = null;
          let pointer = 0;
          input = punycode.ucs2.decode(input);
          if (input[pointer] === 58) {
            if (input[pointer + 1] !== 58) {
              return failure;
            }
            pointer += 2;
            ++pieceIndex;
            compress = pieceIndex;
          }
          while (pointer < input.length) {
            if (pieceIndex === 8) {
              return failure;
            }
            if (input[pointer] === 58) {
              if (compress !== null) {
                return failure;
              }
              ++pointer;
              ++pieceIndex;
              compress = pieceIndex;
              continue;
            }
            let value = 0;
            let length = 0;
            while (length < 4 && isASCIIHex(input[pointer])) {
              value = value * 16 + parseInt(at(input, pointer), 16);
              ++pointer;
              ++length;
            }
            if (input[pointer] === 46) {
              if (length === 0) {
                return failure;
              }
              pointer -= length;
              if (pieceIndex > 6) {
                return failure;
              }
              let numbersSeen = 0;
              while (input[pointer] !== void 0) {
                let ipv4Piece = null;
                if (numbersSeen > 0) {
                  if (input[pointer] === 46 && numbersSeen < 4) {
                    ++pointer;
                  } else {
                    return failure;
                  }
                }
                if (!isASCIIDigit(input[pointer])) {
                  return failure;
                }
                while (isASCIIDigit(input[pointer])) {
                  const number = parseInt(at(input, pointer));
                  if (ipv4Piece === null) {
                    ipv4Piece = number;
                  } else if (ipv4Piece === 0) {
                    return failure;
                  } else {
                    ipv4Piece = ipv4Piece * 10 + number;
                  }
                  if (ipv4Piece > 255) {
                    return failure;
                  }
                  ++pointer;
                }
                address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                ++numbersSeen;
                if (numbersSeen === 2 || numbersSeen === 4) {
                  ++pieceIndex;
                }
              }
              if (numbersSeen !== 4) {
                return failure;
              }
              break;
            } else if (input[pointer] === 58) {
              ++pointer;
              if (input[pointer] === void 0) {
                return failure;
              }
            } else if (input[pointer] !== void 0) {
              return failure;
            }
            address[pieceIndex] = value;
            ++pieceIndex;
          }
          if (compress !== null) {
            let swaps = pieceIndex - compress;
            pieceIndex = 7;
            while (pieceIndex !== 0 && swaps > 0) {
              const temp = address[compress + swaps - 1];
              address[compress + swaps - 1] = address[pieceIndex];
              address[pieceIndex] = temp;
              --pieceIndex;
              --swaps;
            }
          } else if (compress === null && pieceIndex !== 8) {
            return failure;
          }
          return address;
        }
        function serializeIPv6(address) {
          let output = "";
          const seqResult = findLongestZeroSequence(address);
          const compress = seqResult.idx;
          let ignore0 = false;
          for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
            if (ignore0 && address[pieceIndex] === 0) {
              continue;
            } else if (ignore0) {
              ignore0 = false;
            }
            if (compress === pieceIndex) {
              const separator = pieceIndex === 0 ? "::" : ":";
              output += separator;
              ignore0 = true;
              continue;
            }
            output += address[pieceIndex].toString(16);
            if (pieceIndex !== 7) {
              output += ":";
            }
          }
          return output;
        }
        function parseHost(input, isSpecialArg) {
          if (input[0] === "[") {
            if (input[input.length - 1] !== "]") {
              return failure;
            }
            return parseIPv6(input.substring(1, input.length - 1));
          }
          if (!isSpecialArg) {
            return parseOpaqueHost(input);
          }
          const domain = utf8PercentDecode(input);
          const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
          if (asciiDomain === null) {
            return failure;
          }
          if (containsForbiddenHostCodePoint(asciiDomain)) {
            return failure;
          }
          const ipv4Host = parseIPv4(asciiDomain);
          if (typeof ipv4Host === "number" || ipv4Host === failure) {
            return ipv4Host;
          }
          return asciiDomain;
        }
        function parseOpaqueHost(input) {
          if (containsForbiddenHostCodePointExcludingPercent(input)) {
            return failure;
          }
          let output = "";
          const decoded = punycode.ucs2.decode(input);
          for (let i = 0; i < decoded.length; ++i) {
            output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
          }
          return output;
        }
        function findLongestZeroSequence(arr) {
          let maxIdx = null;
          let maxLen = 1;
          let currStart = null;
          let currLen = 0;
          for (let i = 0; i < arr.length; ++i) {
            if (arr[i] !== 0) {
              if (currLen > maxLen) {
                maxIdx = currStart;
                maxLen = currLen;
              }
              currStart = null;
              currLen = 0;
            } else {
              if (currStart === null) {
                currStart = i;
              }
              ++currLen;
            }
          }
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          return {
            idx: maxIdx,
            len: maxLen
          };
        }
        function serializeHost(host) {
          if (typeof host === "number") {
            return serializeIPv4(host);
          }
          if (host instanceof Array) {
            return "[" + serializeIPv6(host) + "]";
          }
          return host;
        }
        function trimControlChars(url) {
          return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
        }
        function trimTabAndNewline(url) {
          return url.replace(/\u0009|\u000A|\u000D/g, "");
        }
        function shortenPath(url) {
          const path7 = url.path;
          if (path7.length === 0) {
            return;
          }
          if (url.scheme === "file" && path7.length === 1 && isNormalizedWindowsDriveLetter(path7[0])) {
            return;
          }
          path7.pop();
        }
        function includesCredentials(url) {
          return url.username !== "" || url.password !== "";
        }
        function cannotHaveAUsernamePasswordPort(url) {
          return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
        }
        function isNormalizedWindowsDriveLetter(string) {
          return /^[A-Za-z]:$/.test(string);
        }
        function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
          this.pointer = 0;
          this.input = input;
          this.base = base || null;
          this.encodingOverride = encodingOverride || "utf-8";
          this.stateOverride = stateOverride;
          this.url = url;
          this.failure = false;
          this.parseError = false;
          if (!this.url) {
            this.url = {
              scheme: "",
              username: "",
              password: "",
              host: null,
              port: null,
              path: [],
              query: null,
              fragment: null,
              cannotBeABaseURL: false
            };
            const res2 = trimControlChars(this.input);
            if (res2 !== this.input) {
              this.parseError = true;
            }
            this.input = res2;
          }
          const res = trimTabAndNewline(this.input);
          if (res !== this.input) {
            this.parseError = true;
          }
          this.input = res;
          this.state = stateOverride || "scheme start";
          this.buffer = "";
          this.atFlag = false;
          this.arrFlag = false;
          this.passwordTokenSeenFlag = false;
          this.input = punycode.ucs2.decode(this.input);
          for (; this.pointer <= this.input.length; ++this.pointer) {
            const c = this.input[this.pointer];
            const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
            const ret = this["parse " + this.state](c, cStr);
            if (!ret) {
              break;
            } else if (ret === failure) {
              this.failure = true;
              break;
            }
          }
        }
        URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
          if (isASCIIAlpha(c)) {
            this.buffer += cStr.toLowerCase();
            this.state = "scheme";
          } else if (!this.stateOverride) {
            this.state = "no scheme";
            --this.pointer;
          } else {
            this.parseError = true;
            return failure;
          }
          return true;
        };
        URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
          if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
            this.buffer += cStr.toLowerCase();
          } else if (c === 58) {
            if (this.stateOverride) {
              if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
                return false;
              }
              if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
                return false;
              }
              if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
                return false;
              }
              if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
                return false;
              }
            }
            this.url.scheme = this.buffer;
            this.buffer = "";
            if (this.stateOverride) {
              return false;
            }
            if (this.url.scheme === "file") {
              if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
                this.parseError = true;
              }
              this.state = "file";
            } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
              this.state = "special relative or authority";
            } else if (isSpecial(this.url)) {
              this.state = "special authority slashes";
            } else if (this.input[this.pointer + 1] === 47) {
              this.state = "path or authority";
              ++this.pointer;
            } else {
              this.url.cannotBeABaseURL = true;
              this.url.path.push("");
              this.state = "cannot-be-a-base-URL path";
            }
          } else if (!this.stateOverride) {
            this.buffer = "";
            this.state = "no scheme";
            this.pointer = -1;
          } else {
            this.parseError = true;
            return failure;
          }
          return true;
        };
        URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
          if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
            return failure;
          } else if (this.base.cannotBeABaseURL && c === 35) {
            this.url.scheme = this.base.scheme;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.url.cannotBeABaseURL = true;
            this.state = "fragment";
          } else if (this.base.scheme === "file") {
            this.state = "file";
            --this.pointer;
          } else {
            this.state = "relative";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
          if (c === 47 && this.input[this.pointer + 1] === 47) {
            this.state = "special authority ignore slashes";
            ++this.pointer;
          } else {
            this.parseError = true;
            this.state = "relative";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
          if (c === 47) {
            this.state = "authority";
          } else {
            this.state = "path";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
          this.url.scheme = this.base.scheme;
          if (isNaN(c)) {
            this.url.username = this.base.username;
            this.url.password = this.base.password;
            this.url.host = this.base.host;
            this.url.port = this.base.port;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
          } else if (c === 47) {
            this.state = "relative slash";
          } else if (c === 63) {
            this.url.username = this.base.username;
            this.url.password = this.base.password;
            this.url.host = this.base.host;
            this.url.port = this.base.port;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
          } else if (c === 35) {
            this.url.username = this.base.username;
            this.url.password = this.base.password;
            this.url.host = this.base.host;
            this.url.port = this.base.port;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
          } else if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
            this.state = "relative slash";
          } else {
            this.url.username = this.base.username;
            this.url.password = this.base.password;
            this.url.host = this.base.host;
            this.url.port = this.base.port;
            this.url.path = this.base.path.slice(0, this.base.path.length - 1);
            this.state = "path";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
          if (isSpecial(this.url) && (c === 47 || c === 92)) {
            if (c === 92) {
              this.parseError = true;
            }
            this.state = "special authority ignore slashes";
          } else if (c === 47) {
            this.state = "authority";
          } else {
            this.url.username = this.base.username;
            this.url.password = this.base.password;
            this.url.host = this.base.host;
            this.url.port = this.base.port;
            this.state = "path";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
          if (c === 47 && this.input[this.pointer + 1] === 47) {
            this.state = "special authority ignore slashes";
            ++this.pointer;
          } else {
            this.parseError = true;
            this.state = "special authority ignore slashes";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
          if (c !== 47 && c !== 92) {
            this.state = "authority";
            --this.pointer;
          } else {
            this.parseError = true;
          }
          return true;
        };
        URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
          if (c === 64) {
            this.parseError = true;
            if (this.atFlag) {
              this.buffer = "%40" + this.buffer;
            }
            this.atFlag = true;
            const len = countSymbols(this.buffer);
            for (let pointer = 0; pointer < len; ++pointer) {
              const codePoint = this.buffer.codePointAt(pointer);
              if (codePoint === 58 && !this.passwordTokenSeenFlag) {
                this.passwordTokenSeenFlag = true;
                continue;
              }
              const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
              if (this.passwordTokenSeenFlag) {
                this.url.password += encodedCodePoints;
              } else {
                this.url.username += encodedCodePoints;
              }
            }
            this.buffer = "";
          } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
            if (this.atFlag && this.buffer === "") {
              this.parseError = true;
              return failure;
            }
            this.pointer -= countSymbols(this.buffer) + 1;
            this.buffer = "";
            this.state = "host";
          } else {
            this.buffer += cStr;
          }
          return true;
        };
        URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
          if (this.stateOverride && this.url.scheme === "file") {
            --this.pointer;
            this.state = "file host";
          } else if (c === 58 && !this.arrFlag) {
            if (this.buffer === "") {
              this.parseError = true;
              return failure;
            }
            const host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
              return failure;
            }
            this.url.host = host;
            this.buffer = "";
            this.state = "port";
            if (this.stateOverride === "hostname") {
              return false;
            }
          } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
            --this.pointer;
            if (isSpecial(this.url) && this.buffer === "") {
              this.parseError = true;
              return failure;
            } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
              this.parseError = true;
              return false;
            }
            const host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
              return failure;
            }
            this.url.host = host;
            this.buffer = "";
            this.state = "path start";
            if (this.stateOverride) {
              return false;
            }
          } else {
            if (c === 91) {
              this.arrFlag = true;
            } else if (c === 93) {
              this.arrFlag = false;
            }
            this.buffer += cStr;
          }
          return true;
        };
        URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
          if (isASCIIDigit(c)) {
            this.buffer += cStr;
          } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
            if (this.buffer !== "") {
              const port = parseInt(this.buffer);
              if (port > Math.pow(2, 16) - 1) {
                this.parseError = true;
                return failure;
              }
              this.url.port = port === defaultPort(this.url.scheme) ? null : port;
              this.buffer = "";
            }
            if (this.stateOverride) {
              return false;
            }
            this.state = "path start";
            --this.pointer;
          } else {
            this.parseError = true;
            return failure;
          }
          return true;
        };
        var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
        URLStateMachine.prototype["parse file"] = function parseFile(c) {
          this.url.scheme = "file";
          if (c === 47 || c === 92) {
            if (c === 92) {
              this.parseError = true;
            }
            this.state = "file slash";
          } else if (this.base !== null && this.base.scheme === "file") {
            if (isNaN(c)) {
              this.url.host = this.base.host;
              this.url.path = this.base.path.slice();
              this.url.query = this.base.query;
            } else if (c === 63) {
              this.url.host = this.base.host;
              this.url.path = this.base.path.slice();
              this.url.query = "";
              this.state = "query";
            } else if (c === 35) {
              this.url.host = this.base.host;
              this.url.path = this.base.path.slice();
              this.url.query = this.base.query;
              this.url.fragment = "";
              this.state = "fragment";
            } else {
              if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
              !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
              !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
                this.url.host = this.base.host;
                this.url.path = this.base.path.slice();
                shortenPath(this.url);
              } else {
                this.parseError = true;
              }
              this.state = "path";
              --this.pointer;
            }
          } else {
            this.state = "path";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
          if (c === 47 || c === 92) {
            if (c === 92) {
              this.parseError = true;
            }
            this.state = "file host";
          } else {
            if (this.base !== null && this.base.scheme === "file") {
              if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
                this.url.path.push(this.base.path[0]);
              } else {
                this.url.host = this.base.host;
              }
            }
            this.state = "path";
            --this.pointer;
          }
          return true;
        };
        URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
          if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
            --this.pointer;
            if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
              this.parseError = true;
              this.state = "path";
            } else if (this.buffer === "") {
              this.url.host = "";
              if (this.stateOverride) {
                return false;
              }
              this.state = "path start";
            } else {
              let host = parseHost(this.buffer, isSpecial(this.url));
              if (host === failure) {
                return failure;
              }
              if (host === "localhost") {
                host = "";
              }
              this.url.host = host;
              if (this.stateOverride) {
                return false;
              }
              this.buffer = "";
              this.state = "path start";
            }
          } else {
            this.buffer += cStr;
          }
          return true;
        };
        URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
          if (isSpecial(this.url)) {
            if (c === 92) {
              this.parseError = true;
            }
            this.state = "path";
            if (c !== 47 && c !== 92) {
              --this.pointer;
            }
          } else if (!this.stateOverride && c === 63) {
            this.url.query = "";
            this.state = "query";
          } else if (!this.stateOverride && c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          } else if (c !== void 0) {
            this.state = "path";
            if (c !== 47) {
              --this.pointer;
            }
          }
          return true;
        };
        URLStateMachine.prototype["parse path"] = function parsePath(c) {
          if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
            if (isSpecial(this.url) && c === 92) {
              this.parseError = true;
            }
            if (isDoubleDot(this.buffer)) {
              shortenPath(this.url);
              if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
                this.url.path.push("");
              }
            } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
              this.url.path.push("");
            } else if (!isSingleDot(this.buffer)) {
              if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
                if (this.url.host !== "" && this.url.host !== null) {
                  this.parseError = true;
                  this.url.host = "";
                }
                this.buffer = this.buffer[0] + ":";
              }
              this.url.path.push(this.buffer);
            }
            this.buffer = "";
            if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
              while (this.url.path.length > 1 && this.url.path[0] === "") {
                this.parseError = true;
                this.url.path.shift();
              }
            }
            if (c === 63) {
              this.url.query = "";
              this.state = "query";
            }
            if (c === 35) {
              this.url.fragment = "";
              this.state = "fragment";
            }
          } else {
            if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
              this.parseError = true;
            }
            this.buffer += percentEncodeChar(c, isPathPercentEncode);
          }
          return true;
        };
        URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
          if (c === 63) {
            this.url.query = "";
            this.state = "query";
          } else if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          } else {
            if (!isNaN(c) && c !== 37) {
              this.parseError = true;
            }
            if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
              this.parseError = true;
            }
            if (!isNaN(c)) {
              this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
            }
          }
          return true;
        };
        URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
          if (isNaN(c) || !this.stateOverride && c === 35) {
            if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
              this.encodingOverride = "utf-8";
            }
            const buffer = new Buffer(this.buffer);
            for (let i = 0; i < buffer.length; ++i) {
              if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
                this.url.query += percentEncode(buffer[i]);
              } else {
                this.url.query += String.fromCodePoint(buffer[i]);
              }
            }
            this.buffer = "";
            if (c === 35) {
              this.url.fragment = "";
              this.state = "fragment";
            }
          } else {
            if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
              this.parseError = true;
            }
            this.buffer += cStr;
          }
          return true;
        };
        URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
          if (isNaN(c)) {
          } else if (c === 0) {
            this.parseError = true;
          } else {
            if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
              this.parseError = true;
            }
            this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
          }
          return true;
        };
        function serializeURL(url, excludeFragment) {
          let output = url.scheme + ":";
          if (url.host !== null) {
            output += "//";
            if (url.username !== "" || url.password !== "") {
              output += url.username;
              if (url.password !== "") {
                output += ":" + url.password;
              }
              output += "@";
            }
            output += serializeHost(url.host);
            if (url.port !== null) {
              output += ":" + url.port;
            }
          } else if (url.host === null && url.scheme === "file") {
            output += "//";
          }
          if (url.cannotBeABaseURL) {
            output += url.path[0];
          } else {
            for (const string of url.path) {
              output += "/" + string;
            }
          }
          if (url.query !== null) {
            output += "?" + url.query;
          }
          if (!excludeFragment && url.fragment !== null) {
            output += "#" + url.fragment;
          }
          return output;
        }
        function serializeOrigin(tuple) {
          let result = tuple.scheme + "://";
          result += serializeHost(tuple.host);
          if (tuple.port !== null) {
            result += ":" + tuple.port;
          }
          return result;
        }
        module2.exports.serializeURL = serializeURL;
        module2.exports.serializeURLOrigin = function(url) {
          switch (url.scheme) {
            case "blob":
              try {
                return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
              } catch (e) {
                return "null";
              }
            case "ftp":
            case "gopher":
            case "http":
            case "https":
            case "ws":
            case "wss":
              return serializeOrigin({
                scheme: url.scheme,
                host: url.host,
                port: url.port
              });
            case "file":
              return "file://";
            default:
              return "null";
          }
        };
        module2.exports.basicURLParse = function(input, options) {
          if (options === void 0) {
            options = {};
          }
          const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
          if (usm.failure) {
            return "failure";
          }
          return usm.url;
        };
        module2.exports.setTheUsername = function(url, username) {
          url.username = "";
          const decoded = punycode.ucs2.decode(username);
          for (let i = 0; i < decoded.length; ++i) {
            url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
          }
        };
        module2.exports.setThePassword = function(url, password) {
          url.password = "";
          const decoded = punycode.ucs2.decode(password);
          for (let i = 0; i < decoded.length; ++i) {
            url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
          }
        };
        module2.exports.serializeHost = serializeHost;
        module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
        module2.exports.serializeInteger = function(integer) {
          return String(integer);
        };
        module2.exports.parseURL = function(input, options) {
          if (options === void 0) {
            options = {};
          }
          return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
        };
      }
    });
    var require_URL_impl = __commonJS({
      "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js"(exports2) {
        "use strict";
        var usm = require_url_state_machine();
        exports2.implementation = class URLImpl {
          constructor(constructorArgs) {
            const url = constructorArgs[0];
            const base = constructorArgs[1];
            let parsedBase = null;
            if (base !== void 0) {
              parsedBase = usm.basicURLParse(base);
              if (parsedBase === "failure") {
                throw new TypeError("Invalid base URL");
              }
            }
            const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
            if (parsedURL === "failure") {
              throw new TypeError("Invalid URL");
            }
            this._url = parsedURL;
          }
          get href() {
            return usm.serializeURL(this._url);
          }
          set href(v) {
            const parsedURL = usm.basicURLParse(v);
            if (parsedURL === "failure") {
              throw new TypeError("Invalid URL");
            }
            this._url = parsedURL;
          }
          get origin() {
            return usm.serializeURLOrigin(this._url);
          }
          get protocol() {
            return this._url.scheme + ":";
          }
          set protocol(v) {
            usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
          }
          get username() {
            return this._url.username;
          }
          set username(v) {
            if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
              return;
            }
            usm.setTheUsername(this._url, v);
          }
          get password() {
            return this._url.password;
          }
          set password(v) {
            if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
              return;
            }
            usm.setThePassword(this._url, v);
          }
          get host() {
            const url = this._url;
            if (url.host === null) {
              return "";
            }
            if (url.port === null) {
              return usm.serializeHost(url.host);
            }
            return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
          }
          set host(v) {
            if (this._url.cannotBeABaseURL) {
              return;
            }
            usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
          }
          get hostname() {
            if (this._url.host === null) {
              return "";
            }
            return usm.serializeHost(this._url.host);
          }
          set hostname(v) {
            if (this._url.cannotBeABaseURL) {
              return;
            }
            usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
          }
          get port() {
            if (this._url.port === null) {
              return "";
            }
            return usm.serializeInteger(this._url.port);
          }
          set port(v) {
            if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
              return;
            }
            if (v === "") {
              this._url.port = null;
            } else {
              usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
            }
          }
          get pathname() {
            if (this._url.cannotBeABaseURL) {
              return this._url.path[0];
            }
            if (this._url.path.length === 0) {
              return "";
            }
            return "/" + this._url.path.join("/");
          }
          set pathname(v) {
            if (this._url.cannotBeABaseURL) {
              return;
            }
            this._url.path = [];
            usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
          }
          get search() {
            if (this._url.query === null || this._url.query === "") {
              return "";
            }
            return "?" + this._url.query;
          }
          set search(v) {
            const url = this._url;
            if (v === "") {
              url.query = null;
              return;
            }
            const input = v[0] === "?" ? v.substring(1) : v;
            url.query = "";
            usm.basicURLParse(input, { url, stateOverride: "query" });
          }
          get hash() {
            if (this._url.fragment === null || this._url.fragment === "") {
              return "";
            }
            return "#" + this._url.fragment;
          }
          set hash(v) {
            if (v === "") {
              this._url.fragment = null;
              return;
            }
            const input = v[0] === "#" ? v.substring(1) : v;
            this._url.fragment = "";
            usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
          }
          toJSON() {
            return this.href;
          }
        };
      }
    });
    var require_URL = __commonJS({
      "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js"(exports2, module2) {
        "use strict";
        var conversions = require_lib2();
        var utils = require_utils3();
        var Impl = require_URL_impl();
        var impl = utils.implSymbol;
        function URL2(url) {
          if (!this || this[impl] || !(this instanceof URL2)) {
            throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
          }
          if (arguments.length < 1) {
            throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
          }
          const args = [];
          for (let i = 0; i < arguments.length && i < 2; ++i) {
            args[i] = arguments[i];
          }
          args[0] = conversions["USVString"](args[0]);
          if (args[1] !== void 0) {
            args[1] = conversions["USVString"](args[1]);
          }
          module2.exports.setup(this, args);
        }
        URL2.prototype.toJSON = function toJSON() {
          if (!this || !module2.exports.is(this)) {
            throw new TypeError("Illegal invocation");
          }
          const args = [];
          for (let i = 0; i < arguments.length && i < 0; ++i) {
            args[i] = arguments[i];
          }
          return this[impl].toJSON.apply(this[impl], args);
        };
        Object.defineProperty(URL2.prototype, "href", {
          get() {
            return this[impl].href;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].href = V;
          },
          enumerable: true,
          configurable: true
        });
        URL2.prototype.toString = function() {
          if (!this || !module2.exports.is(this)) {
            throw new TypeError("Illegal invocation");
          }
          return this.href;
        };
        Object.defineProperty(URL2.prototype, "origin", {
          get() {
            return this[impl].origin;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "protocol", {
          get() {
            return this[impl].protocol;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].protocol = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "username", {
          get() {
            return this[impl].username;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].username = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "password", {
          get() {
            return this[impl].password;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].password = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "host", {
          get() {
            return this[impl].host;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].host = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "hostname", {
          get() {
            return this[impl].hostname;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].hostname = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "port", {
          get() {
            return this[impl].port;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].port = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "pathname", {
          get() {
            return this[impl].pathname;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].pathname = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "search", {
          get() {
            return this[impl].search;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].search = V;
          },
          enumerable: true,
          configurable: true
        });
        Object.defineProperty(URL2.prototype, "hash", {
          get() {
            return this[impl].hash;
          },
          set(V) {
            V = conversions["USVString"](V);
            this[impl].hash = V;
          },
          enumerable: true,
          configurable: true
        });
        module2.exports = {
          is(obj) {
            return !!obj && obj[impl] instanceof Impl.implementation;
          },
          create(constructorArgs, privateData) {
            let obj = Object.create(URL2.prototype);
            this.setup(obj, constructorArgs, privateData);
            return obj;
          },
          setup(obj, constructorArgs, privateData) {
            if (!privateData)
              privateData = {};
            privateData.wrapper = obj;
            obj[impl] = new Impl.implementation(constructorArgs, privateData);
            obj[impl][utils.wrapperSymbol] = obj;
          },
          interface: URL2,
          expose: {
            Window: { URL: URL2 },
            Worker: { URL: URL2 }
          }
        };
      }
    });
    var require_public_api = __commonJS({
      "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js"(exports2) {
        "use strict";
        exports2.URL = require_URL().interface;
        exports2.serializeURL = require_url_state_machine().serializeURL;
        exports2.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
        exports2.basicURLParse = require_url_state_machine().basicURLParse;
        exports2.setTheUsername = require_url_state_machine().setTheUsername;
        exports2.setThePassword = require_url_state_machine().setThePassword;
        exports2.serializeHost = require_url_state_machine().serializeHost;
        exports2.serializeInteger = require_url_state_machine().serializeInteger;
        exports2.parseURL = require_url_state_machine().parseURL;
      }
    });
    var require_lib3 = __commonJS({
      "../../node_modules/.pnpm/node-fetch@2.6.7/node_modules/node-fetch/lib/index.js"(exports2, module2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", { value: true });
        function _interopDefault(ex) {
          return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
        }
        var Stream = _interopDefault(require("stream"));
        var http = _interopDefault(require("http"));
        var Url = _interopDefault(require("url"));
        var whatwgUrl = _interopDefault(require_public_api());
        var https = _interopDefault(require("https"));
        var zlib2 = _interopDefault(require("zlib"));
        var Readable = Stream.Readable;
        var BUFFER = Symbol("buffer");
        var TYPE = Symbol("type");
        var Blob = class _Blob {
          constructor() {
            this[TYPE] = "";
            const blobParts = arguments[0];
            const options = arguments[1];
            const buffers = [];
            let size = 0;
            if (blobParts) {
              const a = blobParts;
              const length = Number(a.length);
              for (let i = 0; i < length; i++) {
                const element = a[i];
                let buffer;
                if (element instanceof Buffer) {
                  buffer = element;
                } else if (ArrayBuffer.isView(element)) {
                  buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
                } else if (element instanceof ArrayBuffer) {
                  buffer = Buffer.from(element);
                } else if (element instanceof _Blob) {
                  buffer = element[BUFFER];
                } else {
                  buffer = Buffer.from(typeof element === "string" ? element : String(element));
                }
                size += buffer.length;
                buffers.push(buffer);
              }
            }
            this[BUFFER] = Buffer.concat(buffers);
            let type = options && options.type !== void 0 && String(options.type).toLowerCase();
            if (type && !/[^\u0020-\u007E]/.test(type)) {
              this[TYPE] = type;
            }
          }
          get size() {
            return this[BUFFER].length;
          }
          get type() {
            return this[TYPE];
          }
          text() {
            return Promise.resolve(this[BUFFER].toString());
          }
          arrayBuffer() {
            const buf = this[BUFFER];
            const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            return Promise.resolve(ab);
          }
          stream() {
            const readable = new Readable();
            readable._read = function() {
            };
            readable.push(this[BUFFER]);
            readable.push(null);
            return readable;
          }
          toString() {
            return "[object Blob]";
          }
          slice() {
            const size = this.size;
            const start = arguments[0];
            const end = arguments[1];
            let relativeStart, relativeEnd;
            if (start === void 0) {
              relativeStart = 0;
            } else if (start < 0) {
              relativeStart = Math.max(size + start, 0);
            } else {
              relativeStart = Math.min(start, size);
            }
            if (end === void 0) {
              relativeEnd = size;
            } else if (end < 0) {
              relativeEnd = Math.max(size + end, 0);
            } else {
              relativeEnd = Math.min(end, size);
            }
            const span = Math.max(relativeEnd - relativeStart, 0);
            const buffer = this[BUFFER];
            const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
            const blob = new _Blob([], { type: arguments[2] });
            blob[BUFFER] = slicedBuffer;
            return blob;
          }
        };
        Object.defineProperties(Blob.prototype, {
          size: { enumerable: true },
          type: { enumerable: true },
          slice: { enumerable: true }
        });
        Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
          value: "Blob",
          writable: false,
          enumerable: false,
          configurable: true
        });
        function FetchError(message, type, systemError) {
          Error.call(this, message);
          this.message = message;
          this.type = type;
          if (systemError) {
            this.code = this.errno = systemError.code;
          }
          Error.captureStackTrace(this, this.constructor);
        }
        FetchError.prototype = Object.create(Error.prototype);
        FetchError.prototype.constructor = FetchError;
        FetchError.prototype.name = "FetchError";
        var convert;
        try {
          convert = require("encoding").convert;
        } catch (e) {
        }
        var INTERNALS = Symbol("Body internals");
        var PassThrough = Stream.PassThrough;
        function Body(body) {
          var _this = this;
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
          let size = _ref$size === void 0 ? 0 : _ref$size;
          var _ref$timeout = _ref.timeout;
          let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
          if (body == null) {
            body = null;
          } else if (isURLSearchParams(body)) {
            body = Buffer.from(body.toString());
          } else if (isBlob(body))
            ;
          else if (Buffer.isBuffer(body))
            ;
          else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
            body = Buffer.from(body);
          } else if (ArrayBuffer.isView(body)) {
            body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
          } else if (body instanceof Stream)
            ;
          else {
            body = Buffer.from(String(body));
          }
          this[INTERNALS] = {
            body,
            disturbed: false,
            error: null
          };
          this.size = size;
          this.timeout = timeout;
          if (body instanceof Stream) {
            body.on("error", function(err) {
              const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
              _this[INTERNALS].error = error;
            });
          }
        }
        Body.prototype = {
          get body() {
            return this[INTERNALS].body;
          },
          get bodyUsed() {
            return this[INTERNALS].disturbed;
          },
          /**
           * Decode response as ArrayBuffer
           *
           * @return  Promise
           */
          arrayBuffer() {
            return consumeBody.call(this).then(function(buf) {
              return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            });
          },
          /**
           * Return raw response as Blob
           *
           * @return Promise
           */
          blob() {
            let ct = this.headers && this.headers.get("content-type") || "";
            return consumeBody.call(this).then(function(buf) {
              return Object.assign(
                // Prevent copying
                new Blob([], {
                  type: ct.toLowerCase()
                }),
                {
                  [BUFFER]: buf
                }
              );
            });
          },
          /**
           * Decode response as json
           *
           * @return  Promise
           */
          json() {
            var _this2 = this;
            return consumeBody.call(this).then(function(buffer) {
              try {
                return JSON.parse(buffer.toString());
              } catch (err) {
                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
              }
            });
          },
          /**
           * Decode response as text
           *
           * @return  Promise
           */
          text() {
            return consumeBody.call(this).then(function(buffer) {
              return buffer.toString();
            });
          },
          /**
           * Decode response as buffer (non-spec api)
           *
           * @return  Promise
           */
          buffer() {
            return consumeBody.call(this);
          },
          /**
           * Decode response as text, while automatically detecting the encoding and
           * trying to decode to UTF-8 (non-spec api)
           *
           * @return  Promise
           */
          textConverted() {
            var _this3 = this;
            return consumeBody.call(this).then(function(buffer) {
              return convertBody(buffer, _this3.headers);
            });
          }
        };
        Object.defineProperties(Body.prototype, {
          body: { enumerable: true },
          bodyUsed: { enumerable: true },
          arrayBuffer: { enumerable: true },
          blob: { enumerable: true },
          json: { enumerable: true },
          text: { enumerable: true }
        });
        Body.mixIn = function(proto) {
          for (const name of Object.getOwnPropertyNames(Body.prototype)) {
            if (!(name in proto)) {
              const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
              Object.defineProperty(proto, name, desc);
            }
          }
        };
        function consumeBody() {
          var _this4 = this;
          if (this[INTERNALS].disturbed) {
            return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
          }
          this[INTERNALS].disturbed = true;
          if (this[INTERNALS].error) {
            return Body.Promise.reject(this[INTERNALS].error);
          }
          let body = this.body;
          if (body === null) {
            return Body.Promise.resolve(Buffer.alloc(0));
          }
          if (isBlob(body)) {
            body = body.stream();
          }
          if (Buffer.isBuffer(body)) {
            return Body.Promise.resolve(body);
          }
          if (!(body instanceof Stream)) {
            return Body.Promise.resolve(Buffer.alloc(0));
          }
          let accum = [];
          let accumBytes = 0;
          let abort = false;
          return new Body.Promise(function(resolve, reject) {
            let resTimeout;
            if (_this4.timeout) {
              resTimeout = setTimeout(function() {
                abort = true;
                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
              }, _this4.timeout);
            }
            body.on("error", function(err) {
              if (err.name === "AbortError") {
                abort = true;
                reject(err);
              } else {
                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
              }
            });
            body.on("data", function(chunk) {
              if (abort || chunk === null) {
                return;
              }
              if (_this4.size && accumBytes + chunk.length > _this4.size) {
                abort = true;
                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
                return;
              }
              accumBytes += chunk.length;
              accum.push(chunk);
            });
            body.on("end", function() {
              if (abort) {
                return;
              }
              clearTimeout(resTimeout);
              try {
                resolve(Buffer.concat(accum, accumBytes));
              } catch (err) {
                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
              }
            });
          });
        }
        function convertBody(buffer, headers) {
          if (typeof convert !== "function") {
            throw new Error("The package `encoding` must be installed to use the textConverted() function");
          }
          const ct = headers.get("content-type");
          let charset = "utf-8";
          let res, str;
          if (ct) {
            res = /charset=([^;]*)/i.exec(ct);
          }
          str = buffer.slice(0, 1024).toString();
          if (!res && str) {
            res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
          }
          if (!res && str) {
            res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
            if (!res) {
              res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
              if (res) {
                res.pop();
              }
            }
            if (res) {
              res = /charset=(.*)/i.exec(res.pop());
            }
          }
          if (!res && str) {
            res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
          }
          if (res) {
            charset = res.pop();
            if (charset === "gb2312" || charset === "gbk") {
              charset = "gb18030";
            }
          }
          return convert(buffer, "UTF-8", charset).toString();
        }
        function isURLSearchParams(obj) {
          if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
            return false;
          }
          return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
        }
        function isBlob(obj) {
          return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
        }
        function clone(instance) {
          let p1, p2;
          let body = instance.body;
          if (instance.bodyUsed) {
            throw new Error("cannot clone body after it is used");
          }
          if (body instanceof Stream && typeof body.getBoundary !== "function") {
            p1 = new PassThrough();
            p2 = new PassThrough();
            body.pipe(p1);
            body.pipe(p2);
            instance[INTERNALS].body = p1;
            body = p2;
          }
          return body;
        }
        function extractContentType(body) {
          if (body === null) {
            return null;
          } else if (typeof body === "string") {
            return "text/plain;charset=UTF-8";
          } else if (isURLSearchParams(body)) {
            return "application/x-www-form-urlencoded;charset=UTF-8";
          } else if (isBlob(body)) {
            return body.type || null;
          } else if (Buffer.isBuffer(body)) {
            return null;
          } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
            return null;
          } else if (ArrayBuffer.isView(body)) {
            return null;
          } else if (typeof body.getBoundary === "function") {
            return `multipart/form-data;boundary=${body.getBoundary()}`;
          } else if (body instanceof Stream) {
            return null;
          } else {
            return "text/plain;charset=UTF-8";
          }
        }
        function getTotalBytes(instance) {
          const body = instance.body;
          if (body === null) {
            return 0;
          } else if (isBlob(body)) {
            return body.size;
          } else if (Buffer.isBuffer(body)) {
            return body.length;
          } else if (body && typeof body.getLengthSync === "function") {
            if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
            body.hasKnownLength && body.hasKnownLength()) {
              return body.getLengthSync();
            }
            return null;
          } else {
            return null;
          }
        }
        function writeToStream(dest, instance) {
          const body = instance.body;
          if (body === null) {
            dest.end();
          } else if (isBlob(body)) {
            body.stream().pipe(dest);
          } else if (Buffer.isBuffer(body)) {
            dest.write(body);
            dest.end();
          } else {
            body.pipe(dest);
          }
        }
        Body.Promise = global.Promise;
        var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
        var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
        function validateName(name) {
          name = `${name}`;
          if (invalidTokenRegex.test(name) || name === "") {
            throw new TypeError(`${name} is not a legal HTTP header name`);
          }
        }
        function validateValue(value) {
          value = `${value}`;
          if (invalidHeaderCharRegex.test(value)) {
            throw new TypeError(`${value} is not a legal HTTP header value`);
          }
        }
        function find(map, name) {
          name = name.toLowerCase();
          for (const key in map) {
            if (key.toLowerCase() === name) {
              return key;
            }
          }
          return void 0;
        }
        var MAP = Symbol("map");
        var Headers = class _Headers {
          /**
           * Headers class
           *
           * @param   Object  headers  Response headers
           * @return  Void
           */
          constructor() {
            let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
            this[MAP] = /* @__PURE__ */ Object.create(null);
            if (init instanceof _Headers) {
              const rawHeaders = init.raw();
              const headerNames = Object.keys(rawHeaders);
              for (const headerName of headerNames) {
                for (const value of rawHeaders[headerName]) {
                  this.append(headerName, value);
                }
              }
              return;
            }
            if (init == null)
              ;
            else if (typeof init === "object") {
              const method = init[Symbol.iterator];
              if (method != null) {
                if (typeof method !== "function") {
                  throw new TypeError("Header pairs must be iterable");
                }
                const pairs = [];
                for (const pair of init) {
                  if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                    throw new TypeError("Each header pair must be iterable");
                  }
                  pairs.push(Array.from(pair));
                }
                for (const pair of pairs) {
                  if (pair.length !== 2) {
                    throw new TypeError("Each header pair must be a name/value tuple");
                  }
                  this.append(pair[0], pair[1]);
                }
              } else {
                for (const key of Object.keys(init)) {
                  const value = init[key];
                  this.append(key, value);
                }
              }
            } else {
              throw new TypeError("Provided initializer must be an object");
            }
          }
          /**
           * Return combined header value given name
           *
           * @param   String  name  Header name
           * @return  Mixed
           */
          get(name) {
            name = `${name}`;
            validateName(name);
            const key = find(this[MAP], name);
            if (key === void 0) {
              return null;
            }
            return this[MAP][key].join(", ");
          }
          /**
           * Iterate over all headers
           *
           * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
           * @param   Boolean   thisArg   `this` context for callback function
           * @return  Void
           */
          forEach(callback) {
            let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
            let pairs = getHeaders(this);
            let i = 0;
            while (i < pairs.length) {
              var _pairs$i = pairs[i];
              const name = _pairs$i[0], value = _pairs$i[1];
              callback.call(thisArg, value, name, this);
              pairs = getHeaders(this);
              i++;
            }
          }
          /**
           * Overwrite header values given name
           *
           * @param   String  name   Header name
           * @param   String  value  Header value
           * @return  Void
           */
          set(name, value) {
            name = `${name}`;
            value = `${value}`;
            validateName(name);
            validateValue(value);
            const key = find(this[MAP], name);
            this[MAP][key !== void 0 ? key : name] = [value];
          }
          /**
           * Append a value onto existing header
           *
           * @param   String  name   Header name
           * @param   String  value  Header value
           * @return  Void
           */
          append(name, value) {
            name = `${name}`;
            value = `${value}`;
            validateName(name);
            validateValue(value);
            const key = find(this[MAP], name);
            if (key !== void 0) {
              this[MAP][key].push(value);
            } else {
              this[MAP][name] = [value];
            }
          }
          /**
           * Check for header name existence
           *
           * @param   String   name  Header name
           * @return  Boolean
           */
          has(name) {
            name = `${name}`;
            validateName(name);
            return find(this[MAP], name) !== void 0;
          }
          /**
           * Delete all header values given name
           *
           * @param   String  name  Header name
           * @return  Void
           */
          delete(name) {
            name = `${name}`;
            validateName(name);
            const key = find(this[MAP], name);
            if (key !== void 0) {
              delete this[MAP][key];
            }
          }
          /**
           * Return raw headers (non-spec api)
           *
           * @return  Object
           */
          raw() {
            return this[MAP];
          }
          /**
           * Get an iterator on keys.
           *
           * @return  Iterator
           */
          keys() {
            return createHeadersIterator(this, "key");
          }
          /**
           * Get an iterator on values.
           *
           * @return  Iterator
           */
          values() {
            return createHeadersIterator(this, "value");
          }
          /**
           * Get an iterator on entries.
           *
           * This is the default iterator of the Headers object.
           *
           * @return  Iterator
           */
          [Symbol.iterator]() {
            return createHeadersIterator(this, "key+value");
          }
        };
        Headers.prototype.entries = Headers.prototype[Symbol.iterator];
        Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
          value: "Headers",
          writable: false,
          enumerable: false,
          configurable: true
        });
        Object.defineProperties(Headers.prototype, {
          get: { enumerable: true },
          forEach: { enumerable: true },
          set: { enumerable: true },
          append: { enumerable: true },
          has: { enumerable: true },
          delete: { enumerable: true },
          keys: { enumerable: true },
          values: { enumerable: true },
          entries: { enumerable: true }
        });
        function getHeaders(headers) {
          let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
          const keys = Object.keys(headers[MAP]).sort();
          return keys.map(kind === "key" ? function(k) {
            return k.toLowerCase();
          } : kind === "value" ? function(k) {
            return headers[MAP][k].join(", ");
          } : function(k) {
            return [k.toLowerCase(), headers[MAP][k].join(", ")];
          });
        }
        var INTERNAL = Symbol("internal");
        function createHeadersIterator(target, kind) {
          const iterator = Object.create(HeadersIteratorPrototype);
          iterator[INTERNAL] = {
            target,
            kind,
            index: 0
          };
          return iterator;
        }
        var HeadersIteratorPrototype = Object.setPrototypeOf({
          next() {
            if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
              throw new TypeError("Value of `this` is not a HeadersIterator");
            }
            var _INTERNAL = this[INTERNAL];
            const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
            const values = getHeaders(target, kind);
            const len = values.length;
            if (index >= len) {
              return {
                value: void 0,
                done: true
              };
            }
            this[INTERNAL].index = index + 1;
            return {
              value: values[index],
              done: false
            };
          }
        }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
        Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
          value: "HeadersIterator",
          writable: false,
          enumerable: false,
          configurable: true
        });
        function exportNodeCompatibleHeaders(headers) {
          const obj = Object.assign({ __proto__: null }, headers[MAP]);
          const hostHeaderKey = find(headers[MAP], "Host");
          if (hostHeaderKey !== void 0) {
            obj[hostHeaderKey] = obj[hostHeaderKey][0];
          }
          return obj;
        }
        function createHeadersLenient(obj) {
          const headers = new Headers();
          for (const name of Object.keys(obj)) {
            if (invalidTokenRegex.test(name)) {
              continue;
            }
            if (Array.isArray(obj[name])) {
              for (const val of obj[name]) {
                if (invalidHeaderCharRegex.test(val)) {
                  continue;
                }
                if (headers[MAP][name] === void 0) {
                  headers[MAP][name] = [val];
                } else {
                  headers[MAP][name].push(val);
                }
              }
            } else if (!invalidHeaderCharRegex.test(obj[name])) {
              headers[MAP][name] = [obj[name]];
            }
          }
          return headers;
        }
        var INTERNALS$1 = Symbol("Response internals");
        var STATUS_CODES = http.STATUS_CODES;
        var Response = class _Response {
          constructor() {
            let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            Body.call(this, body, opts);
            const status = opts.status || 200;
            const headers = new Headers(opts.headers);
            if (body != null && !headers.has("Content-Type")) {
              const contentType = extractContentType(body);
              if (contentType) {
                headers.append("Content-Type", contentType);
              }
            }
            this[INTERNALS$1] = {
              url: opts.url,
              status,
              statusText: opts.statusText || STATUS_CODES[status],
              headers,
              counter: opts.counter
            };
          }
          get url() {
            return this[INTERNALS$1].url || "";
          }
          get status() {
            return this[INTERNALS$1].status;
          }
          /**
           * Convenience property representing if the request ended normally
           */
          get ok() {
            return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
          }
          get redirected() {
            return this[INTERNALS$1].counter > 0;
          }
          get statusText() {
            return this[INTERNALS$1].statusText;
          }
          get headers() {
            return this[INTERNALS$1].headers;
          }
          /**
           * Clone this response
           *
           * @return  Response
           */
          clone() {
            return new _Response(clone(this), {
              url: this.url,
              status: this.status,
              statusText: this.statusText,
              headers: this.headers,
              ok: this.ok,
              redirected: this.redirected
            });
          }
        };
        Body.mixIn(Response.prototype);
        Object.defineProperties(Response.prototype, {
          url: { enumerable: true },
          status: { enumerable: true },
          ok: { enumerable: true },
          redirected: { enumerable: true },
          statusText: { enumerable: true },
          headers: { enumerable: true },
          clone: { enumerable: true }
        });
        Object.defineProperty(Response.prototype, Symbol.toStringTag, {
          value: "Response",
          writable: false,
          enumerable: false,
          configurable: true
        });
        var INTERNALS$2 = Symbol("Request internals");
        var URL2 = Url.URL || whatwgUrl.URL;
        var parse_url = Url.parse;
        var format_url = Url.format;
        function parseURL(urlStr) {
          if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
            urlStr = new URL2(urlStr).toString();
          }
          return parse_url(urlStr);
        }
        var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
        function isRequest(input) {
          return typeof input === "object" && typeof input[INTERNALS$2] === "object";
        }
        function isAbortSignal(signal) {
          const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
          return !!(proto && proto.constructor.name === "AbortSignal");
        }
        var Request = class _Request {
          constructor(input) {
            let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            let parsedURL;
            if (!isRequest(input)) {
              if (input && input.href) {
                parsedURL = parseURL(input.href);
              } else {
                parsedURL = parseURL(`${input}`);
              }
              input = {};
            } else {
              parsedURL = parseURL(input.url);
            }
            let method = init.method || input.method || "GET";
            method = method.toUpperCase();
            if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
              throw new TypeError("Request with GET/HEAD method cannot have body");
            }
            let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
            Body.call(this, inputBody, {
              timeout: init.timeout || input.timeout || 0,
              size: init.size || input.size || 0
            });
            const headers = new Headers(init.headers || input.headers || {});
            if (inputBody != null && !headers.has("Content-Type")) {
              const contentType = extractContentType(inputBody);
              if (contentType) {
                headers.append("Content-Type", contentType);
              }
            }
            let signal = isRequest(input) ? input.signal : null;
            if ("signal" in init)
              signal = init.signal;
            if (signal != null && !isAbortSignal(signal)) {
              throw new TypeError("Expected signal to be an instanceof AbortSignal");
            }
            this[INTERNALS$2] = {
              method,
              redirect: init.redirect || input.redirect || "follow",
              headers,
              parsedURL,
              signal
            };
            this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
            this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
            this.counter = init.counter || input.counter || 0;
            this.agent = init.agent || input.agent;
          }
          get method() {
            return this[INTERNALS$2].method;
          }
          get url() {
            return format_url(this[INTERNALS$2].parsedURL);
          }
          get headers() {
            return this[INTERNALS$2].headers;
          }
          get redirect() {
            return this[INTERNALS$2].redirect;
          }
          get signal() {
            return this[INTERNALS$2].signal;
          }
          /**
           * Clone this request
           *
           * @return  Request
           */
          clone() {
            return new _Request(this);
          }
        };
        Body.mixIn(Request.prototype);
        Object.defineProperty(Request.prototype, Symbol.toStringTag, {
          value: "Request",
          writable: false,
          enumerable: false,
          configurable: true
        });
        Object.defineProperties(Request.prototype, {
          method: { enumerable: true },
          url: { enumerable: true },
          headers: { enumerable: true },
          redirect: { enumerable: true },
          clone: { enumerable: true },
          signal: { enumerable: true }
        });
        function getNodeRequestOptions(request) {
          const parsedURL = request[INTERNALS$2].parsedURL;
          const headers = new Headers(request[INTERNALS$2].headers);
          if (!headers.has("Accept")) {
            headers.set("Accept", "*/*");
          }
          if (!parsedURL.protocol || !parsedURL.hostname) {
            throw new TypeError("Only absolute URLs are supported");
          }
          if (!/^https?:$/.test(parsedURL.protocol)) {
            throw new TypeError("Only HTTP(S) protocols are supported");
          }
          if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
            throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
          }
          let contentLengthValue = null;
          if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
            contentLengthValue = "0";
          }
          if (request.body != null) {
            const totalBytes = getTotalBytes(request);
            if (typeof totalBytes === "number") {
              contentLengthValue = String(totalBytes);
            }
          }
          if (contentLengthValue) {
            headers.set("Content-Length", contentLengthValue);
          }
          if (!headers.has("User-Agent")) {
            headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
          }
          if (request.compress && !headers.has("Accept-Encoding")) {
            headers.set("Accept-Encoding", "gzip,deflate");
          }
          let agent = request.agent;
          if (typeof agent === "function") {
            agent = agent(parsedURL);
          }
          if (!headers.has("Connection") && !agent) {
            headers.set("Connection", "close");
          }
          return Object.assign({}, parsedURL, {
            method: request.method,
            headers: exportNodeCompatibleHeaders(headers),
            agent
          });
        }
        function AbortError(message) {
          Error.call(this, message);
          this.type = "aborted";
          this.message = message;
          Error.captureStackTrace(this, this.constructor);
        }
        AbortError.prototype = Object.create(Error.prototype);
        AbortError.prototype.constructor = AbortError;
        AbortError.prototype.name = "AbortError";
        var URL$1 = Url.URL || whatwgUrl.URL;
        var PassThrough$1 = Stream.PassThrough;
        var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
          const orig = new URL$1(original).hostname;
          const dest = new URL$1(destination).hostname;
          return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
        };
        function fetch2(url, opts) {
          if (!fetch2.Promise) {
            throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
          }
          Body.Promise = fetch2.Promise;
          return new fetch2.Promise(function(resolve, reject) {
            const request = new Request(url, opts);
            const options = getNodeRequestOptions(request);
            const send = (options.protocol === "https:" ? https : http).request;
            const signal = request.signal;
            let response = null;
            const abort = function abort2() {
              let error = new AbortError("The user aborted a request.");
              reject(error);
              if (request.body && request.body instanceof Stream.Readable) {
                request.body.destroy(error);
              }
              if (!response || !response.body)
                return;
              response.body.emit("error", error);
            };
            if (signal && signal.aborted) {
              abort();
              return;
            }
            const abortAndFinalize = function abortAndFinalize2() {
              abort();
              finalize();
            };
            const req = send(options);
            let reqTimeout;
            if (signal) {
              signal.addEventListener("abort", abortAndFinalize);
            }
            function finalize() {
              req.abort();
              if (signal)
                signal.removeEventListener("abort", abortAndFinalize);
              clearTimeout(reqTimeout);
            }
            if (request.timeout) {
              req.once("socket", function(socket) {
                reqTimeout = setTimeout(function() {
                  reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
                  finalize();
                }, request.timeout);
              });
            }
            req.on("error", function(err) {
              reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
              finalize();
            });
            req.on("response", function(res) {
              clearTimeout(reqTimeout);
              const headers = createHeadersLenient(res.headers);
              if (fetch2.isRedirect(res.statusCode)) {
                const location = headers.get("Location");
                let locationURL = null;
                try {
                  locationURL = location === null ? null : new URL$1(location, request.url).toString();
                } catch (err) {
                  if (request.redirect !== "manual") {
                    reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
                    finalize();
                    return;
                  }
                }
                switch (request.redirect) {
                  case "error":
                    reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
                    finalize();
                    return;
                  case "manual":
                    if (locationURL !== null) {
                      try {
                        headers.set("Location", locationURL);
                      } catch (err) {
                        reject(err);
                      }
                    }
                    break;
                  case "follow":
                    if (locationURL === null) {
                      break;
                    }
                    if (request.counter >= request.follow) {
                      reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                      finalize();
                      return;
                    }
                    const requestOpts = {
                      headers: new Headers(request.headers),
                      follow: request.follow,
                      counter: request.counter + 1,
                      agent: request.agent,
                      compress: request.compress,
                      method: request.method,
                      body: request.body,
                      signal: request.signal,
                      timeout: request.timeout,
                      size: request.size
                    };
                    if (!isDomainOrSubdomain(request.url, locationURL)) {
                      for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                        requestOpts.headers.delete(name);
                      }
                    }
                    if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                      reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                      finalize();
                      return;
                    }
                    if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                      requestOpts.method = "GET";
                      requestOpts.body = void 0;
                      requestOpts.headers.delete("content-length");
                    }
                    resolve(fetch2(new Request(locationURL, requestOpts)));
                    finalize();
                    return;
                }
              }
              res.once("end", function() {
                if (signal)
                  signal.removeEventListener("abort", abortAndFinalize);
              });
              let body = res.pipe(new PassThrough$1());
              const response_options = {
                url: request.url,
                status: res.statusCode,
                statusText: res.statusMessage,
                headers,
                size: request.size,
                timeout: request.timeout,
                counter: request.counter
              };
              const codings = headers.get("Content-Encoding");
              if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
                response = new Response(body, response_options);
                resolve(response);
                return;
              }
              const zlibOptions = {
                flush: zlib2.Z_SYNC_FLUSH,
                finishFlush: zlib2.Z_SYNC_FLUSH
              };
              if (codings == "gzip" || codings == "x-gzip") {
                body = body.pipe(zlib2.createGunzip(zlibOptions));
                response = new Response(body, response_options);
                resolve(response);
                return;
              }
              if (codings == "deflate" || codings == "x-deflate") {
                const raw2 = res.pipe(new PassThrough$1());
                raw2.once("data", function(chunk) {
                  if ((chunk[0] & 15) === 8) {
                    body = body.pipe(zlib2.createInflate());
                  } else {
                    body = body.pipe(zlib2.createInflateRaw());
                  }
                  response = new Response(body, response_options);
                  resolve(response);
                });
                return;
              }
              if (codings == "br" && typeof zlib2.createBrotliDecompress === "function") {
                body = body.pipe(zlib2.createBrotliDecompress());
                response = new Response(body, response_options);
                resolve(response);
                return;
              }
              response = new Response(body, response_options);
              resolve(response);
            });
            writeToStream(req, request);
          });
        }
        fetch2.isRedirect = function(code) {
          return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
        };
        fetch2.Promise = global.Promise;
        module2.exports = exports2 = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.default = exports2;
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.FetchError = FetchError;
      }
    });
    var require_retry_operation = __commonJS({
      "../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/lib/retry_operation.js"(exports2, module2) {
        function RetryOperation(timeouts, options) {
          if (typeof options === "boolean") {
            options = { forever: options };
          }
          this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
          this._timeouts = timeouts;
          this._options = options || {};
          this._maxRetryTime = options && options.maxRetryTime || Infinity;
          this._fn = null;
          this._errors = [];
          this._attempts = 1;
          this._operationTimeout = null;
          this._operationTimeoutCb = null;
          this._timeout = null;
          this._operationStart = null;
          if (this._options.forever) {
            this._cachedTimeouts = this._timeouts.slice(0);
          }
        }
        module2.exports = RetryOperation;
        RetryOperation.prototype.reset = function() {
          this._attempts = 1;
          this._timeouts = this._originalTimeouts;
        };
        RetryOperation.prototype.stop = function() {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          this._timeouts = [];
          this._cachedTimeouts = null;
        };
        RetryOperation.prototype.retry = function(err) {
          if (this._timeout) {
            clearTimeout(this._timeout);
          }
          if (!err) {
            return false;
          }
          var currentTime = (/* @__PURE__ */ new Date()).getTime();
          if (err && currentTime - this._operationStart >= this._maxRetryTime) {
            this._errors.unshift(new Error("RetryOperation timeout occurred"));
            return false;
          }
          this._errors.push(err);
          var timeout = this._timeouts.shift();
          if (timeout === void 0) {
            if (this._cachedTimeouts) {
              this._errors.splice(this._errors.length - 1, this._errors.length);
              this._timeouts = this._cachedTimeouts.slice(0);
              timeout = this._timeouts.shift();
            } else {
              return false;
            }
          }
          var self2 = this;
          var timer = setTimeout(function() {
            self2._attempts++;
            if (self2._operationTimeoutCb) {
              self2._timeout = setTimeout(function() {
                self2._operationTimeoutCb(self2._attempts);
              }, self2._operationTimeout);
              if (self2._options.unref) {
                self2._timeout.unref();
              }
            }
            self2._fn(self2._attempts);
          }, timeout);
          if (this._options.unref) {
            timer.unref();
          }
          return true;
        };
        RetryOperation.prototype.attempt = function(fn, timeoutOps) {
          this._fn = fn;
          if (timeoutOps) {
            if (timeoutOps.timeout) {
              this._operationTimeout = timeoutOps.timeout;
            }
            if (timeoutOps.cb) {
              this._operationTimeoutCb = timeoutOps.cb;
            }
          }
          var self2 = this;
          if (this._operationTimeoutCb) {
            this._timeout = setTimeout(function() {
              self2._operationTimeoutCb();
            }, self2._operationTimeout);
          }
          this._operationStart = (/* @__PURE__ */ new Date()).getTime();
          this._fn(this._attempts);
        };
        RetryOperation.prototype.try = function(fn) {
          console.log("Using RetryOperation.try() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = function(fn) {
          console.log("Using RetryOperation.start() is deprecated");
          this.attempt(fn);
        };
        RetryOperation.prototype.start = RetryOperation.prototype.try;
        RetryOperation.prototype.errors = function() {
          return this._errors;
        };
        RetryOperation.prototype.attempts = function() {
          return this._attempts;
        };
        RetryOperation.prototype.mainError = function() {
          if (this._errors.length === 0) {
            return null;
          }
          var counts = {};
          var mainError = null;
          var mainErrorCount = 0;
          for (var i = 0; i < this._errors.length; i++) {
            var error = this._errors[i];
            var message = error.message;
            var count = (counts[message] || 0) + 1;
            counts[message] = count;
            if (count >= mainErrorCount) {
              mainError = error;
              mainErrorCount = count;
            }
          }
          return mainError;
        };
      }
    });
    var require_retry = __commonJS({
      "../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/lib/retry.js"(exports2) {
        var RetryOperation = require_retry_operation();
        exports2.operation = function(options) {
          var timeouts = exports2.timeouts(options);
          return new RetryOperation(timeouts, {
            forever: options && options.forever,
            unref: options && options.unref,
            maxRetryTime: options && options.maxRetryTime
          });
        };
        exports2.timeouts = function(options) {
          if (options instanceof Array) {
            return [].concat(options);
          }
          var opts = {
            retries: 10,
            factor: 2,
            minTimeout: 1 * 1e3,
            maxTimeout: Infinity,
            randomize: false
          };
          for (var key in options) {
            opts[key] = options[key];
          }
          if (opts.minTimeout > opts.maxTimeout) {
            throw new Error("minTimeout is greater than maxTimeout");
          }
          var timeouts = [];
          for (var i = 0; i < opts.retries; i++) {
            timeouts.push(this.createTimeout(i, opts));
          }
          if (options && options.forever && !timeouts.length) {
            timeouts.push(this.createTimeout(i, opts));
          }
          timeouts.sort(function(a, b) {
            return a - b;
          });
          return timeouts;
        };
        exports2.createTimeout = function(attempt, opts) {
          var random = opts.randomize ? Math.random() + 1 : 1;
          var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
          timeout = Math.min(timeout, opts.maxTimeout);
          return timeout;
        };
        exports2.wrap = function(obj, options, methods) {
          if (options instanceof Array) {
            methods = options;
            options = null;
          }
          if (!methods) {
            methods = [];
            for (var key in obj) {
              if (typeof obj[key] === "function") {
                methods.push(key);
              }
            }
          }
          for (var i = 0; i < methods.length; i++) {
            var method = methods[i];
            var original = obj[method];
            obj[method] = function retryWrapper(original2) {
              var op = exports2.operation(options);
              var args = Array.prototype.slice.call(arguments, 1);
              var callback = args.pop();
              args.push(function(err) {
                if (op.retry(err)) {
                  return;
                }
                if (err) {
                  arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
              });
              op.attempt(function() {
                original2.apply(obj, args);
              });
            }.bind(obj, original);
            obj[method].options = options;
          }
        };
      }
    });
    var require_retry2 = __commonJS({
      "../../node_modules/.pnpm/retry@0.12.0/node_modules/retry/index.js"(exports2, module2) {
        module2.exports = require_retry();
      }
    });
    var require_lib4 = __commonJS({
      "../../node_modules/.pnpm/async-retry@1.2.3/node_modules/async-retry/lib/index.js"(exports2, module2) {
        var retrier = require_retry2();
        function retry2(fn, opts) {
          function run(resolve, reject) {
            var options = opts || {};
            var op = retrier.operation(options);
            function bail(err) {
              reject(err || new Error("Aborted"));
            }
            function onError(err, num) {
              if (err.bail) {
                bail(err);
                return;
              }
              if (!op.retry(err)) {
                reject(op.mainError());
              } else if (options.onRetry) {
                options.onRetry(err, num);
              }
            }
            function runAttempt(num) {
              var val;
              try {
                val = fn(bail, num);
              } catch (err) {
                onError(err, num);
                return;
              }
              Promise.resolve(val).then(resolve).catch(function catchIt(err) {
                onError(err, num);
              });
            }
            op.attempt(runAttempt);
          }
          return new Promise(run);
        }
        module2.exports = retry2;
      }
    });
    var require_buffer_crc32 = __commonJS({
      "../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js"(exports2, module2) {
        var Buffer2 = require("buffer").Buffer;
        var CRC_TABLE = [
          0,
          1996959894,
          3993919788,
          2567524794,
          124634137,
          1886057615,
          3915621685,
          2657392035,
          249268274,
          2044508324,
          3772115230,
          2547177864,
          162941995,
          2125561021,
          3887607047,
          2428444049,
          498536548,
          1789927666,
          4089016648,
          2227061214,
          450548861,
          1843258603,
          4107580753,
          2211677639,
          325883990,
          1684777152,
          4251122042,
          2321926636,
          335633487,
          1661365465,
          4195302755,
          2366115317,
          997073096,
          1281953886,
          3579855332,
          2724688242,
          1006888145,
          1258607687,
          3524101629,
          2768942443,
          901097722,
          1119000684,
          3686517206,
          2898065728,
          853044451,
          1172266101,
          3705015759,
          2882616665,
          651767980,
          1373503546,
          3369554304,
          3218104598,
          565507253,
          1454621731,
          3485111705,
          3099436303,
          671266974,
          1594198024,
          3322730930,
          2970347812,
          795835527,
          1483230225,
          3244367275,
          3060149565,
          1994146192,
          31158534,
          2563907772,
          4023717930,
          1907459465,
          112637215,
          2680153253,
          3904427059,
          2013776290,
          251722036,
          2517215374,
          3775830040,
          2137656763,
          141376813,
          2439277719,
          3865271297,
          1802195444,
          476864866,
          2238001368,
          4066508878,
          1812370925,
          453092731,
          2181625025,
          4111451223,
          1706088902,
          314042704,
          2344532202,
          4240017532,
          1658658271,
          366619977,
          2362670323,
          4224994405,
          1303535960,
          984961486,
          2747007092,
          3569037538,
          1256170817,
          1037604311,
          2765210733,
          3554079995,
          1131014506,
          879679996,
          2909243462,
          3663771856,
          1141124467,
          855842277,
          2852801631,
          3708648649,
          1342533948,
          654459306,
          3188396048,
          3373015174,
          1466479909,
          544179635,
          3110523913,
          3462522015,
          1591671054,
          702138776,
          2966460450,
          3352799412,
          1504918807,
          783551873,
          3082640443,
          3233442989,
          3988292384,
          2596254646,
          62317068,
          1957810842,
          3939845945,
          2647816111,
          81470997,
          1943803523,
          3814918930,
          2489596804,
          225274430,
          2053790376,
          3826175755,
          2466906013,
          167816743,
          2097651377,
          4027552580,
          2265490386,
          503444072,
          1762050814,
          4150417245,
          2154129355,
          426522225,
          1852507879,
          4275313526,
          2312317920,
          282753626,
          1742555852,
          4189708143,
          2394877945,
          397917763,
          1622183637,
          3604390888,
          2714866558,
          953729732,
          1340076626,
          3518719985,
          2797360999,
          1068828381,
          1219638859,
          3624741850,
          2936675148,
          906185462,
          1090812512,
          3747672003,
          2825379669,
          829329135,
          1181335161,
          3412177804,
          3160834842,
          628085408,
          1382605366,
          3423369109,
          3138078467,
          570562233,
          1426400815,
          3317316542,
          2998733608,
          733239954,
          1555261956,
          3268935591,
          3050360625,
          752459403,
          1541320221,
          2607071920,
          3965973030,
          1969922972,
          40735498,
          2617837225,
          3943577151,
          1913087877,
          83908371,
          2512341634,
          3803740692,
          2075208622,
          213261112,
          2463272603,
          3855990285,
          2094854071,
          198958881,
          2262029012,
          4057260610,
          1759359992,
          534414190,
          2176718541,
          4139329115,
          1873836001,
          414664567,
          2282248934,
          4279200368,
          1711684554,
          285281116,
          2405801727,
          4167216745,
          1634467795,
          376229701,
          2685067896,
          3608007406,
          1308918612,
          956543938,
          2808555105,
          3495958263,
          1231636301,
          1047427035,
          2932959818,
          3654703836,
          1088359270,
          936918e3,
          2847714899,
          3736837829,
          1202900863,
          817233897,
          3183342108,
          3401237130,
          1404277552,
          615818150,
          3134207493,
          3453421203,
          1423857449,
          601450431,
          3009837614,
          3294710456,
          1567103746,
          711928724,
          3020668471,
          3272380065,
          1510334235,
          755167117
        ];
        if (typeof Int32Array !== "undefined") {
          CRC_TABLE = new Int32Array(CRC_TABLE);
        }
        function ensureBuffer(input) {
          if (Buffer2.isBuffer(input)) {
            return input;
          }
          var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
          if (typeof input === "number") {
            return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
          } else if (typeof input === "string") {
            return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
          } else {
            throw new Error("input must be buffer, number, or string, received " + typeof input);
          }
        }
        function bufferizeInt(num) {
          var tmp = ensureBuffer(4);
          tmp.writeInt32BE(num, 0);
          return tmp;
        }
        function _crc32(buf, previous) {
          buf = ensureBuffer(buf);
          if (Buffer2.isBuffer(previous)) {
            previous = previous.readUInt32BE(0);
          }
          var crc = ~~previous ^ -1;
          for (var n = 0; n < buf.length; n++) {
            crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
          }
          return crc ^ -1;
        }
        function crc32() {
          return bufferizeInt(_crc32.apply(null, arguments));
        }
        crc32.signed = function() {
          return _crc32.apply(null, arguments);
        };
        crc32.unsigned = function() {
          return _crc32.apply(null, arguments) >>> 0;
        };
        module2.exports = crc32;
      }
    });
    var require_yazl = __commonJS({
      "../../node_modules/.pnpm/yazl@2.5.1/node_modules/yazl/index.js"(exports2) {
        var fs6 = require("fs");
        var Transform = require("stream").Transform;
        var PassThrough = require("stream").PassThrough;
        var zlib2 = require("zlib");
        var util = require("util");
        var EventEmitter = require("events").EventEmitter;
        var crc32 = require_buffer_crc32();
        exports2.ZipFile = ZipFile2;
        exports2.dateToDosDateTime = dateToDosDateTime;
        util.inherits(ZipFile2, EventEmitter);
        function ZipFile2() {
          this.outputStream = new PassThrough();
          this.entries = [];
          this.outputStreamCursor = 0;
          this.ended = false;
          this.allDone = false;
          this.forceZip64Eocd = false;
        }
        ZipFile2.prototype.addFile = function(realPath, metadataPath, options) {
          var self2 = this;
          metadataPath = validateMetadataPath(metadataPath, false);
          if (options == null)
            options = {};
          var entry = new Entry(metadataPath, false, options);
          self2.entries.push(entry);
          fs6.stat(realPath, function(err, stats) {
            if (err)
              return self2.emit("error", err);
            if (!stats.isFile())
              return self2.emit("error", new Error("not a file: " + realPath));
            entry.uncompressedSize = stats.size;
            if (options.mtime == null)
              entry.setLastModDate(stats.mtime);
            if (options.mode == null)
              entry.setFileAttributesMode(stats.mode);
            entry.setFileDataPumpFunction(function() {
              var readStream = fs6.createReadStream(realPath);
              entry.state = Entry.FILE_DATA_IN_PROGRESS;
              readStream.on("error", function(err2) {
                self2.emit("error", err2);
              });
              pumpFileDataReadStream(self2, entry, readStream);
            });
            pumpEntries(self2);
          });
        };
        ZipFile2.prototype.addReadStream = function(readStream, metadataPath, options) {
          var self2 = this;
          metadataPath = validateMetadataPath(metadataPath, false);
          if (options == null)
            options = {};
          var entry = new Entry(metadataPath, false, options);
          self2.entries.push(entry);
          entry.setFileDataPumpFunction(function() {
            entry.state = Entry.FILE_DATA_IN_PROGRESS;
            pumpFileDataReadStream(self2, entry, readStream);
          });
          pumpEntries(self2);
        };
        ZipFile2.prototype.addBuffer = function(buffer, metadataPath, options) {
          var self2 = this;
          metadataPath = validateMetadataPath(metadataPath, false);
          if (buffer.length > 1073741823)
            throw new Error("buffer too large: " + buffer.length + " > 1073741823");
          if (options == null)
            options = {};
          if (options.size != null)
            throw new Error("options.size not allowed");
          var entry = new Entry(metadataPath, false, options);
          entry.uncompressedSize = buffer.length;
          entry.crc32 = crc32.unsigned(buffer);
          entry.crcAndFileSizeKnown = true;
          self2.entries.push(entry);
          if (!entry.compress) {
            setCompressedBuffer(buffer);
          } else {
            zlib2.deflateRaw(buffer, function(err, compressedBuffer) {
              setCompressedBuffer(compressedBuffer);
            });
          }
          function setCompressedBuffer(compressedBuffer) {
            entry.compressedSize = compressedBuffer.length;
            entry.setFileDataPumpFunction(function() {
              writeToOutputStream(self2, compressedBuffer);
              writeToOutputStream(self2, entry.getDataDescriptor());
              entry.state = Entry.FILE_DATA_DONE;
              setImmediate(function() {
                pumpEntries(self2);
              });
            });
            pumpEntries(self2);
          }
        };
        ZipFile2.prototype.addEmptyDirectory = function(metadataPath, options) {
          var self2 = this;
          metadataPath = validateMetadataPath(metadataPath, true);
          if (options == null)
            options = {};
          if (options.size != null)
            throw new Error("options.size not allowed");
          if (options.compress != null)
            throw new Error("options.compress not allowed");
          var entry = new Entry(metadataPath, true, options);
          self2.entries.push(entry);
          entry.setFileDataPumpFunction(function() {
            writeToOutputStream(self2, entry.getDataDescriptor());
            entry.state = Entry.FILE_DATA_DONE;
            pumpEntries(self2);
          });
          pumpEntries(self2);
        };
        var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
        ZipFile2.prototype.end = function(options, finalSizeCallback) {
          if (typeof options === "function") {
            finalSizeCallback = options;
            options = null;
          }
          if (options == null)
            options = {};
          if (this.ended)
            return;
          this.ended = true;
          this.finalSizeCallback = finalSizeCallback;
          this.forceZip64Eocd = !!options.forceZip64Format;
          if (options.comment) {
            if (typeof options.comment === "string") {
              this.comment = encodeCp437(options.comment);
            } else {
              this.comment = options.comment;
            }
            if (this.comment.length > 65535)
              throw new Error("comment is too large");
            if (bufferIncludes(this.comment, eocdrSignatureBuffer))
              throw new Error("comment contains end of central directory record signature");
          } else {
            this.comment = EMPTY_BUFFER;
          }
          pumpEntries(this);
        };
        function writeToOutputStream(self2, buffer) {
          self2.outputStream.write(buffer);
          self2.outputStreamCursor += buffer.length;
        }
        function pumpFileDataReadStream(self2, entry, readStream) {
          var crc32Watcher = new Crc32Watcher();
          var uncompressedSizeCounter = new ByteCounter();
          var compressor = entry.compress ? new zlib2.DeflateRaw() : new PassThrough();
          var compressedSizeCounter = new ByteCounter();
          readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
          compressedSizeCounter.on("end", function() {
            entry.crc32 = crc32Watcher.crc32;
            if (entry.uncompressedSize == null) {
              entry.uncompressedSize = uncompressedSizeCounter.byteCount;
            } else {
              if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount)
                return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
            }
            entry.compressedSize = compressedSizeCounter.byteCount;
            self2.outputStreamCursor += entry.compressedSize;
            writeToOutputStream(self2, entry.getDataDescriptor());
            entry.state = Entry.FILE_DATA_DONE;
            pumpEntries(self2);
          });
        }
        function pumpEntries(self2) {
          if (self2.allDone)
            return;
          if (self2.ended && self2.finalSizeCallback != null) {
            var finalSize = calculateFinalSize(self2);
            if (finalSize != null) {
              self2.finalSizeCallback(finalSize);
              self2.finalSizeCallback = null;
            }
          }
          var entry = getFirstNotDoneEntry();
          function getFirstNotDoneEntry() {
            for (var i = 0; i < self2.entries.length; i++) {
              var entry2 = self2.entries[i];
              if (entry2.state < Entry.FILE_DATA_DONE)
                return entry2;
            }
            return null;
          }
          if (entry != null) {
            if (entry.state < Entry.READY_TO_PUMP_FILE_DATA)
              return;
            if (entry.state === Entry.FILE_DATA_IN_PROGRESS)
              return;
            entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
            var localFileHeader = entry.getLocalFileHeader();
            writeToOutputStream(self2, localFileHeader);
            entry.doFileDataPump();
          } else {
            if (self2.ended) {
              self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
              self2.entries.forEach(function(entry2) {
                var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
                writeToOutputStream(self2, centralDirectoryRecord);
              });
              writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
              self2.outputStream.end();
              self2.allDone = true;
            }
          }
        }
        function calculateFinalSize(self2) {
          var pretendOutputCursor = 0;
          var centralDirectorySize = 0;
          for (var i = 0; i < self2.entries.length; i++) {
            var entry = self2.entries[i];
            if (entry.compress)
              return -1;
            if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
              if (entry.uncompressedSize == null)
                return -1;
            } else {
              if (entry.uncompressedSize == null)
                return null;
            }
            entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
            var useZip64Format = entry.useZip64Format();
            pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
            pretendOutputCursor += entry.uncompressedSize;
            if (!entry.crcAndFileSizeKnown) {
              if (useZip64Format) {
                pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
              } else {
                pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
              }
            }
            centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
            if (useZip64Format) {
              centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
            }
          }
          var endOfCentralDirectorySize = 0;
          if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
            endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
          }
          endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
          return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
        }
        var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
        var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
        var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
        function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
          var needZip64Format = false;
          var normalEntriesLength = self2.entries.length;
          if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
            normalEntriesLength = 65535;
            needZip64Format = true;
          }
          var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
          var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
          if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
            normalSizeOfCentralDirectory = 4294967295;
            needZip64Format = true;
          }
          var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
          if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
            normalOffsetOfStartOfCentralDirectory = 4294967295;
            needZip64Format = true;
          }
          if (actuallyJustTellMeHowLongItWouldBe) {
            if (needZip64Format) {
              return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
            } else {
              return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
            }
          }
          var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
          eocdrBuffer.writeUInt32LE(101010256, 0);
          eocdrBuffer.writeUInt16LE(0, 4);
          eocdrBuffer.writeUInt16LE(0, 6);
          eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
          eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
          eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
          eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
          eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
          self2.comment.copy(eocdrBuffer, 22);
          if (!needZip64Format)
            return eocdrBuffer;
          var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
          zip64EocdrBuffer.writeUInt32LE(101075792, 0);
          writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
          zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
          zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
          zip64EocdrBuffer.writeUInt32LE(0, 16);
          zip64EocdrBuffer.writeUInt32LE(0, 20);
          writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
          writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
          writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
          writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
          var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
          zip64EocdlBuffer.writeUInt32LE(117853008, 0);
          zip64EocdlBuffer.writeUInt32LE(0, 4);
          writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
          zip64EocdlBuffer.writeUInt32LE(1, 16);
          return Buffer.concat([
            zip64EocdrBuffer,
            zip64EocdlBuffer,
            eocdrBuffer
          ]);
        }
        function validateMetadataPath(metadataPath, isDirectory22) {
          if (metadataPath === "")
            throw new Error("empty metadataPath");
          metadataPath = metadataPath.replace(/\\/g, "/");
          if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath))
            throw new Error("absolute path: " + metadataPath);
          if (metadataPath.split("/").indexOf("..") !== -1)
            throw new Error("invalid relative path: " + metadataPath);
          var looksLikeDirectory = /\/$/.test(metadataPath);
          if (isDirectory22) {
            if (!looksLikeDirectory)
              metadataPath += "/";
          } else {
            if (looksLikeDirectory)
              throw new Error("file path cannot end with '/': " + metadataPath);
          }
          return metadataPath;
        }
        var EMPTY_BUFFER = bufferAlloc(0);
        function Entry(metadataPath, isDirectory22, options) {
          this.utf8FileName = bufferFrom(metadataPath);
          if (this.utf8FileName.length > 65535)
            throw new Error("utf8 file name too long. " + utf8FileName.length + " > 65535");
          this.isDirectory = isDirectory22;
          this.state = Entry.WAITING_FOR_METADATA;
          this.setLastModDate(options.mtime != null ? options.mtime : /* @__PURE__ */ new Date());
          if (options.mode != null) {
            this.setFileAttributesMode(options.mode);
          } else {
            this.setFileAttributesMode(isDirectory22 ? 16893 : 33204);
          }
          if (isDirectory22) {
            this.crcAndFileSizeKnown = true;
            this.crc32 = 0;
            this.uncompressedSize = 0;
            this.compressedSize = 0;
          } else {
            this.crcAndFileSizeKnown = false;
            this.crc32 = null;
            this.uncompressedSize = null;
            this.compressedSize = null;
            if (options.size != null)
              this.uncompressedSize = options.size;
          }
          if (isDirectory22) {
            this.compress = false;
          } else {
            this.compress = true;
            if (options.compress != null)
              this.compress = !!options.compress;
          }
          this.forceZip64Format = !!options.forceZip64Format;
          if (options.fileComment) {
            if (typeof options.fileComment === "string") {
              this.fileComment = bufferFrom(options.fileComment, "utf-8");
            } else {
              this.fileComment = options.fileComment;
            }
            if (this.fileComment.length > 65535)
              throw new Error("fileComment is too large");
          } else {
            this.fileComment = EMPTY_BUFFER;
          }
        }
        Entry.WAITING_FOR_METADATA = 0;
        Entry.READY_TO_PUMP_FILE_DATA = 1;
        Entry.FILE_DATA_IN_PROGRESS = 2;
        Entry.FILE_DATA_DONE = 3;
        Entry.prototype.setLastModDate = function(date) {
          var dosDateTime = dateToDosDateTime(date);
          this.lastModFileTime = dosDateTime.time;
          this.lastModFileDate = dosDateTime.date;
        };
        Entry.prototype.setFileAttributesMode = function(mode) {
          if ((mode & 65535) !== mode)
            throw new Error("invalid mode. expected: 0 <= " + mode + " <= 65535");
          this.externalFileAttributes = mode << 16 >>> 0;
        };
        Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
          this.doFileDataPump = doFileDataPump;
          this.state = Entry.READY_TO_PUMP_FILE_DATA;
        };
        Entry.prototype.useZip64Format = function() {
          return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
        };
        var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
        var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
        var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
        var VERSION_MADE_BY = 3 << 8 | 63;
        var FILE_NAME_IS_UTF8 = 1 << 11;
        var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
        Entry.prototype.getLocalFileHeader = function() {
          var crc322 = 0;
          var compressedSize = 0;
          var uncompressedSize = 0;
          if (this.crcAndFileSizeKnown) {
            crc322 = this.crc32;
            compressedSize = this.compressedSize;
            uncompressedSize = this.uncompressedSize;
          }
          var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
          var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
          if (!this.crcAndFileSizeKnown)
            generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
          fixedSizeStuff.writeUInt32LE(67324752, 0);
          fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
          fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
          fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
          fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
          fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
          fixedSizeStuff.writeUInt32LE(crc322, 14);
          fixedSizeStuff.writeUInt32LE(compressedSize, 18);
          fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
          fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
          fixedSizeStuff.writeUInt16LE(0, 28);
          return Buffer.concat([
            fixedSizeStuff,
            // file name (variable size)
            this.utf8FileName
            // extra field (variable size)
            // no extra fields
          ]);
        };
        var DATA_DESCRIPTOR_SIZE = 16;
        var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
        Entry.prototype.getDataDescriptor = function() {
          if (this.crcAndFileSizeKnown) {
            return EMPTY_BUFFER;
          }
          if (!this.useZip64Format()) {
            var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
            buffer.writeUInt32LE(134695760, 0);
            buffer.writeUInt32LE(this.crc32, 4);
            buffer.writeUInt32LE(this.compressedSize, 8);
            buffer.writeUInt32LE(this.uncompressedSize, 12);
            return buffer;
          } else {
            var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
            buffer.writeUInt32LE(134695760, 0);
            buffer.writeUInt32LE(this.crc32, 4);
            writeUInt64LE(buffer, this.compressedSize, 8);
            writeUInt64LE(buffer, this.uncompressedSize, 16);
            return buffer;
          }
        };
        var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
        var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
        Entry.prototype.getCentralDirectoryRecord = function() {
          var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
          var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
          if (!this.crcAndFileSizeKnown)
            generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
          var normalCompressedSize = this.compressedSize;
          var normalUncompressedSize = this.uncompressedSize;
          var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
          var versionNeededToExtract;
          var zeiefBuffer;
          if (this.useZip64Format()) {
            normalCompressedSize = 4294967295;
            normalUncompressedSize = 4294967295;
            normalRelativeOffsetOfLocalHeader = 4294967295;
            versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
            zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
            zeiefBuffer.writeUInt16LE(1, 0);
            zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
            writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
            writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
            writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
          } else {
            versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
            zeiefBuffer = EMPTY_BUFFER;
          }
          fixedSizeStuff.writeUInt32LE(33639248, 0);
          fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
          fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
          fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
          fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
          fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
          fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
          fixedSizeStuff.writeUInt32LE(this.crc32, 16);
          fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
          fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
          fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
          fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
          fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
          fixedSizeStuff.writeUInt16LE(0, 34);
          fixedSizeStuff.writeUInt16LE(0, 36);
          fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
          fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
          return Buffer.concat([
            fixedSizeStuff,
            // file name (variable size)
            this.utf8FileName,
            // extra field (variable size)
            zeiefBuffer,
            // file comment (variable size)
            this.fileComment
          ]);
        };
        Entry.prototype.getCompressionMethod = function() {
          var NO_COMPRESSION = 0;
          var DEFLATE_COMPRESSION = 8;
          return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
        };
        function dateToDosDateTime(jsDate) {
          var date = 0;
          date |= jsDate.getDate() & 31;
          date |= (jsDate.getMonth() + 1 & 15) << 5;
          date |= (jsDate.getFullYear() - 1980 & 127) << 9;
          var time = 0;
          time |= Math.floor(jsDate.getSeconds() / 2);
          time |= (jsDate.getMinutes() & 63) << 5;
          time |= (jsDate.getHours() & 31) << 11;
          return { date, time };
        }
        function writeUInt64LE(buffer, n, offset) {
          var high = Math.floor(n / 4294967296);
          var low = n % 4294967296;
          buffer.writeUInt32LE(low, offset);
          buffer.writeUInt32LE(high, offset + 4);
        }
        util.inherits(ByteCounter, Transform);
        function ByteCounter(options) {
          Transform.call(this, options);
          this.byteCount = 0;
        }
        ByteCounter.prototype._transform = function(chunk, encoding, cb) {
          this.byteCount += chunk.length;
          cb(null, chunk);
        };
        util.inherits(Crc32Watcher, Transform);
        function Crc32Watcher(options) {
          Transform.call(this, options);
          this.crc32 = 0;
        }
        Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
          this.crc32 = crc32.unsigned(chunk, this.crc32);
          cb(null, chunk);
        };
        var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
        if (cp437.length !== 256)
          throw new Error("assertion failure");
        var reverseCp437 = null;
        function encodeCp437(string) {
          if (/^[\x20-\x7e]*$/.test(string)) {
            return bufferFrom(string, "utf-8");
          }
          if (reverseCp437 == null) {
            reverseCp437 = {};
            for (var i = 0; i < cp437.length; i++) {
              reverseCp437[cp437[i]] = i;
            }
          }
          var result = bufferAlloc(string.length);
          for (var i = 0; i < string.length; i++) {
            var b = reverseCp437[string[i]];
            if (b == null)
              throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
            result[i] = b;
          }
          return result;
        }
        function bufferAlloc(size) {
          bufferAlloc = modern;
          try {
            return bufferAlloc(size);
          } catch (e) {
            bufferAlloc = legacy;
            return bufferAlloc(size);
          }
          function modern(size2) {
            return Buffer.allocUnsafe(size2);
          }
          function legacy(size2) {
            return new Buffer(size2);
          }
        }
        function bufferFrom(something, encoding) {
          bufferFrom = modern;
          try {
            return bufferFrom(something, encoding);
          } catch (e) {
            bufferFrom = legacy;
            return bufferFrom(something, encoding);
          }
          function modern(something2, encoding2) {
            return Buffer.from(something2, encoding2);
          }
          function legacy(something2, encoding2) {
            return new Buffer(something2, encoding2);
          }
        }
        function bufferIncludes(buffer, content) {
          bufferIncludes = modern;
          try {
            return bufferIncludes(buffer, content);
          } catch (e) {
            bufferIncludes = legacy;
            return bufferIncludes(buffer, content);
          }
          function modern(buffer2, content2) {
            return buffer2.includes(content2);
          }
          function legacy(buffer2, content2) {
            for (var i = 0; i <= buffer2.length - content2.length; i++) {
              for (var j = 0; ; j++) {
                if (j === content2.length)
                  return true;
                if (buffer2[i + j] !== content2[j])
                  break;
              }
            }
            return false;
          }
        }
      }
    });
    var require_concat_map = __commonJS({
      "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports2, module2) {
        module2.exports = function(xs, fn) {
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            var x = fn(xs[i], i);
            if (isArray(x))
              res.push.apply(res, x);
            else
              res.push(x);
          }
          return res;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      }
    });
    var require_balanced_match = __commonJS({
      "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports2, module2) {
        "use strict";
        module2.exports = balanced;
        function balanced(a, b, str) {
          if (a instanceof RegExp)
            a = maybeMatch(a, str);
          if (b instanceof RegExp)
            b = maybeMatch(b, str);
          var r = range(a, b, str);
          return r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length)
          };
        }
        function maybeMatch(reg, str) {
          var m = str.match(reg);
          return m ? m[0] : null;
        }
        balanced.range = range;
        function range(a, b, str) {
          var begs, beg, left, right, result;
          var ai = str.indexOf(a);
          var bi = str.indexOf(b, ai + 1);
          var i = ai;
          if (ai >= 0 && bi > 0) {
            if (a === b) {
              return [ai, bi];
            }
            begs = [];
            left = str.length;
            while (i >= 0 && !result) {
              if (i == ai) {
                begs.push(i);
                ai = str.indexOf(a, i + 1);
              } else if (begs.length == 1) {
                result = [begs.pop(), bi];
              } else {
                beg = begs.pop();
                if (beg < left) {
                  left = beg;
                  right = bi;
                }
                bi = str.indexOf(b, i + 1);
              }
              i = ai < bi && ai >= 0 ? ai : bi;
            }
            if (begs.length) {
              result = [left, right];
            }
          }
          return result;
        }
      }
    });
    var require_brace_expansion = __commonJS({
      "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports2, module2) {
        var concatMap = require_concat_map();
        var balanced = require_balanced_match();
        module2.exports = expandTop;
        var escSlash = "\0SLASH" + Math.random() + "\0";
        var escOpen = "\0OPEN" + Math.random() + "\0";
        var escClose = "\0CLOSE" + Math.random() + "\0";
        var escComma = "\0COMMA" + Math.random() + "\0";
        var escPeriod = "\0PERIOD" + Math.random() + "\0";
        function numeric(str) {
          return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
        }
        function escapeBraces(str) {
          return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
        }
        function unescapeBraces(str) {
          return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
        }
        function parseCommaParts(str) {
          if (!str)
            return [""];
          var parts = [];
          var m = balanced("{", "}", str);
          if (!m)
            return str.split(",");
          var pre = m.pre;
          var body = m.body;
          var post = m.post;
          var p = pre.split(",");
          p[p.length - 1] += "{" + body + "}";
          var postParts = parseCommaParts(post);
          if (post.length) {
            p[p.length - 1] += postParts.shift();
            p.push.apply(p, postParts);
          }
          parts.push.apply(parts, p);
          return parts;
        }
        function expandTop(str) {
          if (!str)
            return [];
          if (str.substr(0, 2) === "{}") {
            str = "\\{\\}" + str.substr(2);
          }
          return expand(escapeBraces(str), true).map(unescapeBraces);
        }
        function embrace(str) {
          return "{" + str + "}";
        }
        function isPadded(el) {
          return /^-?0\d/.test(el);
        }
        function lte(i, y) {
          return i <= y;
        }
        function gte2(i, y) {
          return i >= y;
        }
        function expand(str, isTop) {
          var expansions = [];
          var m = balanced("{", "}", str);
          if (!m || /\$$/.test(m.pre))
            return [str];
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand(n[0], false).map(embrace);
              if (n.length === 1) {
                var post = m.post.length ? expand(m.post, false) : [""];
                return post.map(function(p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var pre = m.pre;
          var post = m.post.length ? expand(m.post, false) : [""];
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte2;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\")
                  c = "";
              } else {
                c = String(i);
                if (pad) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0)
                      c = "-" + z + c.slice(1);
                    else
                      c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = concatMap(n, function(el) {
              return expand(el, false);
            });
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
          return expansions;
        }
      }
    });
    var require_minimatch = __commonJS({
      "../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js"(exports2, module2) {
        module2.exports = minimatch2;
        minimatch2.Minimatch = Minimatch;
        var path7 = (function() {
          try {
            return require("path");
          } catch (e) {
          }
        })() || {
          sep: "/"
        };
        minimatch2.sep = path7.sep;
        var GLOBSTAR = minimatch2.GLOBSTAR = Minimatch.GLOBSTAR = {};
        var expand = require_brace_expansion();
        var plTypes = {
          "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
          "?": { open: "(?:", close: ")?" },
          "+": { open: "(?:", close: ")+" },
          "*": { open: "(?:", close: ")*" },
          "@": { open: "(?:", close: ")" }
        };
        var qmark = "[^/]";
        var star = qmark + "*?";
        var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
        var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
        var reSpecials = charSet("().*{}+?[]^$\\!");
        function charSet(s) {
          return s.split("").reduce(function(set, c) {
            set[c] = true;
            return set;
          }, {});
        }
        var slashSplit = /\/+/;
        minimatch2.filter = filter;
        function filter(pattern, options) {
          options = options || {};
          return function(p, i, list) {
            return minimatch2(p, pattern, options);
          };
        }
        function ext(a, b) {
          b = b || {};
          var t = {};
          Object.keys(a).forEach(function(k) {
            t[k] = a[k];
          });
          Object.keys(b).forEach(function(k) {
            t[k] = b[k];
          });
          return t;
        }
        minimatch2.defaults = function(def) {
          if (!def || typeof def !== "object" || !Object.keys(def).length) {
            return minimatch2;
          }
          var orig = minimatch2;
          var m = function minimatch3(p, pattern, options) {
            return orig(p, pattern, ext(def, options));
          };
          m.Minimatch = function Minimatch2(pattern, options) {
            return new orig.Minimatch(pattern, ext(def, options));
          };
          m.Minimatch.defaults = function defaults(options) {
            return orig.defaults(ext(def, options)).Minimatch;
          };
          m.filter = function filter2(pattern, options) {
            return orig.filter(pattern, ext(def, options));
          };
          m.defaults = function defaults(options) {
            return orig.defaults(ext(def, options));
          };
          m.makeRe = function makeRe22(pattern, options) {
            return orig.makeRe(pattern, ext(def, options));
          };
          m.braceExpand = function braceExpand2(pattern, options) {
            return orig.braceExpand(pattern, ext(def, options));
          };
          m.match = function(list, pattern, options) {
            return orig.match(list, pattern, ext(def, options));
          };
          return m;
        };
        Minimatch.defaults = function(def) {
          return minimatch2.defaults(def).Minimatch;
        };
        function minimatch2(p, pattern, options) {
          assertValidPattern(pattern);
          if (!options)
            options = {};
          if (!options.nocomment && pattern.charAt(0) === "#") {
            return false;
          }
          return new Minimatch(pattern, options).match(p);
        }
        function Minimatch(pattern, options) {
          if (!(this instanceof Minimatch)) {
            return new Minimatch(pattern, options);
          }
          assertValidPattern(pattern);
          if (!options)
            options = {};
          pattern = pattern.trim();
          if (!options.allowWindowsEscape && path7.sep !== "/") {
            pattern = pattern.split(path7.sep).join("/");
          }
          this.options = options;
          this.set = [];
          this.pattern = pattern;
          this.regexp = null;
          this.negate = false;
          this.comment = false;
          this.empty = false;
          this.partial = !!options.partial;
          this.make();
        }
        Minimatch.prototype.debug = function() {
        };
        Minimatch.prototype.make = make;
        function make() {
          var pattern = this.pattern;
          var options = this.options;
          if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
          }
          if (!pattern) {
            this.empty = true;
            return;
          }
          this.parseNegate();
          var set = this.globSet = this.braceExpand();
          if (options.debug)
            this.debug = function debug2() {
              console.error.apply(console, arguments);
            };
          this.debug(this.pattern, set);
          set = this.globParts = set.map(function(s) {
            return s.split(slashSplit);
          });
          this.debug(this.pattern, set);
          set = set.map(function(s, si, set2) {
            return s.map(this.parse, this);
          }, this);
          this.debug(this.pattern, set);
          set = set.filter(function(s) {
            return s.indexOf(false) === -1;
          });
          this.debug(this.pattern, set);
          this.set = set;
        }
        Minimatch.prototype.parseNegate = parseNegate;
        function parseNegate() {
          var pattern = this.pattern;
          var negate = false;
          var options = this.options;
          var negateOffset = 0;
          if (options.nonegate)
            return;
          for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
            negate = !negate;
            negateOffset++;
          }
          if (negateOffset)
            this.pattern = pattern.substr(negateOffset);
          this.negate = negate;
        }
        minimatch2.braceExpand = function(pattern, options) {
          return braceExpand(pattern, options);
        };
        Minimatch.prototype.braceExpand = braceExpand;
        function braceExpand(pattern, options) {
          if (!options) {
            if (this instanceof Minimatch) {
              options = this.options;
            } else {
              options = {};
            }
          }
          pattern = typeof pattern === "undefined" ? this.pattern : pattern;
          assertValidPattern(pattern);
          if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
            return [pattern];
          }
          return expand(pattern);
        }
        var MAX_PATTERN_LENGTH = 1024 * 64;
        var assertValidPattern = function(pattern) {
          if (typeof pattern !== "string") {
            throw new TypeError("invalid pattern");
          }
          if (pattern.length > MAX_PATTERN_LENGTH) {
            throw new TypeError("pattern is too long");
          }
        };
        Minimatch.prototype.parse = parse3;
        var SUBPARSE = {};
        function parse3(pattern, isSub) {
          assertValidPattern(pattern);
          var options = this.options;
          if (pattern === "**") {
            if (!options.noglobstar)
              return GLOBSTAR;
            else
              pattern = "*";
          }
          if (pattern === "")
            return "";
          var re = "";
          var hasMagic = !!options.nocase;
          var escaping = false;
          var patternListStack = [];
          var negativeLists = [];
          var stateChar;
          var inClass = false;
          var reClassStart = -1;
          var classStart = -1;
          var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
          var self2 = this;
          function clearStateChar() {
            if (stateChar) {
              switch (stateChar) {
                case "*":
                  re += star;
                  hasMagic = true;
                  break;
                case "?":
                  re += qmark;
                  hasMagic = true;
                  break;
                default:
                  re += "\\" + stateChar;
                  break;
              }
              self2.debug("clearStateChar %j %j", stateChar, re);
              stateChar = false;
            }
          }
          for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
            this.debug("%s	%s %s %j", pattern, i, re, c);
            if (escaping && reSpecials[c]) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            switch (c) {
              case "/": {
                return false;
              }
              case "\\":
                clearStateChar();
                escaping = true;
                continue;
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
                if (inClass) {
                  this.debug("  in class");
                  if (c === "!" && i === classStart + 1)
                    c = "^";
                  re += c;
                  continue;
                }
                self2.debug("call clearStateChar %j", stateChar);
                clearStateChar();
                stateChar = c;
                if (options.noext)
                  clearStateChar();
                continue;
              case "(":
                if (inClass) {
                  re += "(";
                  continue;
                }
                if (!stateChar) {
                  re += "\\(";
                  continue;
                }
                patternListStack.push({
                  type: stateChar,
                  start: i - 1,
                  reStart: re.length,
                  open: plTypes[stateChar].open,
                  close: plTypes[stateChar].close
                });
                re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
                this.debug("plType %j %j", stateChar, re);
                stateChar = false;
                continue;
              case ")":
                if (inClass || !patternListStack.length) {
                  re += "\\)";
                  continue;
                }
                clearStateChar();
                hasMagic = true;
                var pl = patternListStack.pop();
                re += pl.close;
                if (pl.type === "!") {
                  negativeLists.push(pl);
                }
                pl.reEnd = re.length;
                continue;
              case "|":
                if (inClass || !patternListStack.length || escaping) {
                  re += "\\|";
                  escaping = false;
                  continue;
                }
                clearStateChar();
                re += "|";
                continue;
              case "[":
                clearStateChar();
                if (inClass) {
                  re += "\\" + c;
                  continue;
                }
                inClass = true;
                classStart = i;
                reClassStart = re.length;
                re += c;
                continue;
              case "]":
                if (i === classStart + 1 || !inClass) {
                  re += "\\" + c;
                  escaping = false;
                  continue;
                }
                var cs = pattern.substring(classStart + 1, i);
                try {
                  RegExp("[" + cs + "]");
                } catch (er) {
                  var sp = this.parse(cs, SUBPARSE);
                  re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                  hasMagic = hasMagic || sp[1];
                  inClass = false;
                  continue;
                }
                hasMagic = true;
                inClass = false;
                re += c;
                continue;
              default:
                clearStateChar();
                if (escaping) {
                  escaping = false;
                } else if (reSpecials[c] && !(c === "^" && inClass)) {
                  re += "\\";
                }
                re += c;
            }
          }
          if (inClass) {
            cs = pattern.substr(classStart + 1);
            sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0];
            hasMagic = hasMagic || sp[1];
          }
          for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
            var tail = re.slice(pl.reStart + pl.open.length);
            this.debug("setting tail", re, pl);
            tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
              if (!$2) {
                $2 = "\\";
              }
              return $1 + $1 + $2 + "|";
            });
            this.debug("tail=%j\n   %s", tail, tail, pl, re);
            var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
            hasMagic = true;
            re = re.slice(0, pl.reStart) + t + "\\(" + tail;
          }
          clearStateChar();
          if (escaping) {
            re += "\\\\";
          }
          var addPatternStart = false;
          switch (re.charAt(0)) {
            case "[":
            case ".":
            case "(":
              addPatternStart = true;
          }
          for (var n = negativeLists.length - 1; n > -1; n--) {
            var nl = negativeLists[n];
            var nlBefore = re.slice(0, nl.reStart);
            var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
            var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
            var nlAfter = re.slice(nl.reEnd);
            nlLast += nlAfter;
            var openParensBefore = nlBefore.split("(").length - 1;
            var cleanAfter = nlAfter;
            for (i = 0; i < openParensBefore; i++) {
              cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
            }
            nlAfter = cleanAfter;
            var dollar = "";
            if (nlAfter === "" && isSub !== SUBPARSE) {
              dollar = "$";
            }
            var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
            re = newRe;
          }
          if (re !== "" && hasMagic) {
            re = "(?=.)" + re;
          }
          if (addPatternStart) {
            re = patternStart + re;
          }
          if (isSub === SUBPARSE) {
            return [re, hasMagic];
          }
          if (!hasMagic) {
            return globUnescape(pattern);
          }
          var flags = options.nocase ? "i" : "";
          try {
            var regExp = new RegExp("^" + re + "$", flags);
          } catch (er) {
            return new RegExp("$.");
          }
          regExp._glob = pattern;
          regExp._src = re;
          return regExp;
        }
        minimatch2.makeRe = function(pattern, options) {
          return new Minimatch(pattern, options || {}).makeRe();
        };
        Minimatch.prototype.makeRe = makeRe2;
        function makeRe2() {
          if (this.regexp || this.regexp === false)
            return this.regexp;
          var set = this.set;
          if (!set.length) {
            this.regexp = false;
            return this.regexp;
          }
          var options = this.options;
          var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
          var flags = options.nocase ? "i" : "";
          var re = set.map(function(pattern) {
            return pattern.map(function(p) {
              return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
            }).join("\\/");
          }).join("|");
          re = "^(?:" + re + ")$";
          if (this.negate)
            re = "^(?!" + re + ").*$";
          try {
            this.regexp = new RegExp(re, flags);
          } catch (ex) {
            this.regexp = false;
          }
          return this.regexp;
        }
        minimatch2.match = function(list, pattern, options) {
          options = options || {};
          var mm = new Minimatch(pattern, options);
          list = list.filter(function(f) {
            return mm.match(f);
          });
          if (mm.options.nonull && !list.length) {
            list.push(pattern);
          }
          return list;
        };
        Minimatch.prototype.match = function match(f, partial) {
          if (typeof partial === "undefined")
            partial = this.partial;
          this.debug("match", f, this.pattern);
          if (this.comment)
            return false;
          if (this.empty)
            return f === "";
          if (f === "/" && partial)
            return true;
          var options = this.options;
          if (path7.sep !== "/") {
            f = f.split(path7.sep).join("/");
          }
          f = f.split(slashSplit);
          this.debug(this.pattern, "split", f);
          var set = this.set;
          this.debug(this.pattern, "set", set);
          var filename;
          var i;
          for (i = f.length - 1; i >= 0; i--) {
            filename = f[i];
            if (filename)
              break;
          }
          for (i = 0; i < set.length; i++) {
            var pattern = set[i];
            var file = f;
            if (options.matchBase && pattern.length === 1) {
              file = [filename];
            }
            var hit = this.matchOne(file, pattern, partial);
            if (hit) {
              if (options.flipNegate)
                return true;
              return !this.negate;
            }
          }
          if (options.flipNegate)
            return false;
          return this.negate;
        };
        Minimatch.prototype.matchOne = function(file, pattern, partial) {
          var options = this.options;
          this.debug(
            "matchOne",
            { "this": this, file, pattern }
          );
          this.debug("matchOne", file.length, pattern.length);
          for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug("matchOne loop");
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            if (p === false)
              return false;
            if (p === GLOBSTAR) {
              this.debug("GLOBSTAR", [pattern, p, f]);
              var fr = fi;
              var pr = pi + 1;
              if (pr === pl) {
                this.debug("** at the end");
                for (; fi < fl; fi++) {
                  if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                    return false;
                }
                return true;
              }
              while (fr < fl) {
                var swallowee = file[fr];
                this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                  this.debug("globstar found match!", fr, fl, swallowee);
                  return true;
                } else {
                  if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                    this.debug("dot detected!", file, fr, pattern, pr);
                    break;
                  }
                  this.debug("globstar swallow a segment, and continue");
                  fr++;
                }
              }
              if (partial) {
                this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                if (fr === fl)
                  return true;
              }
              return false;
            }
            var hit;
            if (typeof p === "string") {
              hit = f === p;
              this.debug("string match", p, f, hit);
            } else {
              hit = f.match(p);
              this.debug("pattern match", p, f, hit);
            }
            if (!hit)
              return false;
          }
          if (fi === fl && pi === pl) {
            return true;
          } else if (fi === fl) {
            return partial;
          } else if (pi === pl) {
            return fi === fl - 1 && file[fi] === "";
          }
          throw new Error("wtf?");
        };
        function globUnescape(s) {
          return s.replace(/\\(.)/g, "$1");
        }
        function regExpEscape(s) {
          return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        }
      }
    });
    var require_wrappy = __commonJS({
      "../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports2, module2) {
        module2.exports = wrappy;
        function wrappy(fn, cb) {
          if (fn && cb)
            return wrappy(fn)(cb);
          if (typeof fn !== "function")
            throw new TypeError("need wrapper function");
          Object.keys(fn).forEach(function(k) {
            wrapper[k] = fn[k];
          });
          return wrapper;
          function wrapper() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            var ret = fn.apply(this, args);
            var cb2 = args[args.length - 1];
            if (typeof ret === "function" && ret !== cb2) {
              Object.keys(cb2).forEach(function(k) {
                ret[k] = cb2[k];
              });
            }
            return ret;
          }
        }
      }
    });
    var require_once = __commonJS({
      "../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports2, module2) {
        var wrappy = require_wrappy();
        module2.exports = wrappy(once);
        module2.exports.strict = wrappy(onceStrict);
        once.proto = once(function() {
          Object.defineProperty(Function.prototype, "once", {
            value: function() {
              return once(this);
            },
            configurable: true
          });
          Object.defineProperty(Function.prototype, "onceStrict", {
            value: function() {
              return onceStrict(this);
            },
            configurable: true
          });
        });
        function once(fn) {
          var f = function() {
            if (f.called)
              return f.value;
            f.called = true;
            return f.value = fn.apply(this, arguments);
          };
          f.called = false;
          return f;
        }
        function onceStrict(fn) {
          var f = function() {
            if (f.called)
              throw new Error(f.onceError);
            f.called = true;
            return f.value = fn.apply(this, arguments);
          };
          var name = fn.name || "Function wrapped with `once`";
          f.onceError = name + " shouldn't be called more than once";
          f.called = false;
          return f;
        }
      }
    });
    var require_end_of_stream = __commonJS({
      "../../node_modules/.pnpm/end-of-stream@1.4.1/node_modules/end-of-stream/index.js"(exports2, module2) {
        var once = require_once();
        var noop = function() {
        };
        var isRequest = function(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        };
        var isChildProcess = function(stream) {
          return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
        };
        var eos2 = function(stream, opts, callback) {
          if (typeof opts === "function")
            return eos2(stream, null, opts);
          if (!opts)
            opts = {};
          callback = once(callback || noop);
          var ws = stream._writableState;
          var rs = stream._readableState;
          var readable = opts.readable || opts.readable !== false && stream.readable;
          var writable = opts.writable || opts.writable !== false && stream.writable;
          var onlegacyfinish = function() {
            if (!stream.writable)
              onfinish();
          };
          var onfinish = function() {
            writable = false;
            if (!readable)
              callback.call(stream);
          };
          var onend = function() {
            readable = false;
            if (!writable)
              callback.call(stream);
          };
          var onexit = function(exitCode) {
            callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
          };
          var onerror = function(err) {
            callback.call(stream, err);
          };
          var onclose = function() {
            if (readable && !(rs && rs.ended))
              return callback.call(stream, new Error("premature close"));
            if (writable && !(ws && ws.ended))
              return callback.call(stream, new Error("premature close"));
          };
          var onrequest = function() {
            stream.req.on("finish", onfinish);
          };
          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req)
              onrequest();
            else
              stream.on("request", onrequest);
          } else if (writable && !ws) {
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }
          if (isChildProcess(stream))
            stream.on("exit", onexit);
          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false)
            stream.on("error", onerror);
          stream.on("close", onclose);
          return function() {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req)
              stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("exit", onexit);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        };
        module2.exports = eos2;
      }
    });
    var require_old = __commonJS({
      "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js"(exports2) {
        var pathModule = require("path");
        var isWindows = process.platform === "win32";
        var fs6 = require("fs");
        var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
        function rethrow() {
          var callback;
          if (DEBUG) {
            var backtrace = new Error();
            callback = debugCallback;
          } else
            callback = missingCallback;
          return callback;
          function debugCallback(err) {
            if (err) {
              backtrace.message = err.message;
              err = backtrace;
              missingCallback(err);
            }
          }
          function missingCallback(err) {
            if (err) {
              if (process.throwDeprecation)
                throw err;
              else if (!process.noDeprecation) {
                var msg = "fs: missing callback " + (err.stack || err.message);
                if (process.traceDeprecation)
                  console.trace(msg);
                else
                  console.error(msg);
              }
            }
          }
        }
        function maybeCallback(cb) {
          return typeof cb === "function" ? cb : rethrow();
        }
        var normalize = pathModule.normalize;
        if (isWindows) {
          nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
        } else {
          nextPartRe = /(.*?)(?:[\/]+|$)/g;
        }
        var nextPartRe;
        if (isWindows) {
          splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
        } else {
          splitRootRe = /^[\/]*/;
        }
        var splitRootRe;
        exports2.realpathSync = function realpathSync(p, cache) {
          p = pathModule.resolve(p);
          if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
            return cache[p];
          }
          var original = p, seenLinks = {}, knownHard = {};
          var pos;
          var current;
          var base;
          var previous;
          start();
          function start() {
            var m = splitRootRe.exec(p);
            pos = m[0].length;
            current = m[0];
            base = m[0];
            previous = "";
            if (isWindows && !knownHard[base]) {
              fs6.lstatSync(base);
              knownHard[base] = true;
            }
          }
          while (pos < p.length) {
            nextPartRe.lastIndex = pos;
            var result = nextPartRe.exec(p);
            previous = current;
            current += result[0];
            base = previous + result[1];
            pos = nextPartRe.lastIndex;
            if (knownHard[base] || cache && cache[base] === base) {
              continue;
            }
            var resolvedLink;
            if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
              resolvedLink = cache[base];
            } else {
              var stat = fs6.lstatSync(base);
              if (!stat.isSymbolicLink()) {
                knownHard[base] = true;
                if (cache)
                  cache[base] = base;
                continue;
              }
              var linkTarget = null;
              if (!isWindows) {
                var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
                if (seenLinks.hasOwnProperty(id)) {
                  linkTarget = seenLinks[id];
                }
              }
              if (linkTarget === null) {
                fs6.statSync(base);
                linkTarget = fs6.readlinkSync(base);
              }
              resolvedLink = pathModule.resolve(previous, linkTarget);
              if (cache)
                cache[base] = resolvedLink;
              if (!isWindows)
                seenLinks[id] = linkTarget;
            }
            p = pathModule.resolve(resolvedLink, p.slice(pos));
            start();
          }
          if (cache)
            cache[original] = p;
          return p;
        };
        exports2.realpath = function realpath(p, cache, cb) {
          if (typeof cb !== "function") {
            cb = maybeCallback(cache);
            cache = null;
          }
          p = pathModule.resolve(p);
          if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
            return process.nextTick(cb.bind(null, null, cache[p]));
          }
          var original = p, seenLinks = {}, knownHard = {};
          var pos;
          var current;
          var base;
          var previous;
          start();
          function start() {
            var m = splitRootRe.exec(p);
            pos = m[0].length;
            current = m[0];
            base = m[0];
            previous = "";
            if (isWindows && !knownHard[base]) {
              fs6.lstat(base, function(err) {
                if (err)
                  return cb(err);
                knownHard[base] = true;
                LOOP();
              });
            } else {
              process.nextTick(LOOP);
            }
          }
          function LOOP() {
            if (pos >= p.length) {
              if (cache)
                cache[original] = p;
              return cb(null, p);
            }
            nextPartRe.lastIndex = pos;
            var result = nextPartRe.exec(p);
            previous = current;
            current += result[0];
            base = previous + result[1];
            pos = nextPartRe.lastIndex;
            if (knownHard[base] || cache && cache[base] === base) {
              return process.nextTick(LOOP);
            }
            if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
              return gotResolvedLink(cache[base]);
            }
            return fs6.lstat(base, gotStat);
          }
          function gotStat(err, stat) {
            if (err)
              return cb(err);
            if (!stat.isSymbolicLink()) {
              knownHard[base] = true;
              if (cache)
                cache[base] = base;
              return process.nextTick(LOOP);
            }
            if (!isWindows) {
              var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
              if (seenLinks.hasOwnProperty(id)) {
                return gotTarget(null, seenLinks[id], base);
              }
            }
            fs6.stat(base, function(err2) {
              if (err2)
                return cb(err2);
              fs6.readlink(base, function(err3, target) {
                if (!isWindows)
                  seenLinks[id] = target;
                gotTarget(err3, target);
              });
            });
          }
          function gotTarget(err, target, base2) {
            if (err)
              return cb(err);
            var resolvedLink = pathModule.resolve(previous, target);
            if (cache)
              cache[base2] = resolvedLink;
            gotResolvedLink(resolvedLink);
          }
          function gotResolvedLink(resolvedLink) {
            p = pathModule.resolve(resolvedLink, p.slice(pos));
            start();
          }
        };
      }
    });
    var require_fs2 = __commonJS({
      "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js"(exports2, module2) {
        module2.exports = realpath;
        realpath.realpath = realpath;
        realpath.sync = realpathSync;
        realpath.realpathSync = realpathSync;
        realpath.monkeypatch = monkeypatch;
        realpath.unmonkeypatch = unmonkeypatch;
        var fs6 = require("fs");
        var origRealpath = fs6.realpath;
        var origRealpathSync = fs6.realpathSync;
        var version = process.version;
        var ok = /^v[0-5]\./.test(version);
        var old = require_old();
        function newError(er) {
          return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
        }
        function realpath(p, cache, cb) {
          if (ok) {
            return origRealpath(p, cache, cb);
          }
          if (typeof cache === "function") {
            cb = cache;
            cache = null;
          }
          origRealpath(p, cache, function(er, result) {
            if (newError(er)) {
              old.realpath(p, cache, cb);
            } else {
              cb(er, result);
            }
          });
        }
        function realpathSync(p, cache) {
          if (ok) {
            return origRealpathSync(p, cache);
          }
          try {
            return origRealpathSync(p, cache);
          } catch (er) {
            if (newError(er)) {
              return old.realpathSync(p, cache);
            } else {
              throw er;
            }
          }
        }
        function monkeypatch() {
          fs6.realpath = realpath;
          fs6.realpathSync = realpathSync;
        }
        function unmonkeypatch() {
          fs6.realpath = origRealpath;
          fs6.realpathSync = origRealpathSync;
        }
      }
    });
    var require_path = __commonJS({
      "../../node_modules/.pnpm/minimatch@5.0.1/node_modules/minimatch/lib/path.js"(exports2, module2) {
        var isWindows = typeof process === "object" && process && process.platform === "win32";
        module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
      }
    });
    var require_brace_expansion2 = __commonJS({
      "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports2, module2) {
        var balanced = require_balanced_match();
        module2.exports = expandTop;
        var escSlash = "\0SLASH" + Math.random() + "\0";
        var escOpen = "\0OPEN" + Math.random() + "\0";
        var escClose = "\0CLOSE" + Math.random() + "\0";
        var escComma = "\0COMMA" + Math.random() + "\0";
        var escPeriod = "\0PERIOD" + Math.random() + "\0";
        function numeric(str) {
          return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
        }
        function escapeBraces(str) {
          return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
        }
        function unescapeBraces(str) {
          return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
        }
        function parseCommaParts(str) {
          if (!str)
            return [""];
          var parts = [];
          var m = balanced("{", "}", str);
          if (!m)
            return str.split(",");
          var pre = m.pre;
          var body = m.body;
          var post = m.post;
          var p = pre.split(",");
          p[p.length - 1] += "{" + body + "}";
          var postParts = parseCommaParts(post);
          if (post.length) {
            p[p.length - 1] += postParts.shift();
            p.push.apply(p, postParts);
          }
          parts.push.apply(parts, p);
          return parts;
        }
        function expandTop(str) {
          if (!str)
            return [];
          if (str.substr(0, 2) === "{}") {
            str = "\\{\\}" + str.substr(2);
          }
          return expand(escapeBraces(str), true).map(unescapeBraces);
        }
        function embrace(str) {
          return "{" + str + "}";
        }
        function isPadded(el) {
          return /^-?0\d/.test(el);
        }
        function lte(i, y) {
          return i <= y;
        }
        function gte2(i, y) {
          return i >= y;
        }
        function expand(str, isTop) {
          var expansions = [];
          var m = balanced("{", "}", str);
          if (!m)
            return [str];
          var pre = m.pre;
          var post = m.post.length ? expand(m.post, false) : [""];
          if (/\$$/.test(m.pre)) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + "{" + m.body + "}" + post[k];
              expansions.push(expansion);
            }
          } else {
            var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
            var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
            var isSequence = isNumericSequence || isAlphaSequence;
            var isOptions = m.body.indexOf(",") >= 0;
            if (!isSequence && !isOptions) {
              if (m.post.match(/,.*\}/)) {
                str = m.pre + "{" + m.body + escClose + m.post;
                return expand(str);
              }
              return [str];
            }
            var n;
            if (isSequence) {
              n = m.body.split(/\.\./);
            } else {
              n = parseCommaParts(m.body);
              if (n.length === 1) {
                n = expand(n[0], false).map(embrace);
                if (n.length === 1) {
                  return post.map(function(p) {
                    return m.pre + n[0] + p;
                  });
                }
              }
            }
            var N;
            if (isSequence) {
              var x = numeric(n[0]);
              var y = numeric(n[1]);
              var width = Math.max(n[0].length, n[1].length);
              var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
              var test = lte;
              var reverse = y < x;
              if (reverse) {
                incr *= -1;
                test = gte2;
              }
              var pad = n.some(isPadded);
              N = [];
              for (var i = x; test(i, y); i += incr) {
                var c;
                if (isAlphaSequence) {
                  c = String.fromCharCode(i);
                  if (c === "\\")
                    c = "";
                } else {
                  c = String(i);
                  if (pad) {
                    var need = width - c.length;
                    if (need > 0) {
                      var z = new Array(need + 1).join("0");
                      if (i < 0)
                        c = "-" + z + c.slice(1);
                      else
                        c = z + c;
                    }
                  }
                }
                N.push(c);
              }
            } else {
              N = [];
              for (var j = 0; j < n.length; j++) {
                N.push.apply(N, expand(n[j], false));
              }
            }
            for (var j = 0; j < N.length; j++) {
              for (var k = 0; k < post.length; k++) {
                var expansion = pre + N[j] + post[k];
                if (!isTop || isSequence || expansion)
                  expansions.push(expansion);
              }
            }
          }
          return expansions;
        }
      }
    });
    var require_minimatch2 = __commonJS({
      "../../node_modules/.pnpm/minimatch@5.0.1/node_modules/minimatch/minimatch.js"(exports2, module2) {
        var minimatch2 = module2.exports = (p, pattern, options = {}) => {
          assertValidPattern(pattern);
          if (!options.nocomment && pattern.charAt(0) === "#") {
            return false;
          }
          return new Minimatch(pattern, options).match(p);
        };
        module2.exports = minimatch2;
        var path7 = require_path();
        minimatch2.sep = path7.sep;
        var GLOBSTAR = Symbol("globstar **");
        minimatch2.GLOBSTAR = GLOBSTAR;
        var expand = require_brace_expansion2();
        var plTypes = {
          "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
          "?": { open: "(?:", close: ")?" },
          "+": { open: "(?:", close: ")+" },
          "*": { open: "(?:", close: ")*" },
          "@": { open: "(?:", close: ")" }
        };
        var qmark = "[^/]";
        var star = qmark + "*?";
        var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
        var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
        var charSet = (s) => s.split("").reduce((set, c) => {
          set[c] = true;
          return set;
        }, {});
        var reSpecials = charSet("().*{}+?[]^$\\!");
        var addPatternStartSet = charSet("[.(");
        var slashSplit = /\/+/;
        minimatch2.filter = (pattern, options = {}) => (p, i, list) => minimatch2(p, pattern, options);
        var ext = (a, b = {}) => {
          const t = {};
          Object.keys(a).forEach((k) => t[k] = a[k]);
          Object.keys(b).forEach((k) => t[k] = b[k]);
          return t;
        };
        minimatch2.defaults = (def) => {
          if (!def || typeof def !== "object" || !Object.keys(def).length) {
            return minimatch2;
          }
          const orig = minimatch2;
          const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
          m.Minimatch = class Minimatch extends orig.Minimatch {
            constructor(pattern, options) {
              super(pattern, ext(def, options));
            }
          };
          m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
          m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
          m.defaults = (options) => orig.defaults(ext(def, options));
          m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
          m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
          m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
          return m;
        };
        minimatch2.braceExpand = (pattern, options) => braceExpand(pattern, options);
        var braceExpand = (pattern, options = {}) => {
          assertValidPattern(pattern);
          if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
            return [pattern];
          }
          return expand(pattern);
        };
        var MAX_PATTERN_LENGTH = 1024 * 64;
        var assertValidPattern = (pattern) => {
          if (typeof pattern !== "string") {
            throw new TypeError("invalid pattern");
          }
          if (pattern.length > MAX_PATTERN_LENGTH) {
            throw new TypeError("pattern is too long");
          }
        };
        var SUBPARSE = Symbol("subparse");
        minimatch2.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
        minimatch2.match = (list, pattern, options = {}) => {
          const mm = new Minimatch(pattern, options);
          list = list.filter((f) => mm.match(f));
          if (mm.options.nonull && !list.length) {
            list.push(pattern);
          }
          return list;
        };
        var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
        var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
        var Minimatch = class {
          constructor(pattern, options) {
            assertValidPattern(pattern);
            if (!options)
              options = {};
            this.options = options;
            this.set = [];
            this.pattern = pattern;
            this.regexp = null;
            this.negate = false;
            this.comment = false;
            this.empty = false;
            this.partial = !!options.partial;
            this.make();
          }
          debug() {
          }
          make() {
            const pattern = this.pattern;
            const options = this.options;
            if (!options.nocomment && pattern.charAt(0) === "#") {
              this.comment = true;
              return;
            }
            if (!pattern) {
              this.empty = true;
              return;
            }
            this.parseNegate();
            let set = this.globSet = this.braceExpand();
            if (options.debug)
              this.debug = (...args) => console.error(...args);
            this.debug(this.pattern, set);
            set = this.globParts = set.map((s) => s.split(slashSplit));
            this.debug(this.pattern, set);
            set = set.map((s, si, set2) => s.map(this.parse, this));
            this.debug(this.pattern, set);
            set = set.filter((s) => s.indexOf(false) === -1);
            this.debug(this.pattern, set);
            this.set = set;
          }
          parseNegate() {
            if (this.options.nonegate)
              return;
            const pattern = this.pattern;
            let negate = false;
            let negateOffset = 0;
            for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
              negate = !negate;
              negateOffset++;
            }
            if (negateOffset)
              this.pattern = pattern.substr(negateOffset);
            this.negate = negate;
          }
          // set partial to true to test if, for example,
          // "/a/b" matches the start of "/*/b/*/d"
          // Partial means, if you run out of file before you run
          // out of pattern, then that's fine, as long as all
          // the parts match.
          matchOne(file, pattern, partial) {
            var options = this.options;
            this.debug(
              "matchOne",
              { "this": this, file, pattern }
            );
            this.debug("matchOne", file.length, pattern.length);
            for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
              this.debug("matchOne loop");
              var p = pattern[pi];
              var f = file[fi];
              this.debug(pattern, p, f);
              if (p === false)
                return false;
              if (p === GLOBSTAR) {
                this.debug("GLOBSTAR", [pattern, p, f]);
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                  this.debug("** at the end");
                  for (; fi < fl; fi++) {
                    if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                      return false;
                  }
                  return true;
                }
                while (fr < fl) {
                  var swallowee = file[fr];
                  this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                  if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                    this.debug("globstar found match!", fr, fl, swallowee);
                    return true;
                  } else {
                    if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                      this.debug("dot detected!", file, fr, pattern, pr);
                      break;
                    }
                    this.debug("globstar swallow a segment, and continue");
                    fr++;
                  }
                }
                if (partial) {
                  this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                  if (fr === fl)
                    return true;
                }
                return false;
              }
              var hit;
              if (typeof p === "string") {
                hit = f === p;
                this.debug("string match", p, f, hit);
              } else {
                hit = f.match(p);
                this.debug("pattern match", p, f, hit);
              }
              if (!hit)
                return false;
            }
            if (fi === fl && pi === pl) {
              return true;
            } else if (fi === fl) {
              return partial;
            } else if (pi === pl) {
              return fi === fl - 1 && file[fi] === "";
            }
            throw new Error("wtf?");
          }
          braceExpand() {
            return braceExpand(this.pattern, this.options);
          }
          parse(pattern, isSub) {
            assertValidPattern(pattern);
            const options = this.options;
            if (pattern === "**") {
              if (!options.noglobstar)
                return GLOBSTAR;
              else
                pattern = "*";
            }
            if (pattern === "")
              return "";
            let re = "";
            let hasMagic = !!options.nocase;
            let escaping = false;
            const patternListStack = [];
            const negativeLists = [];
            let stateChar;
            let inClass = false;
            let reClassStart = -1;
            let classStart = -1;
            let cs;
            let pl;
            let sp;
            const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
            const clearStateChar = () => {
              if (stateChar) {
                switch (stateChar) {
                  case "*":
                    re += star;
                    hasMagic = true;
                    break;
                  case "?":
                    re += qmark;
                    hasMagic = true;
                    break;
                  default:
                    re += "\\" + stateChar;
                    break;
                }
                this.debug("clearStateChar %j %j", stateChar, re);
                stateChar = false;
              }
            };
            for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
              this.debug("%s	%s %s %j", pattern, i, re, c);
              if (escaping) {
                if (c === "/") {
                  return false;
                }
                if (reSpecials[c]) {
                  re += "\\";
                }
                re += c;
                escaping = false;
                continue;
              }
              switch (c) {
                case "/": {
                  return false;
                }
                case "\\":
                  clearStateChar();
                  escaping = true;
                  continue;
                case "?":
                case "*":
                case "+":
                case "@":
                case "!":
                  this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
                  if (inClass) {
                    this.debug("  in class");
                    if (c === "!" && i === classStart + 1)
                      c = "^";
                    re += c;
                    continue;
                  }
                  this.debug("call clearStateChar %j", stateChar);
                  clearStateChar();
                  stateChar = c;
                  if (options.noext)
                    clearStateChar();
                  continue;
                case "(":
                  if (inClass) {
                    re += "(";
                    continue;
                  }
                  if (!stateChar) {
                    re += "\\(";
                    continue;
                  }
                  patternListStack.push({
                    type: stateChar,
                    start: i - 1,
                    reStart: re.length,
                    open: plTypes[stateChar].open,
                    close: plTypes[stateChar].close
                  });
                  re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
                  this.debug("plType %j %j", stateChar, re);
                  stateChar = false;
                  continue;
                case ")":
                  if (inClass || !patternListStack.length) {
                    re += "\\)";
                    continue;
                  }
                  clearStateChar();
                  hasMagic = true;
                  pl = patternListStack.pop();
                  re += pl.close;
                  if (pl.type === "!") {
                    negativeLists.push(pl);
                  }
                  pl.reEnd = re.length;
                  continue;
                case "|":
                  if (inClass || !patternListStack.length) {
                    re += "\\|";
                    continue;
                  }
                  clearStateChar();
                  re += "|";
                  continue;
                case "[":
                  clearStateChar();
                  if (inClass) {
                    re += "\\" + c;
                    continue;
                  }
                  inClass = true;
                  classStart = i;
                  reClassStart = re.length;
                  re += c;
                  continue;
                case "]":
                  if (i === classStart + 1 || !inClass) {
                    re += "\\" + c;
                    continue;
                  }
                  cs = pattern.substring(classStart + 1, i);
                  try {
                    RegExp("[" + cs + "]");
                  } catch (er) {
                    sp = this.parse(cs, SUBPARSE);
                    re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                    hasMagic = hasMagic || sp[1];
                    inClass = false;
                    continue;
                  }
                  hasMagic = true;
                  inClass = false;
                  re += c;
                  continue;
                default:
                  clearStateChar();
                  if (reSpecials[c] && !(c === "^" && inClass)) {
                    re += "\\";
                  }
                  re += c;
                  break;
              }
            }
            if (inClass) {
              cs = pattern.substr(classStart + 1);
              sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0];
              hasMagic = hasMagic || sp[1];
            }
            for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
              let tail;
              tail = re.slice(pl.reStart + pl.open.length);
              this.debug("setting tail", re, pl);
              tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
                if (!$2) {
                  $2 = "\\";
                }
                return $1 + $1 + $2 + "|";
              });
              this.debug("tail=%j\n   %s", tail, tail, pl, re);
              const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
              hasMagic = true;
              re = re.slice(0, pl.reStart) + t + "\\(" + tail;
            }
            clearStateChar();
            if (escaping) {
              re += "\\\\";
            }
            const addPatternStart = addPatternStartSet[re.charAt(0)];
            for (let n = negativeLists.length - 1; n > -1; n--) {
              const nl = negativeLists[n];
              const nlBefore = re.slice(0, nl.reStart);
              const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
              let nlAfter = re.slice(nl.reEnd);
              const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
              const openParensBefore = nlBefore.split("(").length - 1;
              let cleanAfter = nlAfter;
              for (let i = 0; i < openParensBefore; i++) {
                cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
              }
              nlAfter = cleanAfter;
              const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
              re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
            }
            if (re !== "" && hasMagic) {
              re = "(?=.)" + re;
            }
            if (addPatternStart) {
              re = patternStart + re;
            }
            if (isSub === SUBPARSE) {
              return [re, hasMagic];
            }
            if (!hasMagic) {
              return globUnescape(pattern);
            }
            const flags = options.nocase ? "i" : "";
            try {
              return Object.assign(new RegExp("^" + re + "$", flags), {
                _glob: pattern,
                _src: re
              });
            } catch (er) {
              return new RegExp("$.");
            }
          }
          makeRe() {
            if (this.regexp || this.regexp === false)
              return this.regexp;
            const set = this.set;
            if (!set.length) {
              this.regexp = false;
              return this.regexp;
            }
            const options = this.options;
            const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
            const flags = options.nocase ? "i" : "";
            let re = set.map((pattern) => {
              pattern = pattern.map(
                (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
              ).reduce((set2, p) => {
                if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
                  set2.push(p);
                }
                return set2;
              }, []);
              pattern.forEach((p, i) => {
                if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
                  return;
                }
                if (i === 0) {
                  if (pattern.length > 1) {
                    pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
                  } else {
                    pattern[i] = twoStar;
                  }
                } else if (i === pattern.length - 1) {
                  pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
                } else {
                  pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
                  pattern[i + 1] = GLOBSTAR;
                }
              });
              return pattern.filter((p) => p !== GLOBSTAR).join("/");
            }).join("|");
            re = "^(?:" + re + ")$";
            if (this.negate)
              re = "^(?!" + re + ").*$";
            try {
              this.regexp = new RegExp(re, flags);
            } catch (ex) {
              this.regexp = false;
            }
            return this.regexp;
          }
          match(f, partial = this.partial) {
            this.debug("match", f, this.pattern);
            if (this.comment)
              return false;
            if (this.empty)
              return f === "";
            if (f === "/" && partial)
              return true;
            const options = this.options;
            if (path7.sep !== "/") {
              f = f.split(path7.sep).join("/");
            }
            f = f.split(slashSplit);
            this.debug(this.pattern, "split", f);
            const set = this.set;
            this.debug(this.pattern, "set", set);
            let filename;
            for (let i = f.length - 1; i >= 0; i--) {
              filename = f[i];
              if (filename)
                break;
            }
            for (let i = 0; i < set.length; i++) {
              const pattern = set[i];
              let file = f;
              if (options.matchBase && pattern.length === 1) {
                file = [filename];
              }
              const hit = this.matchOne(file, pattern, partial);
              if (hit) {
                if (options.flipNegate)
                  return true;
                return !this.negate;
              }
            }
            if (options.flipNegate)
              return false;
            return this.negate;
          }
          static defaults(def) {
            return minimatch2.defaults(def).Minimatch;
          }
        };
        minimatch2.Minimatch = Minimatch;
      }
    });
    var require_common = __commonJS({
      "../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/common.js"(exports2) {
        exports2.setopts = setopts;
        exports2.ownProp = ownProp;
        exports2.makeAbs = makeAbs;
        exports2.finish = finish;
        exports2.mark = mark;
        exports2.isIgnored = isIgnored;
        exports2.childrenIgnored = childrenIgnored;
        function ownProp(obj, field) {
          return Object.prototype.hasOwnProperty.call(obj, field);
        }
        var fs6 = require("fs");
        var path7 = require("path");
        var minimatch2 = require_minimatch2();
        var isAbsolute = require("path").isAbsolute;
        var Minimatch = minimatch2.Minimatch;
        function alphasort(a, b) {
          return a.localeCompare(b, "en");
        }
        function setupIgnores(self2, options) {
          self2.ignore = options.ignore || [];
          if (!Array.isArray(self2.ignore))
            self2.ignore = [self2.ignore];
          if (self2.ignore.length) {
            self2.ignore = self2.ignore.map(ignoreMap);
          }
        }
        function ignoreMap(pattern) {
          var gmatcher = null;
          if (pattern.slice(-3) === "/**") {
            var gpattern = pattern.replace(/(\/\*\*)+$/, "");
            gmatcher = new Minimatch(gpattern, { dot: true });
          }
          return {
            matcher: new Minimatch(pattern, { dot: true }),
            gmatcher
          };
        }
        function setopts(self2, pattern, options) {
          if (!options)
            options = {};
          if (options.matchBase && -1 === pattern.indexOf("/")) {
            if (options.noglobstar) {
              throw new Error("base matching requires globstar");
            }
            pattern = "**/" + pattern;
          }
          self2.silent = !!options.silent;
          self2.pattern = pattern;
          self2.strict = options.strict !== false;
          self2.realpath = !!options.realpath;
          self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
          self2.follow = !!options.follow;
          self2.dot = !!options.dot;
          self2.mark = !!options.mark;
          self2.nodir = !!options.nodir;
          if (self2.nodir)
            self2.mark = true;
          self2.sync = !!options.sync;
          self2.nounique = !!options.nounique;
          self2.nonull = !!options.nonull;
          self2.nosort = !!options.nosort;
          self2.nocase = !!options.nocase;
          self2.stat = !!options.stat;
          self2.noprocess = !!options.noprocess;
          self2.absolute = !!options.absolute;
          self2.fs = options.fs || fs6;
          self2.maxLength = options.maxLength || Infinity;
          self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
          self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
          self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
          setupIgnores(self2, options);
          self2.changedCwd = false;
          var cwd = process.cwd();
          if (!ownProp(options, "cwd"))
            self2.cwd = path7.resolve(cwd);
          else {
            self2.cwd = path7.resolve(options.cwd);
            self2.changedCwd = self2.cwd !== cwd;
          }
          self2.root = options.root || path7.resolve(self2.cwd, "/");
          self2.root = path7.resolve(self2.root);
          self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
          self2.nomount = !!options.nomount;
          if (process.platform === "win32") {
            self2.root = self2.root.replace(/\\/g, "/");
            self2.cwd = self2.cwd.replace(/\\/g, "/");
            self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
          }
          options.nonegate = true;
          options.nocomment = true;
          options.allowWindowsEscape = true;
          self2.minimatch = new Minimatch(pattern, options);
          self2.options = self2.minimatch.options;
        }
        function finish(self2) {
          var nou = self2.nounique;
          var all = nou ? [] : /* @__PURE__ */ Object.create(null);
          for (var i = 0, l = self2.matches.length; i < l; i++) {
            var matches = self2.matches[i];
            if (!matches || Object.keys(matches).length === 0) {
              if (self2.nonull) {
                var literal = self2.minimatch.globSet[i];
                if (nou)
                  all.push(literal);
                else
                  all[literal] = true;
              }
            } else {
              var m = Object.keys(matches);
              if (nou)
                all.push.apply(all, m);
              else
                m.forEach(function(m2) {
                  all[m2] = true;
                });
            }
          }
          if (!nou)
            all = Object.keys(all);
          if (!self2.nosort)
            all = all.sort(alphasort);
          if (self2.mark) {
            for (var i = 0; i < all.length; i++) {
              all[i] = self2._mark(all[i]);
            }
            if (self2.nodir) {
              all = all.filter(function(e) {
                var notDir = !/\/$/.test(e);
                var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
                if (notDir && c)
                  notDir = c !== "DIR" && !Array.isArray(c);
                return notDir;
              });
            }
          }
          if (self2.ignore.length)
            all = all.filter(function(m2) {
              return !isIgnored(self2, m2);
            });
          self2.found = all;
        }
        function mark(self2, p) {
          var abs = makeAbs(self2, p);
          var c = self2.cache[abs];
          var m = p;
          if (c) {
            var isDir = c === "DIR" || Array.isArray(c);
            var slash = p.slice(-1) === "/";
            if (isDir && !slash)
              m += "/";
            else if (!isDir && slash)
              m = m.slice(0, -1);
            if (m !== p) {
              var mabs = makeAbs(self2, m);
              self2.statCache[mabs] = self2.statCache[abs];
              self2.cache[mabs] = self2.cache[abs];
            }
          }
          return m;
        }
        function makeAbs(self2, f) {
          var abs = f;
          if (f.charAt(0) === "/") {
            abs = path7.join(self2.root, f);
          } else if (isAbsolute(f) || f === "") {
            abs = f;
          } else if (self2.changedCwd) {
            abs = path7.resolve(self2.cwd, f);
          } else {
            abs = path7.resolve(f);
          }
          if (process.platform === "win32")
            abs = abs.replace(/\\/g, "/");
          return abs;
        }
        function isIgnored(self2, path8) {
          if (!self2.ignore.length)
            return false;
          return self2.ignore.some(function(item) {
            return item.matcher.match(path8) || !!(item.gmatcher && item.gmatcher.match(path8));
          });
        }
        function childrenIgnored(self2, path8) {
          if (!self2.ignore.length)
            return false;
          return self2.ignore.some(function(item) {
            return !!(item.gmatcher && item.gmatcher.match(path8));
          });
        }
      }
    });
    var require_sync = __commonJS({
      "../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/sync.js"(exports2, module2) {
        module2.exports = globSync;
        globSync.GlobSync = GlobSync;
        var rp = require_fs2();
        var minimatch2 = require_minimatch2();
        var Minimatch = minimatch2.Minimatch;
        var Glob = require_glob().Glob;
        var util = require("util");
        var path7 = require("path");
        var assert7 = require("assert");
        var isAbsolute = require("path").isAbsolute;
        var common = require_common();
        var setopts = common.setopts;
        var ownProp = common.ownProp;
        var childrenIgnored = common.childrenIgnored;
        var isIgnored = common.isIgnored;
        function globSync(pattern, options) {
          if (typeof options === "function" || arguments.length === 3)
            throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
          return new GlobSync(pattern, options).found;
        }
        function GlobSync(pattern, options) {
          if (!pattern)
            throw new Error("must provide pattern");
          if (typeof options === "function" || arguments.length === 3)
            throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
          if (!(this instanceof GlobSync))
            return new GlobSync(pattern, options);
          setopts(this, pattern, options);
          if (this.noprocess)
            return this;
          var n = this.minimatch.set.length;
          this.matches = new Array(n);
          for (var i = 0; i < n; i++) {
            this._process(this.minimatch.set[i], i, false);
          }
          this._finish();
        }
        GlobSync.prototype._finish = function() {
          assert7.ok(this instanceof GlobSync);
          if (this.realpath) {
            var self2 = this;
            this.matches.forEach(function(matchset, index) {
              var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
              for (var p in matchset) {
                try {
                  p = self2._makeAbs(p);
                  var real = rp.realpathSync(p, self2.realpathCache);
                  set[real] = true;
                } catch (er) {
                  if (er.syscall === "stat")
                    set[self2._makeAbs(p)] = true;
                  else
                    throw er;
                }
              }
            });
          }
          common.finish(this);
        };
        GlobSync.prototype._process = function(pattern, index, inGlobStar) {
          assert7.ok(this instanceof GlobSync);
          var n = 0;
          while (typeof pattern[n] === "string") {
            n++;
          }
          var prefix;
          switch (n) {
            case pattern.length:
              this._processSimple(pattern.join("/"), index);
              return;
            case 0:
              prefix = null;
              break;
            default:
              prefix = pattern.slice(0, n).join("/");
              break;
          }
          var remain = pattern.slice(n);
          var read;
          if (prefix === null)
            read = ".";
          else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
            return typeof p === "string" ? p : "[*]";
          }).join("/"))) {
            if (!prefix || !isAbsolute(prefix))
              prefix = "/" + prefix;
            read = prefix;
          } else
            read = prefix;
          var abs = this._makeAbs(read);
          if (childrenIgnored(this, read))
            return;
          var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
          if (isGlobStar)
            this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
          else
            this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
        };
        GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
          var entries = this._readdir(abs, inGlobStar);
          if (!entries)
            return;
          var pn = remain[0];
          var negate = !!this.minimatch.negate;
          var rawGlob = pn._glob;
          var dotOk = this.dot || rawGlob.charAt(0) === ".";
          var matchedEntries = [];
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (e.charAt(0) !== "." || dotOk) {
              var m;
              if (negate && !prefix) {
                m = !e.match(pn);
              } else {
                m = e.match(pn);
              }
              if (m)
                matchedEntries.push(e);
            }
          }
          var len = matchedEntries.length;
          if (len === 0)
            return;
          if (remain.length === 1 && !this.mark && !this.stat) {
            if (!this.matches[index])
              this.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var i = 0; i < len; i++) {
              var e = matchedEntries[i];
              if (prefix) {
                if (prefix.slice(-1) !== "/")
                  e = prefix + "/" + e;
                else
                  e = prefix + e;
              }
              if (e.charAt(0) === "/" && !this.nomount) {
                e = path7.join(this.root, e);
              }
              this._emitMatch(index, e);
            }
            return;
          }
          remain.shift();
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            var newPattern;
            if (prefix)
              newPattern = [prefix, e];
            else
              newPattern = [e];
            this._process(newPattern.concat(remain), index, inGlobStar);
          }
        };
        GlobSync.prototype._emitMatch = function(index, e) {
          if (isIgnored(this, e))
            return;
          var abs = this._makeAbs(e);
          if (this.mark)
            e = this._mark(e);
          if (this.absolute) {
            e = abs;
          }
          if (this.matches[index][e])
            return;
          if (this.nodir) {
            var c = this.cache[abs];
            if (c === "DIR" || Array.isArray(c))
              return;
          }
          this.matches[index][e] = true;
          if (this.stat)
            this._stat(e);
        };
        GlobSync.prototype._readdirInGlobStar = function(abs) {
          if (this.follow)
            return this._readdir(abs, false);
          var entries;
          var lstat2;
          var stat;
          try {
            lstat2 = this.fs.lstatSync(abs);
          } catch (er) {
            if (er.code === "ENOENT") {
              return null;
            }
          }
          var isSym = lstat2 && lstat2.isSymbolicLink();
          this.symlinks[abs] = isSym;
          if (!isSym && lstat2 && !lstat2.isDirectory())
            this.cache[abs] = "FILE";
          else
            entries = this._readdir(abs, false);
          return entries;
        };
        GlobSync.prototype._readdir = function(abs, inGlobStar) {
          var entries;
          if (inGlobStar && !ownProp(this.symlinks, abs))
            return this._readdirInGlobStar(abs);
          if (ownProp(this.cache, abs)) {
            var c = this.cache[abs];
            if (!c || c === "FILE")
              return null;
            if (Array.isArray(c))
              return c;
          }
          try {
            return this._readdirEntries(abs, this.fs.readdirSync(abs));
          } catch (er) {
            this._readdirError(abs, er);
            return null;
          }
        };
        GlobSync.prototype._readdirEntries = function(abs, entries) {
          if (!this.mark && !this.stat) {
            for (var i = 0; i < entries.length; i++) {
              var e = entries[i];
              if (abs === "/")
                e = abs + e;
              else
                e = abs + "/" + e;
              this.cache[e] = true;
            }
          }
          this.cache[abs] = entries;
          return entries;
        };
        GlobSync.prototype._readdirError = function(f, er) {
          switch (er.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var abs = this._makeAbs(f);
              this.cache[abs] = "FILE";
              if (abs === this.cwdAbs) {
                var error = new Error(er.code + " invalid cwd " + this.cwd);
                error.path = this.cwd;
                error.code = er.code;
                throw error;
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(f)] = false;
              break;
            default:
              this.cache[this._makeAbs(f)] = false;
              if (this.strict)
                throw er;
              if (!this.silent)
                console.error("glob error", er);
              break;
          }
        };
        GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
          var entries = this._readdir(abs, inGlobStar);
          if (!entries)
            return;
          var remainWithoutGlobStar = remain.slice(1);
          var gspref = prefix ? [prefix] : [];
          var noGlobStar = gspref.concat(remainWithoutGlobStar);
          this._process(noGlobStar, index, false);
          var len = entries.length;
          var isSym = this.symlinks[abs];
          if (isSym && inGlobStar)
            return;
          for (var i = 0; i < len; i++) {
            var e = entries[i];
            if (e.charAt(0) === "." && !this.dot)
              continue;
            var instead = gspref.concat(entries[i], remainWithoutGlobStar);
            this._process(instead, index, true);
            var below = gspref.concat(entries[i], remain);
            this._process(below, index, true);
          }
        };
        GlobSync.prototype._processSimple = function(prefix, index) {
          var exists = this._stat(prefix);
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          if (!exists)
            return;
          if (prefix && isAbsolute(prefix) && !this.nomount) {
            var trail = /[\/\\]$/.test(prefix);
            if (prefix.charAt(0) === "/") {
              prefix = path7.join(this.root, prefix);
            } else {
              prefix = path7.resolve(this.root, prefix);
              if (trail)
                prefix += "/";
            }
          }
          if (process.platform === "win32")
            prefix = prefix.replace(/\\/g, "/");
          this._emitMatch(index, prefix);
        };
        GlobSync.prototype._stat = function(f) {
          var abs = this._makeAbs(f);
          var needDir = f.slice(-1) === "/";
          if (f.length > this.maxLength)
            return false;
          if (!this.stat && ownProp(this.cache, abs)) {
            var c = this.cache[abs];
            if (Array.isArray(c))
              c = "DIR";
            if (!needDir || c === "DIR")
              return c;
            if (needDir && c === "FILE")
              return false;
          }
          var exists;
          var stat = this.statCache[abs];
          if (!stat) {
            var lstat2;
            try {
              lstat2 = this.fs.lstatSync(abs);
            } catch (er) {
              if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
                this.statCache[abs] = false;
                return false;
              }
            }
            if (lstat2 && lstat2.isSymbolicLink()) {
              try {
                stat = this.fs.statSync(abs);
              } catch (er) {
                stat = lstat2;
              }
            } else {
              stat = lstat2;
            }
          }
          this.statCache[abs] = stat;
          var c = true;
          if (stat)
            c = stat.isDirectory() ? "DIR" : "FILE";
          this.cache[abs] = this.cache[abs] || c;
          if (needDir && c === "FILE")
            return false;
          return c;
        };
        GlobSync.prototype._mark = function(p) {
          return common.mark(this, p);
        };
        GlobSync.prototype._makeAbs = function(f) {
          return common.makeAbs(this, f);
        };
      }
    });
    var require_inflight = __commonJS({
      "../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js"(exports2, module2) {
        var wrappy = require_wrappy();
        var reqs = /* @__PURE__ */ Object.create(null);
        var once = require_once();
        module2.exports = wrappy(inflight);
        function inflight(key, cb) {
          if (reqs[key]) {
            reqs[key].push(cb);
            return null;
          } else {
            reqs[key] = [cb];
            return makeres(key);
          }
        }
        function makeres(key) {
          return once(function RES() {
            var cbs = reqs[key];
            var len = cbs.length;
            var args = slice(arguments);
            try {
              for (var i = 0; i < len; i++) {
                cbs[i].apply(null, args);
              }
            } finally {
              if (cbs.length > len) {
                cbs.splice(0, len);
                process.nextTick(function() {
                  RES.apply(null, args);
                });
              } else {
                delete reqs[key];
              }
            }
          });
        }
        function slice(args) {
          var length = args.length;
          var array = [];
          for (var i = 0; i < length; i++)
            array[i] = args[i];
          return array;
        }
      }
    });
    var require_glob = __commonJS({
      "../../node_modules/.pnpm/glob@8.0.3/node_modules/glob/glob.js"(exports2, module2) {
        module2.exports = glob2;
        var rp = require_fs2();
        var minimatch2 = require_minimatch2();
        var Minimatch = minimatch2.Minimatch;
        var inherits = require_inherits();
        var EE = require("events").EventEmitter;
        var path7 = require("path");
        var assert7 = require("assert");
        var isAbsolute = require("path").isAbsolute;
        var globSync = require_sync();
        var common = require_common();
        var setopts = common.setopts;
        var ownProp = common.ownProp;
        var inflight = require_inflight();
        var util = require("util");
        var childrenIgnored = common.childrenIgnored;
        var isIgnored = common.isIgnored;
        var once = require_once();
        function glob2(pattern, options, cb) {
          if (typeof options === "function")
            cb = options, options = {};
          if (!options)
            options = {};
          if (options.sync) {
            if (cb)
              throw new TypeError("callback provided to sync glob");
            return globSync(pattern, options);
          }
          return new Glob(pattern, options, cb);
        }
        glob2.sync = globSync;
        var GlobSync = glob2.GlobSync = globSync.GlobSync;
        glob2.glob = glob2;
        function extend(origin, add) {
          if (add === null || typeof add !== "object") {
            return origin;
          }
          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        }
        glob2.hasMagic = function(pattern, options_) {
          var options = extend({}, options_);
          options.noprocess = true;
          var g = new Glob(pattern, options);
          var set = g.minimatch.set;
          if (!pattern)
            return false;
          if (set.length > 1)
            return true;
          for (var j = 0; j < set[0].length; j++) {
            if (typeof set[0][j] !== "string")
              return true;
          }
          return false;
        };
        glob2.Glob = Glob;
        inherits(Glob, EE);
        function Glob(pattern, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          if (options && options.sync) {
            if (cb)
              throw new TypeError("callback provided to sync glob");
            return new GlobSync(pattern, options);
          }
          if (!(this instanceof Glob))
            return new Glob(pattern, options, cb);
          setopts(this, pattern, options);
          this._didRealPath = false;
          var n = this.minimatch.set.length;
          this.matches = new Array(n);
          if (typeof cb === "function") {
            cb = once(cb);
            this.on("error", cb);
            this.on("end", function(matches) {
              cb(null, matches);
            });
          }
          var self2 = this;
          this._processing = 0;
          this._emitQueue = [];
          this._processQueue = [];
          this.paused = false;
          if (this.noprocess)
            return this;
          if (n === 0)
            return done();
          var sync = true;
          for (var i = 0; i < n; i++) {
            this._process(this.minimatch.set[i], i, false, done);
          }
          sync = false;
          function done() {
            --self2._processing;
            if (self2._processing <= 0) {
              if (sync) {
                process.nextTick(function() {
                  self2._finish();
                });
              } else {
                self2._finish();
              }
            }
          }
        }
        Glob.prototype._finish = function() {
          assert7(this instanceof Glob);
          if (this.aborted)
            return;
          if (this.realpath && !this._didRealpath)
            return this._realpath();
          common.finish(this);
          this.emit("end", this.found);
        };
        Glob.prototype._realpath = function() {
          if (this._didRealpath)
            return;
          this._didRealpath = true;
          var n = this.matches.length;
          if (n === 0)
            return this._finish();
          var self2 = this;
          for (var i = 0; i < this.matches.length; i++)
            this._realpathSet(i, next);
          function next() {
            if (--n === 0)
              self2._finish();
          }
        };
        Glob.prototype._realpathSet = function(index, cb) {
          var matchset = this.matches[index];
          if (!matchset)
            return cb();
          var found = Object.keys(matchset);
          var self2 = this;
          var n = found.length;
          if (n === 0)
            return cb();
          var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
          found.forEach(function(p, i) {
            p = self2._makeAbs(p);
            rp.realpath(p, self2.realpathCache, function(er, real) {
              if (!er)
                set[real] = true;
              else if (er.syscall === "stat")
                set[p] = true;
              else
                self2.emit("error", er);
              if (--n === 0) {
                self2.matches[index] = set;
                cb();
              }
            });
          });
        };
        Glob.prototype._mark = function(p) {
          return common.mark(this, p);
        };
        Glob.prototype._makeAbs = function(f) {
          return common.makeAbs(this, f);
        };
        Glob.prototype.abort = function() {
          this.aborted = true;
          this.emit("abort");
        };
        Glob.prototype.pause = function() {
          if (!this.paused) {
            this.paused = true;
            this.emit("pause");
          }
        };
        Glob.prototype.resume = function() {
          if (this.paused) {
            this.emit("resume");
            this.paused = false;
            if (this._emitQueue.length) {
              var eq = this._emitQueue.slice(0);
              this._emitQueue.length = 0;
              for (var i = 0; i < eq.length; i++) {
                var e = eq[i];
                this._emitMatch(e[0], e[1]);
              }
            }
            if (this._processQueue.length) {
              var pq = this._processQueue.slice(0);
              this._processQueue.length = 0;
              for (var i = 0; i < pq.length; i++) {
                var p = pq[i];
                this._processing--;
                this._process(p[0], p[1], p[2], p[3]);
              }
            }
          }
        };
        Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
          assert7(this instanceof Glob);
          assert7(typeof cb === "function");
          if (this.aborted)
            return;
          this._processing++;
          if (this.paused) {
            this._processQueue.push([pattern, index, inGlobStar, cb]);
            return;
          }
          var n = 0;
          while (typeof pattern[n] === "string") {
            n++;
          }
          var prefix;
          switch (n) {
            case pattern.length:
              this._processSimple(pattern.join("/"), index, cb);
              return;
            case 0:
              prefix = null;
              break;
            default:
              prefix = pattern.slice(0, n).join("/");
              break;
          }
          var remain = pattern.slice(n);
          var read;
          if (prefix === null)
            read = ".";
          else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
            return typeof p === "string" ? p : "[*]";
          }).join("/"))) {
            if (!prefix || !isAbsolute(prefix))
              prefix = "/" + prefix;
            read = prefix;
          } else
            read = prefix;
          var abs = this._makeAbs(read);
          if (childrenIgnored(this, read))
            return cb();
          var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
          if (isGlobStar)
            this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
          else
            this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
        };
        Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
          var self2 = this;
          this._readdir(abs, inGlobStar, function(er, entries) {
            return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
          });
        };
        Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
          if (!entries)
            return cb();
          var pn = remain[0];
          var negate = !!this.minimatch.negate;
          var rawGlob = pn._glob;
          var dotOk = this.dot || rawGlob.charAt(0) === ".";
          var matchedEntries = [];
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (e.charAt(0) !== "." || dotOk) {
              var m;
              if (negate && !prefix) {
                m = !e.match(pn);
              } else {
                m = e.match(pn);
              }
              if (m)
                matchedEntries.push(e);
            }
          }
          var len = matchedEntries.length;
          if (len === 0)
            return cb();
          if (remain.length === 1 && !this.mark && !this.stat) {
            if (!this.matches[index])
              this.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var i = 0; i < len; i++) {
              var e = matchedEntries[i];
              if (prefix) {
                if (prefix !== "/")
                  e = prefix + "/" + e;
                else
                  e = prefix + e;
              }
              if (e.charAt(0) === "/" && !this.nomount) {
                e = path7.join(this.root, e);
              }
              this._emitMatch(index, e);
            }
            return cb();
          }
          remain.shift();
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            var newPattern;
            if (prefix) {
              if (prefix !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            this._process([e].concat(remain), index, inGlobStar, cb);
          }
          cb();
        };
        Glob.prototype._emitMatch = function(index, e) {
          if (this.aborted)
            return;
          if (isIgnored(this, e))
            return;
          if (this.paused) {
            this._emitQueue.push([index, e]);
            return;
          }
          var abs = isAbsolute(e) ? e : this._makeAbs(e);
          if (this.mark)
            e = this._mark(e);
          if (this.absolute)
            e = abs;
          if (this.matches[index][e])
            return;
          if (this.nodir) {
            var c = this.cache[abs];
            if (c === "DIR" || Array.isArray(c))
              return;
          }
          this.matches[index][e] = true;
          var st = this.statCache[abs];
          if (st)
            this.emit("stat", e, st);
          this.emit("match", e);
        };
        Glob.prototype._readdirInGlobStar = function(abs, cb) {
          if (this.aborted)
            return;
          if (this.follow)
            return this._readdir(abs, false, cb);
          var lstatkey = "lstat\0" + abs;
          var self2 = this;
          var lstatcb = inflight(lstatkey, lstatcb_);
          if (lstatcb)
            self2.fs.lstat(abs, lstatcb);
          function lstatcb_(er, lstat2) {
            if (er && er.code === "ENOENT")
              return cb();
            var isSym = lstat2 && lstat2.isSymbolicLink();
            self2.symlinks[abs] = isSym;
            if (!isSym && lstat2 && !lstat2.isDirectory()) {
              self2.cache[abs] = "FILE";
              cb();
            } else
              self2._readdir(abs, false, cb);
          }
        };
        Glob.prototype._readdir = function(abs, inGlobStar, cb) {
          if (this.aborted)
            return;
          cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
          if (!cb)
            return;
          if (inGlobStar && !ownProp(this.symlinks, abs))
            return this._readdirInGlobStar(abs, cb);
          if (ownProp(this.cache, abs)) {
            var c = this.cache[abs];
            if (!c || c === "FILE")
              return cb();
            if (Array.isArray(c))
              return cb(null, c);
          }
          var self2 = this;
          self2.fs.readdir(abs, readdirCb(this, abs, cb));
        };
        function readdirCb(self2, abs, cb) {
          return function(er, entries) {
            if (er)
              self2._readdirError(abs, er, cb);
            else
              self2._readdirEntries(abs, entries, cb);
          };
        }
        Glob.prototype._readdirEntries = function(abs, entries, cb) {
          if (this.aborted)
            return;
          if (!this.mark && !this.stat) {
            for (var i = 0; i < entries.length; i++) {
              var e = entries[i];
              if (abs === "/")
                e = abs + e;
              else
                e = abs + "/" + e;
              this.cache[e] = true;
            }
          }
          this.cache[abs] = entries;
          return cb(null, entries);
        };
        Glob.prototype._readdirError = function(f, er, cb) {
          if (this.aborted)
            return;
          switch (er.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var abs = this._makeAbs(f);
              this.cache[abs] = "FILE";
              if (abs === this.cwdAbs) {
                var error = new Error(er.code + " invalid cwd " + this.cwd);
                error.path = this.cwd;
                error.code = er.code;
                this.emit("error", error);
                this.abort();
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(f)] = false;
              break;
            default:
              this.cache[this._makeAbs(f)] = false;
              if (this.strict) {
                this.emit("error", er);
                this.abort();
              }
              if (!this.silent)
                console.error("glob error", er);
              break;
          }
          return cb();
        };
        Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
          var self2 = this;
          this._readdir(abs, inGlobStar, function(er, entries) {
            self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
          });
        };
        Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
          if (!entries)
            return cb();
          var remainWithoutGlobStar = remain.slice(1);
          var gspref = prefix ? [prefix] : [];
          var noGlobStar = gspref.concat(remainWithoutGlobStar);
          this._process(noGlobStar, index, false, cb);
          var isSym = this.symlinks[abs];
          var len = entries.length;
          if (isSym && inGlobStar)
            return cb();
          for (var i = 0; i < len; i++) {
            var e = entries[i];
            if (e.charAt(0) === "." && !this.dot)
              continue;
            var instead = gspref.concat(entries[i], remainWithoutGlobStar);
            this._process(instead, index, true, cb);
            var below = gspref.concat(entries[i], remain);
            this._process(below, index, true, cb);
          }
          cb();
        };
        Glob.prototype._processSimple = function(prefix, index, cb) {
          var self2 = this;
          this._stat(prefix, function(er, exists) {
            self2._processSimple2(prefix, index, er, exists, cb);
          });
        };
        Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          if (!exists)
            return cb();
          if (prefix && isAbsolute(prefix) && !this.nomount) {
            var trail = /[\/\\]$/.test(prefix);
            if (prefix.charAt(0) === "/") {
              prefix = path7.join(this.root, prefix);
            } else {
              prefix = path7.resolve(this.root, prefix);
              if (trail)
                prefix += "/";
            }
          }
          if (process.platform === "win32")
            prefix = prefix.replace(/\\/g, "/");
          this._emitMatch(index, prefix);
          cb();
        };
        Glob.prototype._stat = function(f, cb) {
          var abs = this._makeAbs(f);
          var needDir = f.slice(-1) === "/";
          if (f.length > this.maxLength)
            return cb();
          if (!this.stat && ownProp(this.cache, abs)) {
            var c = this.cache[abs];
            if (Array.isArray(c))
              c = "DIR";
            if (!needDir || c === "DIR")
              return cb(null, c);
            if (needDir && c === "FILE")
              return cb();
          }
          var exists;
          var stat = this.statCache[abs];
          if (stat !== void 0) {
            if (stat === false)
              return cb(null, stat);
            else {
              var type = stat.isDirectory() ? "DIR" : "FILE";
              if (needDir && type === "FILE")
                return cb();
              else
                return cb(null, type, stat);
            }
          }
          var self2 = this;
          var statcb = inflight("stat\0" + abs, lstatcb_);
          if (statcb)
            self2.fs.lstat(abs, statcb);
          function lstatcb_(er, lstat2) {
            if (lstat2 && lstat2.isSymbolicLink()) {
              return self2.fs.stat(abs, function(er2, stat2) {
                if (er2)
                  self2._stat2(f, abs, null, lstat2, cb);
                else
                  self2._stat2(f, abs, er2, stat2, cb);
              });
            } else {
              self2._stat2(f, abs, er, lstat2, cb);
            }
          }
        };
        Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return cb();
          }
          var needDir = f.slice(-1) === "/";
          this.statCache[abs] = stat;
          if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
            return cb(null, false, stat);
          var c = true;
          if (stat)
            c = stat.isDirectory() ? "DIR" : "FILE";
          this.cache[abs] = this.cache[abs] || c;
          if (needDir && c === "FILE")
            return cb();
          return cb(null, c, stat);
        };
      }
    });
    var require_src = __commonJS({
      "../../node_modules/.pnpm/nice-try@1.0.5/node_modules/nice-try/src/index.js"(exports2, module2) {
        "use strict";
        module2.exports = function(fn) {
          try {
            return fn();
          } catch (e) {
          }
        };
      }
    });
    var require_windows = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
        module2.exports = isexe;
        isexe.sync = sync;
        var fs6 = require("fs");
        function checkPathExt(path7, options) {
          var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
          if (!pathext) {
            return true;
          }
          pathext = pathext.split(";");
          if (pathext.indexOf("") !== -1) {
            return true;
          }
          for (var i = 0; i < pathext.length; i++) {
            var p = pathext[i].toLowerCase();
            if (p && path7.substr(-p.length).toLowerCase() === p) {
              return true;
            }
          }
          return false;
        }
        function checkStat(stat, path7, options) {
          if (!stat.isSymbolicLink() && !stat.isFile()) {
            return false;
          }
          return checkPathExt(path7, options);
        }
        function isexe(path7, options, cb) {
          fs6.stat(path7, function(er, stat) {
            cb(er, er ? false : checkStat(stat, path7, options));
          });
        }
        function sync(path7, options) {
          return checkStat(fs6.statSync(path7), path7, options);
        }
      }
    });
    var require_mode = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
        module2.exports = isexe;
        isexe.sync = sync;
        var fs6 = require("fs");
        function isexe(path7, options, cb) {
          fs6.stat(path7, function(er, stat) {
            cb(er, er ? false : checkStat(stat, options));
          });
        }
        function sync(path7, options) {
          return checkStat(fs6.statSync(path7), options);
        }
        function checkStat(stat, options) {
          return stat.isFile() && checkMode(stat, options);
        }
        function checkMode(stat, options) {
          var mod = stat.mode;
          var uid = stat.uid;
          var gid = stat.gid;
          var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
          var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
          var u = parseInt("100", 8);
          var g = parseInt("010", 8);
          var o = parseInt("001", 8);
          var ug = u | g;
          var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
          return ret;
        }
      }
    });
    var require_isexe = __commonJS({
      "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
        var fs6 = require("fs");
        var core;
        if (process.platform === "win32" || global.TESTING_WINDOWS) {
          core = require_windows();
        } else {
          core = require_mode();
        }
        module2.exports = isexe;
        isexe.sync = sync;
        function isexe(path7, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          if (!cb) {
            if (typeof Promise !== "function") {
              throw new TypeError("callback not provided");
            }
            return new Promise(function(resolve, reject) {
              isexe(path7, options || {}, function(er, is) {
                if (er) {
                  reject(er);
                } else {
                  resolve(is);
                }
              });
            });
          }
          core(path7, options || {}, function(er, is) {
            if (er) {
              if (er.code === "EACCES" || options && options.ignoreErrors) {
                er = null;
                is = false;
              }
            }
            cb(er, is);
          });
        }
        function sync(path7, options) {
          try {
            return core.sync(path7, options || {});
          } catch (er) {
            if (options && options.ignoreErrors || er.code === "EACCES") {
              return false;
            } else {
              throw er;
            }
          }
        }
      }
    });
    var require_which = __commonJS({
      "../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js"(exports2, module2) {
        module2.exports = which;
        which.sync = whichSync;
        var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
        var path7 = require("path");
        var COLON = isWindows ? ";" : ":";
        var isexe = require_isexe();
        function getNotFoundError(cmd) {
          var er = new Error("not found: " + cmd);
          er.code = "ENOENT";
          return er;
        }
        function getPathInfo(cmd, opt) {
          var colon = opt.colon || COLON;
          var pathEnv = opt.path || process.env.PATH || "";
          var pathExt = [""];
          pathEnv = pathEnv.split(colon);
          var pathExtExe = "";
          if (isWindows) {
            pathEnv.unshift(process.cwd());
            pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
            pathExt = pathExtExe.split(colon);
            if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
              pathExt.unshift("");
          }
          if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
            pathEnv = [""];
          return {
            env: pathEnv,
            ext: pathExt,
            extExe: pathExtExe
          };
        }
        function which(cmd, opt, cb) {
          if (typeof opt === "function") {
            cb = opt;
            opt = {};
          }
          var info = getPathInfo(cmd, opt);
          var pathEnv = info.env;
          var pathExt = info.ext;
          var pathExtExe = info.extExe;
          var found = [];
          (function F(i, l) {
            if (i === l) {
              if (opt.all && found.length)
                return cb(null, found);
              else
                return cb(getNotFoundError(cmd));
            }
            var pathPart = pathEnv[i];
            if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
              pathPart = pathPart.slice(1, -1);
            var p = path7.join(pathPart, cmd);
            if (!pathPart && /^\.[\\\/]/.test(cmd)) {
              p = cmd.slice(0, 2) + p;
            }
            ;
            (function E(ii, ll) {
              if (ii === ll)
                return F(i + 1, l);
              var ext = pathExt[ii];
              isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
                if (!er && is) {
                  if (opt.all)
                    found.push(p + ext);
                  else
                    return cb(null, p + ext);
                }
                return E(ii + 1, ll);
              });
            })(0, pathExt.length);
          })(0, pathEnv.length);
        }
        function whichSync(cmd, opt) {
          opt = opt || {};
          var info = getPathInfo(cmd, opt);
          var pathEnv = info.env;
          var pathExt = info.ext;
          var pathExtExe = info.extExe;
          var found = [];
          for (var i = 0, l = pathEnv.length; i < l; i++) {
            var pathPart = pathEnv[i];
            if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
              pathPart = pathPart.slice(1, -1);
            var p = path7.join(pathPart, cmd);
            if (!pathPart && /^\.[\\\/]/.test(cmd)) {
              p = cmd.slice(0, 2) + p;
            }
            for (var j = 0, ll = pathExt.length; j < ll; j++) {
              var cur = p + pathExt[j];
              var is;
              try {
                is = isexe.sync(cur, { pathExt: pathExtExe });
                if (is) {
                  if (opt.all)
                    found.push(cur);
                  else
                    return cur;
                }
              } catch (ex) {
              }
            }
          }
          if (opt.all && found.length)
            return found;
          if (opt.nothrow)
            return null;
          throw getNotFoundError(cmd);
        }
      }
    });
    var require_path_key = __commonJS({
      "../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js"(exports2, module2) {
        "use strict";
        module2.exports = (opts) => {
          opts = opts || {};
          const env = opts.env || process.env;
          const platform = opts.platform || process.platform;
          if (platform !== "win32") {
            return "PATH";
          }
          return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
        };
      }
    });
    var require_resolveCommand = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var which = require_which();
        var pathKey = require_path_key()();
        function resolveCommandAttempt(parsed, withoutPathExt) {
          const cwd = process.cwd();
          const hasCustomCwd = parsed.options.cwd != null;
          if (hasCustomCwd) {
            try {
              process.chdir(parsed.options.cwd);
            } catch (err) {
            }
          }
          let resolved;
          try {
            resolved = which.sync(parsed.command, {
              path: (parsed.options.env || process.env)[pathKey],
              pathExt: withoutPathExt ? path7.delimiter : void 0
            });
          } catch (e) {
          } finally {
            process.chdir(cwd);
          }
          if (resolved) {
            resolved = path7.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
          }
          return resolved;
        }
        function resolveCommand(parsed) {
          return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
        }
        module2.exports = resolveCommand;
      }
    });
    var require_escape = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
        "use strict";
        var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
        function escapeCommand(arg) {
          arg = arg.replace(metaCharsRegExp, "^$1");
          return arg;
        }
        function escapeArgument(arg, doubleEscapeMetaChars) {
          arg = `${arg}`;
          arg = arg.replace(/(\\*)"/g, '$1$1\\"');
          arg = arg.replace(/(\\*)$/, "$1$1");
          arg = `"${arg}"`;
          arg = arg.replace(metaCharsRegExp, "^$1");
          if (doubleEscapeMetaChars) {
            arg = arg.replace(metaCharsRegExp, "^$1");
          }
          return arg;
        }
        module2.exports.command = escapeCommand;
        module2.exports.argument = escapeArgument;
      }
    });
    var require_shebang_regex = __commonJS({
      "../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
        "use strict";
        module2.exports = /^#!.*/;
      }
    });
    var require_shebang_command = __commonJS({
      "../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js"(exports2, module2) {
        "use strict";
        var shebangRegex = require_shebang_regex();
        module2.exports = function(str) {
          var match = str.match(shebangRegex);
          if (!match) {
            return null;
          }
          var arr = match[0].replace(/#! ?/, "").split(" ");
          var bin = arr[0].split("/").pop();
          var arg = arr[1];
          return bin === "env" ? arg : bin + (arg ? " " + arg : "");
        };
      }
    });
    var require_readShebang = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
        "use strict";
        var fs6 = require("fs");
        var shebangCommand = require_shebang_command();
        function readShebang(command) {
          const size = 150;
          let buffer;
          if (Buffer.alloc) {
            buffer = Buffer.alloc(size);
          } else {
            buffer = new Buffer(size);
            buffer.fill(0);
          }
          let fd;
          try {
            fd = fs6.openSync(command, "r");
            fs6.readSync(fd, buffer, 0, size, 0);
            fs6.closeSync(fd);
          } catch (e) {
          }
          return shebangCommand(buffer.toString());
        }
        module2.exports = readShebang;
      }
    });
    var require_semver = __commonJS({
      "../../node_modules/.pnpm/semver@5.7.2/node_modules/semver/semver.js"(exports2, module2) {
        exports2 = module2.exports = SemVer2;
        var debug2;
        if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
          debug2 = function() {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift("SEMVER");
            console.log.apply(console, args);
          };
        } else {
          debug2 = function() {
          };
        }
        exports2.SEMVER_SPEC_VERSION = "2.0.0";
        var MAX_LENGTH = 256;
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
        9007199254740991;
        var MAX_SAFE_COMPONENT_LENGTH = 16;
        var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
        var re = exports2.re = [];
        var safeRe = exports2.safeRe = [];
        var src = exports2.src = [];
        var R = 0;
        var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
        var safeRegexReplacements = [
          ["\\s", 1],
          ["\\d", MAX_LENGTH],
          [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
        ];
        function makeSafeRe(value) {
          for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
            var token = safeRegexReplacements[i2][0];
            var max = safeRegexReplacements[i2][1];
            value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
          }
          return value;
        }
        var NUMERICIDENTIFIER = R++;
        src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
        var NUMERICIDENTIFIERLOOSE = R++;
        src[NUMERICIDENTIFIERLOOSE] = "\\d+";
        var NONNUMERICIDENTIFIER = R++;
        src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
        var MAINVERSION = R++;
        src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
        var MAINVERSIONLOOSE = R++;
        src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
        var PRERELEASEIDENTIFIER = R++;
        src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
        var PRERELEASEIDENTIFIERLOOSE = R++;
        src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
        var PRERELEASE = R++;
        src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
        var PRERELEASELOOSE = R++;
        src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
        var BUILDIDENTIFIER = R++;
        src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
        var BUILD = R++;
        src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
        var FULL = R++;
        var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
        src[FULL] = "^" + FULLPLAIN + "$";
        var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
        var LOOSE = R++;
        src[LOOSE] = "^" + LOOSEPLAIN + "$";
        var GTLT = R++;
        src[GTLT] = "((?:<|>)?=?)";
        var XRANGEIDENTIFIERLOOSE = R++;
        src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
        var XRANGEIDENTIFIER = R++;
        src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
        var XRANGEPLAIN = R++;
        src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
        var XRANGEPLAINLOOSE = R++;
        src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
        var XRANGE = R++;
        src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
        var XRANGELOOSE = R++;
        src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
        var COERCE = R++;
        src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
        var LONETILDE = R++;
        src[LONETILDE] = "(?:~>?)";
        var TILDETRIM = R++;
        src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
        re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
        safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
        var tildeTrimReplace = "$1~";
        var TILDE = R++;
        src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
        var TILDELOOSE = R++;
        src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
        var LONECARET = R++;
        src[LONECARET] = "(?:\\^)";
        var CARETTRIM = R++;
        src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
        re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
        safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
        var caretTrimReplace = "$1^";
        var CARET = R++;
        src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
        var CARETLOOSE = R++;
        src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
        var COMPARATORLOOSE = R++;
        src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
        var COMPARATOR = R++;
        src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
        var COMPARATORTRIM = R++;
        src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
        re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
        safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
        var comparatorTrimReplace = "$1$2$3";
        var HYPHENRANGE = R++;
        src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
        var HYPHENRANGELOOSE = R++;
        src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
        var STAR = R++;
        src[STAR] = "(<|>)?=?\\s*\\*";
        for (i = 0; i < R; i++) {
          debug2(i, src[i]);
          if (!re[i]) {
            re[i] = new RegExp(src[i]);
            safeRe[i] = new RegExp(makeSafeRe(src[i]));
          }
        }
        var i;
        exports2.parse = parse3;
        function parse3(version, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (version instanceof SemVer2) {
            return version;
          }
          if (typeof version !== "string") {
            return null;
          }
          if (version.length > MAX_LENGTH) {
            return null;
          }
          var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
          if (!r.test(version)) {
            return null;
          }
          try {
            return new SemVer2(version, options);
          } catch (er) {
            return null;
          }
        }
        exports2.valid = valid;
        function valid(version, options) {
          var v = parse3(version, options);
          return v ? v.version : null;
        }
        exports2.clean = clean;
        function clean(version, options) {
          var s = parse3(version.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        }
        exports2.SemVer = SemVer2;
        function SemVer2(version, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (version instanceof SemVer2) {
            if (version.loose === options.loose) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== "string") {
            throw new TypeError("Invalid Version: " + version);
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
          }
          if (!(this instanceof SemVer2)) {
            return new SemVer2(version, options);
          }
          debug2("SemVer", version, options);
          this.options = options;
          this.loose = !!options.loose;
          var m = version.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
          if (!m) {
            throw new TypeError("Invalid Version: " + version);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map(function(id) {
              if (/^[0-9]+$/.test(id)) {
                var num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        SemVer2.prototype.format = function() {
          this.version = this.major + "." + this.minor + "." + this.patch;
          if (this.prerelease.length) {
            this.version += "-" + this.prerelease.join(".");
          }
          return this.version;
        };
        SemVer2.prototype.toString = function() {
          return this.version;
        };
        SemVer2.prototype.compare = function(other) {
          debug2("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          return this.compareMain(other) || this.comparePre(other);
        };
        SemVer2.prototype.compareMain = function(other) {
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        };
        SemVer2.prototype.comparePre = function(other) {
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          var i2 = 0;
          do {
            var a = this.prerelease[i2];
            var b = other.prerelease[i2];
            debug2("prerelease compare", i2, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i2);
        };
        SemVer2.prototype.inc = function(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier);
              this.inc("pre", identifier);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier);
              }
              this.inc("pre", identifier);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                var i2 = this.prerelease.length;
                while (--i2 >= 0) {
                  if (typeof this.prerelease[i2] === "number") {
                    this.prerelease[i2]++;
                    i2 = -2;
                  }
                }
                if (i2 === -1) {
                  this.prerelease.push(0);
                }
              }
              if (identifier) {
                if (this.prerelease[0] === identifier) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }
              break;
            default:
              throw new Error("invalid increment argument: " + release);
          }
          this.format();
          this.raw = this.version;
          return this;
        };
        exports2.inc = inc;
        function inc(version, release, loose, identifier) {
          if (typeof loose === "string") {
            identifier = loose;
            loose = void 0;
          }
          try {
            return new SemVer2(version, loose).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        }
        exports2.diff = diff;
        function diff(version1, version2) {
          if (eq(version1, version2)) {
            return null;
          } else {
            var v1 = parse3(version1);
            var v2 = parse3(version2);
            var prefix = "";
            if (v1.prerelease.length || v2.prerelease.length) {
              prefix = "pre";
              var defaultResult = "prerelease";
            }
            for (var key in v1) {
              if (key === "major" || key === "minor" || key === "patch") {
                if (v1[key] !== v2[key]) {
                  return prefix + key;
                }
              }
            }
            return defaultResult;
          }
        }
        exports2.compareIdentifiers = compareIdentifiers;
        var numeric = /^[0-9]+$/;
        function compareIdentifiers(a, b) {
          var anum = numeric.test(a);
          var bnum = numeric.test(b);
          if (anum && bnum) {
            a = +a;
            b = +b;
          }
          return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        }
        exports2.rcompareIdentifiers = rcompareIdentifiers;
        function rcompareIdentifiers(a, b) {
          return compareIdentifiers(b, a);
        }
        exports2.major = major;
        function major(a, loose) {
          return new SemVer2(a, loose).major;
        }
        exports2.minor = minor;
        function minor(a, loose) {
          return new SemVer2(a, loose).minor;
        }
        exports2.patch = patch;
        function patch(a, loose) {
          return new SemVer2(a, loose).patch;
        }
        exports2.compare = compare;
        function compare(a, b, loose) {
          return new SemVer2(a, loose).compare(new SemVer2(b, loose));
        }
        exports2.compareLoose = compareLoose;
        function compareLoose(a, b) {
          return compare(a, b, true);
        }
        exports2.rcompare = rcompare;
        function rcompare(a, b, loose) {
          return compare(b, a, loose);
        }
        exports2.sort = sort;
        function sort(list, loose) {
          return list.sort(function(a, b) {
            return exports2.compare(a, b, loose);
          });
        }
        exports2.rsort = rsort;
        function rsort(list, loose) {
          return list.sort(function(a, b) {
            return exports2.rcompare(a, b, loose);
          });
        }
        exports2.gt = gt;
        function gt(a, b, loose) {
          return compare(a, b, loose) > 0;
        }
        exports2.lt = lt;
        function lt(a, b, loose) {
          return compare(a, b, loose) < 0;
        }
        exports2.eq = eq;
        function eq(a, b, loose) {
          return compare(a, b, loose) === 0;
        }
        exports2.neq = neq;
        function neq(a, b, loose) {
          return compare(a, b, loose) !== 0;
        }
        exports2.gte = gte2;
        function gte2(a, b, loose) {
          return compare(a, b, loose) >= 0;
        }
        exports2.lte = lte;
        function lte(a, b, loose) {
          return compare(a, b, loose) <= 0;
        }
        exports2.cmp = cmp;
        function cmp(a, op, b, loose) {
          switch (op) {
            case "===":
              if (typeof a === "object")
                a = a.version;
              if (typeof b === "object")
                b = b.version;
              return a === b;
            case "!==":
              if (typeof a === "object")
                a = a.version;
              if (typeof b === "object")
                b = b.version;
              return a !== b;
            case "":
            case "=":
            case "==":
              return eq(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt(a, b, loose);
            case ">=":
              return gte2(a, b, loose);
            case "<":
              return lt(a, b, loose);
            case "<=":
              return lte(a, b, loose);
            default:
              throw new TypeError("Invalid operator: " + op);
          }
        }
        exports2.Comparator = Comparator;
        function Comparator(comp, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          if (!(this instanceof Comparator)) {
            return new Comparator(comp, options);
          }
          comp = comp.trim().split(/\s+/).join(" ");
          debug2("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug2("comp", this);
        }
        var ANY = {};
        Comparator.prototype.parse = function(comp) {
          var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
          var m = comp.match(r);
          if (!m) {
            throw new TypeError("Invalid comparator: " + comp);
          }
          this.operator = m[1];
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer2(m[2], this.options.loose);
          }
        };
        Comparator.prototype.toString = function() {
          return this.value;
        };
        Comparator.prototype.test = function(version) {
          debug2("Comparator.test", version, this.options.loose);
          if (this.semver === ANY) {
            return true;
          }
          if (typeof version === "string") {
            version = new SemVer2(version, this.options);
          }
          return cmp(version, this.operator, this.semver, this.options);
        };
        Comparator.prototype.intersects = function(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          var rangeTmp;
          if (this.operator === "") {
            rangeTmp = new Range(comp.value, options);
            return satisfies2(this.value, rangeTmp, options);
          } else if (comp.operator === "") {
            rangeTmp = new Range(this.value, options);
            return satisfies2(comp.semver, rangeTmp, options);
          }
          var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
          var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
          var sameSemVer = this.semver.version === comp.semver.version;
          var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
          var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
          var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        };
        exports2.Range = Range;
        function Range(range, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            return new Range(range.value, options);
          }
          if (!(this instanceof Range)) {
            return new Range(range, options);
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range.trim().split(/\s+/).join(" ");
          this.set = this.raw.split("||").map(function(range2) {
            return this.parseRange(range2.trim());
          }, this).filter(function(c) {
            return c.length;
          });
          if (!this.set.length) {
            throw new TypeError("Invalid SemVer Range: " + this.raw);
          }
          this.format();
        }
        Range.prototype.format = function() {
          this.range = this.set.map(function(comps) {
            return comps.join(" ").trim();
          }).join("||").trim();
          return this.range;
        };
        Range.prototype.toString = function() {
          return this.range;
        };
        Range.prototype.parseRange = function(range) {
          var loose = this.options.loose;
          var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
          range = range.replace(hr, hyphenReplace);
          debug2("hyphen replace", range);
          range = range.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
          debug2("comparator trim", range, safeRe[COMPARATORTRIM]);
          range = range.replace(safeRe[TILDETRIM], tildeTrimReplace);
          range = range.replace(safeRe[CARETTRIM], caretTrimReplace);
          var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
          var set = range.split(" ").map(function(comp) {
            return parseComparator(comp, this.options);
          }, this).join(" ").split(/\s+/);
          if (this.options.loose) {
            set = set.filter(function(comp) {
              return !!comp.match(compRe);
            });
          }
          set = set.map(function(comp) {
            return new Comparator(comp, this.options);
          }, this);
          return set;
        };
        Range.prototype.intersects = function(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some(function(thisComparators) {
            return thisComparators.every(function(thisComparator) {
              return range.set.some(function(rangeComparators) {
                return rangeComparators.every(function(rangeComparator) {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        };
        exports2.toComparators = toComparators;
        function toComparators(range, options) {
          return new Range(range, options).set.map(function(comp) {
            return comp.map(function(c) {
              return c.value;
            }).join(" ").trim().split(" ");
          });
        }
        function parseComparator(comp, options) {
          debug2("comp", comp, options);
          comp = replaceCarets(comp, options);
          debug2("caret", comp);
          comp = replaceTildes(comp, options);
          debug2("tildes", comp);
          comp = replaceXRanges(comp, options);
          debug2("xrange", comp);
          comp = replaceStars(comp, options);
          debug2("stars", comp);
          return comp;
        }
        function isX(id) {
          return !id || id.toLowerCase() === "x" || id === "*";
        }
        function replaceTildes(comp, options) {
          return comp.trim().split(/\s+/).map(function(comp2) {
            return replaceTilde(comp2, options);
          }).join(" ");
        }
        function replaceTilde(comp, options) {
          var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
          return comp.replace(r, function(_, M, m, p, pr) {
            debug2("tilde", comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
              ret = "";
            } else if (isX(m)) {
              ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
            } else if (isX(p)) {
              ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
            } else if (pr) {
              debug2("replaceTilde pr", pr);
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
            debug2("tilde return", ret);
            return ret;
          });
        }
        function replaceCarets(comp, options) {
          return comp.trim().split(/\s+/).map(function(comp2) {
            return replaceCaret(comp2, options);
          }).join(" ");
        }
        function replaceCaret(comp, options) {
          debug2("caret", comp, options);
          var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
          return comp.replace(r, function(_, M, m, p, pr) {
            debug2("caret", comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
              ret = "";
            } else if (isX(m)) {
              ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
            } else if (isX(p)) {
              if (M === "0") {
                ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
              } else {
                ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
              }
            } else if (pr) {
              debug2("replaceCaret pr", pr);
              if (M === "0") {
                if (m === "0") {
                  ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
                } else {
                  ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
                }
              } else {
                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
              }
            } else {
              debug2("no pr");
              if (M === "0") {
                if (m === "0") {
                  ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
                } else {
                  ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
                }
              } else {
                ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
              }
            }
            debug2("caret return", ret);
            return ret;
          });
        }
        function replaceXRanges(comp, options) {
          debug2("replaceXRanges", comp, options);
          return comp.split(/\s+/).map(function(comp2) {
            return replaceXRange(comp2, options);
          }).join(" ");
        }
        function replaceXRange(comp, options) {
          comp = comp.trim();
          var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
          return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
            debug2("xRange", comp, ret, gtlt, M, m, p, pr);
            var xM = isX(M);
            var xm = xM || isX(m);
            var xp = xm || isX(p);
            var anyX = xp;
            if (gtlt === "=" && anyX) {
              gtlt = "";
            }
            if (xM) {
              if (gtlt === ">" || gtlt === "<") {
                ret = "<0.0.0";
              } else {
                ret = "*";
              }
            } else if (gtlt && anyX) {
              if (xm) {
                m = 0;
              }
              p = 0;
              if (gtlt === ">") {
                gtlt = ">=";
                if (xm) {
                  M = +M + 1;
                  m = 0;
                  p = 0;
                } else {
                  m = +m + 1;
                  p = 0;
                }
              } else if (gtlt === "<=") {
                gtlt = "<";
                if (xm) {
                  M = +M + 1;
                } else {
                  m = +m + 1;
                }
              }
              ret = gtlt + M + "." + m + "." + p;
            } else if (xm) {
              ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
            } else if (xp) {
              ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
            }
            debug2("xRange return", ret);
            return ret;
          });
        }
        function replaceStars(comp, options) {
          debug2("replaceStars", comp, options);
          return comp.trim().replace(safeRe[STAR], "");
        }
        function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
          if (isX(fM)) {
            from = "";
          } else if (isX(fm)) {
            from = ">=" + fM + ".0.0";
          } else if (isX(fp)) {
            from = ">=" + fM + "." + fm + ".0";
          } else {
            from = ">=" + from;
          }
          if (isX(tM)) {
            to = "";
          } else if (isX(tm)) {
            to = "<" + (+tM + 1) + ".0.0";
          } else if (isX(tp)) {
            to = "<" + tM + "." + (+tm + 1) + ".0";
          } else if (tpr) {
            to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
          } else {
            to = "<=" + to;
          }
          return (from + " " + to).trim();
        }
        Range.prototype.test = function(version) {
          if (!version) {
            return false;
          }
          if (typeof version === "string") {
            version = new SemVer2(version, this.options);
          }
          for (var i2 = 0; i2 < this.set.length; i2++) {
            if (testSet(this.set[i2], version, this.options)) {
              return true;
            }
          }
          return false;
        };
        function testSet(set, version, options) {
          for (var i2 = 0; i2 < set.length; i2++) {
            if (!set[i2].test(version)) {
              return false;
            }
          }
          if (version.prerelease.length && !options.includePrerelease) {
            for (i2 = 0; i2 < set.length; i2++) {
              debug2(set[i2].semver);
              if (set[i2].semver === ANY) {
                continue;
              }
              if (set[i2].semver.prerelease.length > 0) {
                var allowed = set[i2].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                  return true;
                }
              }
            }
            return false;
          }
          return true;
        }
        exports2.satisfies = satisfies2;
        function satisfies2(version, range, options) {
          try {
            range = new Range(range, options);
          } catch (er) {
            return false;
          }
          return range.test(version);
        }
        exports2.maxSatisfying = maxSatisfying;
        function maxSatisfying(versions, range, options) {
          var max = null;
          var maxSV = null;
          try {
            var rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          versions.forEach(function(v) {
            if (rangeObj.test(v)) {
              if (!max || maxSV.compare(v) === -1) {
                max = v;
                maxSV = new SemVer2(max, options);
              }
            }
          });
          return max;
        }
        exports2.minSatisfying = minSatisfying;
        function minSatisfying(versions, range, options) {
          var min = null;
          var minSV = null;
          try {
            var rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          versions.forEach(function(v) {
            if (rangeObj.test(v)) {
              if (!min || minSV.compare(v) === 1) {
                min = v;
                minSV = new SemVer2(min, options);
              }
            }
          });
          return min;
        }
        exports2.minVersion = minVersion2;
        function minVersion2(range, loose) {
          range = new Range(range, loose);
          var minver = new SemVer2("0.0.0");
          if (range.test(minver)) {
            return minver;
          }
          minver = new SemVer2("0.0.0-0");
          if (range.test(minver)) {
            return minver;
          }
          minver = null;
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            var comparators = range.set[i2];
            comparators.forEach(function(comparator) {
              var compver = new SemVer2(comparator.semver.version);
              switch (comparator.operator) {
                case ">":
                  if (compver.prerelease.length === 0) {
                    compver.patch++;
                  } else {
                    compver.prerelease.push(0);
                  }
                  compver.raw = compver.format();
                case "":
                case ">=":
                  if (!minver || gt(minver, compver)) {
                    minver = compver;
                  }
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + comparator.operator);
              }
            });
          }
          if (minver && range.test(minver)) {
            return minver;
          }
          return null;
        }
        exports2.validRange = validRange3;
        function validRange3(range, options) {
          try {
            return new Range(range, options).range || "*";
          } catch (er) {
            return null;
          }
        }
        exports2.ltr = ltr;
        function ltr(version, range, options) {
          return outside(version, range, "<", options);
        }
        exports2.gtr = gtr;
        function gtr(version, range, options) {
          return outside(version, range, ">", options);
        }
        exports2.outside = outside;
        function outside(version, range, hilo, options) {
          version = new SemVer2(version, options);
          range = new Range(range, options);
          var gtfn, ltefn, ltfn, comp, ecomp;
          switch (hilo) {
            case ">":
              gtfn = gt;
              ltefn = lte;
              ltfn = lt;
              comp = ">";
              ecomp = ">=";
              break;
            case "<":
              gtfn = lt;
              ltefn = gte2;
              ltfn = gt;
              comp = "<";
              ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies2(version, range, options)) {
            return false;
          }
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            var comparators = range.set[i2];
            var high = null;
            var low = null;
            comparators.forEach(function(comparator) {
              if (comparator.semver === ANY) {
                comparator = new Comparator(">=0.0.0");
              }
              high = high || comparator;
              low = low || comparator;
              if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
              } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
              }
            });
            if (high.operator === comp || high.operator === ecomp) {
              return false;
            }
            if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
              return false;
            } else if (low.operator === ecomp && ltfn(version, low.semver)) {
              return false;
            }
          }
          return true;
        }
        exports2.prerelease = prerelease;
        function prerelease(version, options) {
          var parsed = parse3(version, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        }
        exports2.intersects = intersects3;
        function intersects3(r1, r2, options) {
          r1 = new Range(r1, options);
          r2 = new Range(r2, options);
          return r1.intersects(r2);
        }
        exports2.coerce = coerce2;
        function coerce2(version) {
          if (version instanceof SemVer2) {
            return version;
          }
          if (typeof version !== "string") {
            return null;
          }
          var match = version.match(safeRe[COERCE]);
          if (match == null) {
            return null;
          }
          return parse3(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
        }
      }
    });
    var require_parse = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
        "use strict";
        var path7 = require("path");
        var niceTry = require_src();
        var resolveCommand = require_resolveCommand();
        var escape = require_escape();
        var readShebang = require_readShebang();
        var semver = require_semver();
        var isWin2 = process.platform === "win32";
        var isExecutableRegExp = /\.(?:com|exe)$/i;
        var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
        var supportsShellOption = niceTry(() => semver.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
        function detectShebang(parsed) {
          parsed.file = resolveCommand(parsed);
          const shebang = parsed.file && readShebang(parsed.file);
          if (shebang) {
            parsed.args.unshift(parsed.file);
            parsed.command = shebang;
            return resolveCommand(parsed);
          }
          return parsed.file;
        }
        function parseNonShell(parsed) {
          if (!isWin2) {
            return parsed;
          }
          const commandFile = detectShebang(parsed);
          const needsShell = !isExecutableRegExp.test(commandFile);
          if (parsed.options.forceShell || needsShell) {
            const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
            parsed.command = path7.normalize(parsed.command);
            parsed.command = escape.command(parsed.command);
            parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
            const shellCommand = [parsed.command].concat(parsed.args).join(" ");
            parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
            parsed.command = process.env.comspec || "cmd.exe";
            parsed.options.windowsVerbatimArguments = true;
          }
          return parsed;
        }
        function parseShell(parsed) {
          if (supportsShellOption) {
            return parsed;
          }
          const shellCommand = [parsed.command].concat(parsed.args).join(" ");
          if (isWin2) {
            parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
            parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
            parsed.options.windowsVerbatimArguments = true;
          } else {
            if (typeof parsed.options.shell === "string") {
              parsed.command = parsed.options.shell;
            } else if (process.platform === "android") {
              parsed.command = "/system/bin/sh";
            } else {
              parsed.command = "/bin/sh";
            }
            parsed.args = ["-c", shellCommand];
          }
          return parsed;
        }
        function parse3(command, args, options) {
          if (args && !Array.isArray(args)) {
            options = args;
            args = null;
          }
          args = args ? args.slice(0) : [];
          options = Object.assign({}, options);
          const parsed = {
            command,
            args,
            options,
            file: void 0,
            original: {
              command,
              args
            }
          };
          return options.shell ? parseShell(parsed) : parseNonShell(parsed);
        }
        module2.exports = parse3;
      }
    });
    var require_enoent = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
        "use strict";
        var isWin2 = process.platform === "win32";
        function notFoundError(original, syscall) {
          return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
            code: "ENOENT",
            errno: "ENOENT",
            syscall: `${syscall} ${original.command}`,
            path: original.command,
            spawnargs: original.args
          });
        }
        function hookChildProcess(cp, parsed) {
          if (!isWin2) {
            return;
          }
          const originalEmit = cp.emit;
          cp.emit = function(name, arg1) {
            if (name === "exit") {
              const err = verifyENOENT(arg1, parsed, "spawn");
              if (err) {
                return originalEmit.call(cp, "error", err);
              }
            }
            return originalEmit.apply(cp, arguments);
          };
        }
        function verifyENOENT(status, parsed) {
          if (isWin2 && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, "spawn");
          }
          return null;
        }
        function verifyENOENTSync(status, parsed) {
          if (isWin2 && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, "spawnSync");
          }
          return null;
        }
        module2.exports = {
          hookChildProcess,
          verifyENOENT,
          verifyENOENTSync,
          notFoundError
        };
      }
    });
    var require_cross_spawn = __commonJS({
      "../../node_modules/.pnpm/cross-spawn@6.0.5/node_modules/cross-spawn/index.js"(exports2, module2) {
        "use strict";
        var cp = require("child_process");
        var parse3 = require_parse();
        var enoent = require_enoent();
        function spawn2(command, args, options) {
          const parsed = parse3(command, args, options);
          const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
          enoent.hookChildProcess(spawned, parsed);
          return spawned;
        }
        function spawnSync(command, args, options) {
          const parsed = parse3(command, args, options);
          const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
          result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
          return result;
        }
        module2.exports = spawn2;
        module2.exports.spawn = spawn2;
        module2.exports.sync = spawnSync;
        module2.exports._parse = parse3;
        module2.exports._enoent = enoent;
      }
    });
    var require_semver2 = __commonJS({
      "../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"(exports2, module2) {
        exports2 = module2.exports = SemVer2;
        var debug2;
        if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
          debug2 = function() {
            var args = Array.prototype.slice.call(arguments, 0);
            args.unshift("SEMVER");
            console.log.apply(console, args);
          };
        } else {
          debug2 = function() {
          };
        }
        exports2.SEMVER_SPEC_VERSION = "2.0.0";
        var MAX_LENGTH = 256;
        var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
        9007199254740991;
        var MAX_SAFE_COMPONENT_LENGTH = 16;
        var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
        var re = exports2.re = [];
        var safeRe = exports2.safeRe = [];
        var src = exports2.src = [];
        var t = exports2.tokens = {};
        var R = 0;
        function tok(n) {
          t[n] = R++;
        }
        var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
        var safeRegexReplacements = [
          ["\\s", 1],
          ["\\d", MAX_LENGTH],
          [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
        ];
        function makeSafeRe(value) {
          for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
            var token = safeRegexReplacements[i2][0];
            var max = safeRegexReplacements[i2][1];
            value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
          }
          return value;
        }
        tok("NUMERICIDENTIFIER");
        src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
        tok("NUMERICIDENTIFIERLOOSE");
        src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
        tok("NONNUMERICIDENTIFIER");
        src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
        tok("MAINVERSION");
        src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
        tok("MAINVERSIONLOOSE");
        src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
        tok("PRERELEASEIDENTIFIER");
        src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
        tok("PRERELEASEIDENTIFIERLOOSE");
        src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
        tok("PRERELEASE");
        src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
        tok("PRERELEASELOOSE");
        src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
        tok("BUILDIDENTIFIER");
        src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
        tok("BUILD");
        src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
        tok("FULL");
        tok("FULLPLAIN");
        src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
        src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
        tok("LOOSEPLAIN");
        src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
        tok("LOOSE");
        src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
        tok("GTLT");
        src[t.GTLT] = "((?:<|>)?=?)";
        tok("XRANGEIDENTIFIERLOOSE");
        src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
        tok("XRANGEIDENTIFIER");
        src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
        tok("XRANGEPLAIN");
        src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
        tok("XRANGEPLAINLOOSE");
        src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
        tok("XRANGE");
        src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
        tok("XRANGELOOSE");
        src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
        tok("COERCE");
        src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
        tok("COERCERTL");
        re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
        safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
        tok("LONETILDE");
        src[t.LONETILDE] = "(?:~>?)";
        tok("TILDETRIM");
        src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
        re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
        safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
        var tildeTrimReplace = "$1~";
        tok("TILDE");
        src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
        tok("TILDELOOSE");
        src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
        tok("LONECARET");
        src[t.LONECARET] = "(?:\\^)";
        tok("CARETTRIM");
        src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
        re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
        safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
        var caretTrimReplace = "$1^";
        tok("CARET");
        src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
        tok("CARETLOOSE");
        src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
        tok("COMPARATORLOOSE");
        src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
        tok("COMPARATOR");
        src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
        tok("COMPARATORTRIM");
        src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
        re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
        safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
        var comparatorTrimReplace = "$1$2$3";
        tok("HYPHENRANGE");
        src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
        tok("HYPHENRANGELOOSE");
        src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
        tok("STAR");
        src[t.STAR] = "(<|>)?=?\\s*\\*";
        for (i = 0; i < R; i++) {
          debug2(i, src[i]);
          if (!re[i]) {
            re[i] = new RegExp(src[i]);
            safeRe[i] = new RegExp(makeSafeRe(src[i]));
          }
        }
        var i;
        exports2.parse = parse3;
        function parse3(version, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (version instanceof SemVer2) {
            return version;
          }
          if (typeof version !== "string") {
            return null;
          }
          if (version.length > MAX_LENGTH) {
            return null;
          }
          var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
          if (!r.test(version)) {
            return null;
          }
          try {
            return new SemVer2(version, options);
          } catch (er) {
            return null;
          }
        }
        exports2.valid = valid;
        function valid(version, options) {
          var v = parse3(version, options);
          return v ? v.version : null;
        }
        exports2.clean = clean;
        function clean(version, options) {
          var s = parse3(version.trim().replace(/^[=v]+/, ""), options);
          return s ? s.version : null;
        }
        exports2.SemVer = SemVer2;
        function SemVer2(version, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (version instanceof SemVer2) {
            if (version.loose === options.loose) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== "string") {
            throw new TypeError("Invalid Version: " + version);
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
          }
          if (!(this instanceof SemVer2)) {
            return new SemVer2(version, options);
          }
          debug2("SemVer", version, options);
          this.options = options;
          this.loose = !!options.loose;
          var m = version.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
          if (!m) {
            throw new TypeError("Invalid Version: " + version);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map(function(id) {
              if (/^[0-9]+$/.test(id)) {
                var num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        SemVer2.prototype.format = function() {
          this.version = this.major + "." + this.minor + "." + this.patch;
          if (this.prerelease.length) {
            this.version += "-" + this.prerelease.join(".");
          }
          return this.version;
        };
        SemVer2.prototype.toString = function() {
          return this.version;
        };
        SemVer2.prototype.compare = function(other) {
          debug2("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          return this.compareMain(other) || this.comparePre(other);
        };
        SemVer2.prototype.compareMain = function(other) {
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        };
        SemVer2.prototype.comparePre = function(other) {
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          var i2 = 0;
          do {
            var a = this.prerelease[i2];
            var b = other.prerelease[i2];
            debug2("prerelease compare", i2, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i2);
        };
        SemVer2.prototype.compareBuild = function(other) {
          if (!(other instanceof SemVer2)) {
            other = new SemVer2(other, this.options);
          }
          var i2 = 0;
          do {
            var a = this.build[i2];
            var b = other.build[i2];
            debug2("prerelease compare", i2, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i2);
        };
        SemVer2.prototype.inc = function(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier);
              this.inc("pre", identifier);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier);
              }
              this.inc("pre", identifier);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                var i2 = this.prerelease.length;
                while (--i2 >= 0) {
                  if (typeof this.prerelease[i2] === "number") {
                    this.prerelease[i2]++;
                    i2 = -2;
                  }
                }
                if (i2 === -1) {
                  this.prerelease.push(0);
                }
              }
              if (identifier) {
                if (this.prerelease[0] === identifier) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }
              break;
            default:
              throw new Error("invalid increment argument: " + release);
          }
          this.format();
          this.raw = this.version;
          return this;
        };
        exports2.inc = inc;
        function inc(version, release, loose, identifier) {
          if (typeof loose === "string") {
            identifier = loose;
            loose = void 0;
          }
          try {
            return new SemVer2(version, loose).inc(release, identifier).version;
          } catch (er) {
            return null;
          }
        }
        exports2.diff = diff;
        function diff(version1, version2) {
          if (eq(version1, version2)) {
            return null;
          } else {
            var v1 = parse3(version1);
            var v2 = parse3(version2);
            var prefix = "";
            if (v1.prerelease.length || v2.prerelease.length) {
              prefix = "pre";
              var defaultResult = "prerelease";
            }
            for (var key in v1) {
              if (key === "major" || key === "minor" || key === "patch") {
                if (v1[key] !== v2[key]) {
                  return prefix + key;
                }
              }
            }
            return defaultResult;
          }
        }
        exports2.compareIdentifiers = compareIdentifiers;
        var numeric = /^[0-9]+$/;
        function compareIdentifiers(a, b) {
          var anum = numeric.test(a);
          var bnum = numeric.test(b);
          if (anum && bnum) {
            a = +a;
            b = +b;
          }
          return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
        }
        exports2.rcompareIdentifiers = rcompareIdentifiers;
        function rcompareIdentifiers(a, b) {
          return compareIdentifiers(b, a);
        }
        exports2.major = major;
        function major(a, loose) {
          return new SemVer2(a, loose).major;
        }
        exports2.minor = minor;
        function minor(a, loose) {
          return new SemVer2(a, loose).minor;
        }
        exports2.patch = patch;
        function patch(a, loose) {
          return new SemVer2(a, loose).patch;
        }
        exports2.compare = compare;
        function compare(a, b, loose) {
          return new SemVer2(a, loose).compare(new SemVer2(b, loose));
        }
        exports2.compareLoose = compareLoose;
        function compareLoose(a, b) {
          return compare(a, b, true);
        }
        exports2.compareBuild = compareBuild;
        function compareBuild(a, b, loose) {
          var versionA = new SemVer2(a, loose);
          var versionB = new SemVer2(b, loose);
          return versionA.compare(versionB) || versionA.compareBuild(versionB);
        }
        exports2.rcompare = rcompare;
        function rcompare(a, b, loose) {
          return compare(b, a, loose);
        }
        exports2.sort = sort;
        function sort(list, loose) {
          return list.sort(function(a, b) {
            return exports2.compareBuild(a, b, loose);
          });
        }
        exports2.rsort = rsort;
        function rsort(list, loose) {
          return list.sort(function(a, b) {
            return exports2.compareBuild(b, a, loose);
          });
        }
        exports2.gt = gt;
        function gt(a, b, loose) {
          return compare(a, b, loose) > 0;
        }
        exports2.lt = lt;
        function lt(a, b, loose) {
          return compare(a, b, loose) < 0;
        }
        exports2.eq = eq;
        function eq(a, b, loose) {
          return compare(a, b, loose) === 0;
        }
        exports2.neq = neq;
        function neq(a, b, loose) {
          return compare(a, b, loose) !== 0;
        }
        exports2.gte = gte2;
        function gte2(a, b, loose) {
          return compare(a, b, loose) >= 0;
        }
        exports2.lte = lte;
        function lte(a, b, loose) {
          return compare(a, b, loose) <= 0;
        }
        exports2.cmp = cmp;
        function cmp(a, op, b, loose) {
          switch (op) {
            case "===":
              if (typeof a === "object")
                a = a.version;
              if (typeof b === "object")
                b = b.version;
              return a === b;
            case "!==":
              if (typeof a === "object")
                a = a.version;
              if (typeof b === "object")
                b = b.version;
              return a !== b;
            case "":
            case "=":
            case "==":
              return eq(a, b, loose);
            case "!=":
              return neq(a, b, loose);
            case ">":
              return gt(a, b, loose);
            case ">=":
              return gte2(a, b, loose);
            case "<":
              return lt(a, b, loose);
            case "<=":
              return lte(a, b, loose);
            default:
              throw new TypeError("Invalid operator: " + op);
          }
        }
        exports2.Comparator = Comparator;
        function Comparator(comp, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          if (!(this instanceof Comparator)) {
            return new Comparator(comp, options);
          }
          comp = comp.trim().split(/\s+/).join(" ");
          debug2("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug2("comp", this);
        }
        var ANY = {};
        Comparator.prototype.parse = function(comp) {
          var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
          var m = comp.match(r);
          if (!m) {
            throw new TypeError("Invalid comparator: " + comp);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer2(m[2], this.options.loose);
          }
        };
        Comparator.prototype.toString = function() {
          return this.value;
        };
        Comparator.prototype.test = function(version) {
          debug2("Comparator.test", version, this.options.loose);
          if (this.semver === ANY || version === ANY) {
            return true;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer2(version, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version, this.operator, this.semver, this.options);
        };
        Comparator.prototype.intersects = function(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          var rangeTmp;
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            rangeTmp = new Range(comp.value, options);
            return satisfies2(this.value, rangeTmp, options);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            rangeTmp = new Range(this.value, options);
            return satisfies2(comp.semver, rangeTmp, options);
          }
          var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
          var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
          var sameSemVer = this.semver.version === comp.semver.version;
          var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
          var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
          var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        };
        exports2.Range = Range;
        function Range(range, options) {
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            return new Range(range.value, options);
          }
          if (!(this instanceof Range)) {
            return new Range(range, options);
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range.trim().split(/\s+/).join(" ");
          this.set = this.raw.split("||").map(function(range2) {
            return this.parseRange(range2.trim());
          }, this).filter(function(c) {
            return c.length;
          });
          if (!this.set.length) {
            throw new TypeError("Invalid SemVer Range: " + this.raw);
          }
          this.format();
        }
        Range.prototype.format = function() {
          this.range = this.set.map(function(comps) {
            return comps.join(" ").trim();
          }).join("||").trim();
          return this.range;
        };
        Range.prototype.toString = function() {
          return this.range;
        };
        Range.prototype.parseRange = function(range) {
          var loose = this.options.loose;
          var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace);
          debug2("hyphen replace", range);
          range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
          debug2("comparator trim", range, safeRe[t.COMPARATORTRIM]);
          range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
          range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
          range = range.split(/\s+/).join(" ");
          var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
          var set = range.split(" ").map(function(comp) {
            return parseComparator(comp, this.options);
          }, this).join(" ").split(/\s+/);
          if (this.options.loose) {
            set = set.filter(function(comp) {
              return !!comp.match(compRe);
            });
          }
          set = set.map(function(comp) {
            return new Comparator(comp, this.options);
          }, this);
          return set;
        };
        Range.prototype.intersects = function(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some(function(thisComparators) {
            return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
              return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
                return rangeComparators.every(function(rangeComparator) {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        };
        function isSatisfiable(comparators, options) {
          var result = true;
          var remainingComparators = comparators.slice();
          var testComparator = remainingComparators.pop();
          while (result && remainingComparators.length) {
            result = remainingComparators.every(function(otherComparator) {
              return testComparator.intersects(otherComparator, options);
            });
            testComparator = remainingComparators.pop();
          }
          return result;
        }
        exports2.toComparators = toComparators;
        function toComparators(range, options) {
          return new Range(range, options).set.map(function(comp) {
            return comp.map(function(c) {
              return c.value;
            }).join(" ").trim().split(" ");
          });
        }
        function parseComparator(comp, options) {
          debug2("comp", comp, options);
          comp = replaceCarets(comp, options);
          debug2("caret", comp);
          comp = replaceTildes(comp, options);
          debug2("tildes", comp);
          comp = replaceXRanges(comp, options);
          debug2("xrange", comp);
          comp = replaceStars(comp, options);
          debug2("stars", comp);
          return comp;
        }
        function isX(id) {
          return !id || id.toLowerCase() === "x" || id === "*";
        }
        function replaceTildes(comp, options) {
          return comp.trim().split(/\s+/).map(function(comp2) {
            return replaceTilde(comp2, options);
          }).join(" ");
        }
        function replaceTilde(comp, options) {
          var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
          return comp.replace(r, function(_, M, m, p, pr) {
            debug2("tilde", comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
              ret = "";
            } else if (isX(m)) {
              ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
            } else if (isX(p)) {
              ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
            } else if (pr) {
              debug2("replaceTilde pr", pr);
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
            debug2("tilde return", ret);
            return ret;
          });
        }
        function replaceCarets(comp, options) {
          return comp.trim().split(/\s+/).map(function(comp2) {
            return replaceCaret(comp2, options);
          }).join(" ");
        }
        function replaceCaret(comp, options) {
          debug2("caret", comp, options);
          var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
          return comp.replace(r, function(_, M, m, p, pr) {
            debug2("caret", comp, _, M, m, p, pr);
            var ret;
            if (isX(M)) {
              ret = "";
            } else if (isX(m)) {
              ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
            } else if (isX(p)) {
              if (M === "0") {
                ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
              } else {
                ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
              }
            } else if (pr) {
              debug2("replaceCaret pr", pr);
              if (M === "0") {
                if (m === "0") {
                  ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
                } else {
                  ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
                }
              } else {
                ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
              }
            } else {
              debug2("no pr");
              if (M === "0") {
                if (m === "0") {
                  ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
                } else {
                  ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
                }
              } else {
                ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
              }
            }
            debug2("caret return", ret);
            return ret;
          });
        }
        function replaceXRanges(comp, options) {
          debug2("replaceXRanges", comp, options);
          return comp.split(/\s+/).map(function(comp2) {
            return replaceXRange(comp2, options);
          }).join(" ");
        }
        function replaceXRange(comp, options) {
          comp = comp.trim();
          var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
          return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
            debug2("xRange", comp, ret, gtlt, M, m, p, pr);
            var xM = isX(M);
            var xm = xM || isX(m);
            var xp = xm || isX(p);
            var anyX = xp;
            if (gtlt === "=" && anyX) {
              gtlt = "";
            }
            pr = options.includePrerelease ? "-0" : "";
            if (xM) {
              if (gtlt === ">" || gtlt === "<") {
                ret = "<0.0.0-0";
              } else {
                ret = "*";
              }
            } else if (gtlt && anyX) {
              if (xm) {
                m = 0;
              }
              p = 0;
              if (gtlt === ">") {
                gtlt = ">=";
                if (xm) {
                  M = +M + 1;
                  m = 0;
                  p = 0;
                } else {
                  m = +m + 1;
                  p = 0;
                }
              } else if (gtlt === "<=") {
                gtlt = "<";
                if (xm) {
                  M = +M + 1;
                } else {
                  m = +m + 1;
                }
              }
              ret = gtlt + M + "." + m + "." + p + pr;
            } else if (xm) {
              ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
            } else if (xp) {
              ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
            }
            debug2("xRange return", ret);
            return ret;
          });
        }
        function replaceStars(comp, options) {
          debug2("replaceStars", comp, options);
          return comp.trim().replace(safeRe[t.STAR], "");
        }
        function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
          if (isX(fM)) {
            from = "";
          } else if (isX(fm)) {
            from = ">=" + fM + ".0.0";
          } else if (isX(fp)) {
            from = ">=" + fM + "." + fm + ".0";
          } else {
            from = ">=" + from;
          }
          if (isX(tM)) {
            to = "";
          } else if (isX(tm)) {
            to = "<" + (+tM + 1) + ".0.0";
          } else if (isX(tp)) {
            to = "<" + tM + "." + (+tm + 1) + ".0";
          } else if (tpr) {
            to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
          } else {
            to = "<=" + to;
          }
          return (from + " " + to).trim();
        }
        Range.prototype.test = function(version) {
          if (!version) {
            return false;
          }
          if (typeof version === "string") {
            try {
              version = new SemVer2(version, this.options);
            } catch (er) {
              return false;
            }
          }
          for (var i2 = 0; i2 < this.set.length; i2++) {
            if (testSet(this.set[i2], version, this.options)) {
              return true;
            }
          }
          return false;
        };
        function testSet(set, version, options) {
          for (var i2 = 0; i2 < set.length; i2++) {
            if (!set[i2].test(version)) {
              return false;
            }
          }
          if (version.prerelease.length && !options.includePrerelease) {
            for (i2 = 0; i2 < set.length; i2++) {
              debug2(set[i2].semver);
              if (set[i2].semver === ANY) {
                continue;
              }
              if (set[i2].semver.prerelease.length > 0) {
                var allowed = set[i2].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                  return true;
                }
              }
            }
            return false;
          }
          return true;
        }
        exports2.satisfies = satisfies2;
        function satisfies2(version, range, options) {
          try {
            range = new Range(range, options);
          } catch (er) {
            return false;
          }
          return range.test(version);
        }
        exports2.maxSatisfying = maxSatisfying;
        function maxSatisfying(versions, range, options) {
          var max = null;
          var maxSV = null;
          try {
            var rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          versions.forEach(function(v) {
            if (rangeObj.test(v)) {
              if (!max || maxSV.compare(v) === -1) {
                max = v;
                maxSV = new SemVer2(max, options);
              }
            }
          });
          return max;
        }
        exports2.minSatisfying = minSatisfying;
        function minSatisfying(versions, range, options) {
          var min = null;
          var minSV = null;
          try {
            var rangeObj = new Range(range, options);
          } catch (er) {
            return null;
          }
          versions.forEach(function(v) {
            if (rangeObj.test(v)) {
              if (!min || minSV.compare(v) === 1) {
                min = v;
                minSV = new SemVer2(min, options);
              }
            }
          });
          return min;
        }
        exports2.minVersion = minVersion2;
        function minVersion2(range, loose) {
          range = new Range(range, loose);
          var minver = new SemVer2("0.0.0");
          if (range.test(minver)) {
            return minver;
          }
          minver = new SemVer2("0.0.0-0");
          if (range.test(minver)) {
            return minver;
          }
          minver = null;
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            var comparators = range.set[i2];
            comparators.forEach(function(comparator) {
              var compver = new SemVer2(comparator.semver.version);
              switch (comparator.operator) {
                case ">":
                  if (compver.prerelease.length === 0) {
                    compver.patch++;
                  } else {
                    compver.prerelease.push(0);
                  }
                  compver.raw = compver.format();
                case "":
                case ">=":
                  if (!minver || gt(minver, compver)) {
                    minver = compver;
                  }
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw new Error("Unexpected operation: " + comparator.operator);
              }
            });
          }
          if (minver && range.test(minver)) {
            return minver;
          }
          return null;
        }
        exports2.validRange = validRange3;
        function validRange3(range, options) {
          try {
            return new Range(range, options).range || "*";
          } catch (er) {
            return null;
          }
        }
        exports2.ltr = ltr;
        function ltr(version, range, options) {
          return outside(version, range, "<", options);
        }
        exports2.gtr = gtr;
        function gtr(version, range, options) {
          return outside(version, range, ">", options);
        }
        exports2.outside = outside;
        function outside(version, range, hilo, options) {
          version = new SemVer2(version, options);
          range = new Range(range, options);
          var gtfn, ltefn, ltfn, comp, ecomp;
          switch (hilo) {
            case ">":
              gtfn = gt;
              ltefn = lte;
              ltfn = lt;
              comp = ">";
              ecomp = ">=";
              break;
            case "<":
              gtfn = lt;
              ltefn = gte2;
              ltfn = gt;
              comp = "<";
              ecomp = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"');
          }
          if (satisfies2(version, range, options)) {
            return false;
          }
          for (var i2 = 0; i2 < range.set.length; ++i2) {
            var comparators = range.set[i2];
            var high = null;
            var low = null;
            comparators.forEach(function(comparator) {
              if (comparator.semver === ANY) {
                comparator = new Comparator(">=0.0.0");
              }
              high = high || comparator;
              low = low || comparator;
              if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
              } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
              }
            });
            if (high.operator === comp || high.operator === ecomp) {
              return false;
            }
            if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
              return false;
            } else if (low.operator === ecomp && ltfn(version, low.semver)) {
              return false;
            }
          }
          return true;
        }
        exports2.prerelease = prerelease;
        function prerelease(version, options) {
          var parsed = parse3(version, options);
          return parsed && parsed.prerelease.length ? parsed.prerelease : null;
        }
        exports2.intersects = intersects3;
        function intersects3(r1, r2, options) {
          r1 = new Range(r1, options);
          r2 = new Range(r2, options);
          return r1.intersects(r2);
        }
        exports2.coerce = coerce2;
        function coerce2(version, options) {
          if (version instanceof SemVer2) {
            return version;
          }
          if (typeof version === "number") {
            version = String(version);
          }
          if (typeof version !== "string") {
            return null;
          }
          options = options || {};
          var match = null;
          if (!options.rtl) {
            match = version.match(safeRe[t.COERCE]);
          } else {
            var next;
            while ((next = safeRe[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
              if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
              }
              safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
            }
            safeRe[t.COERCERTL].lastIndex = -1;
          }
          if (match === null) {
            return null;
          }
          return parse3(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
        }
      }
    });
    var require_common2 = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/common.js"(exports2, module2) {
        "use strict";
        function isNothing(subject) {
          return typeof subject === "undefined" || subject === null;
        }
        function isObject(subject) {
          return typeof subject === "object" && subject !== null;
        }
        function toArray(sequence) {
          if (Array.isArray(sequence))
            return sequence;
          else if (isNothing(sequence))
            return [];
          return [sequence];
        }
        function extend(target, source) {
          var index, length, key, sourceKeys;
          if (source) {
            sourceKeys = Object.keys(source);
            for (index = 0, length = sourceKeys.length; index < length; index += 1) {
              key = sourceKeys[index];
              target[key] = source[key];
            }
          }
          return target;
        }
        function repeat(string, count) {
          var result = "", cycle;
          for (cycle = 0; cycle < count; cycle += 1) {
            result += string;
          }
          return result;
        }
        function isNegativeZero(number) {
          return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
        }
        module2.exports.isNothing = isNothing;
        module2.exports.isObject = isObject;
        module2.exports.toArray = toArray;
        module2.exports.repeat = repeat;
        module2.exports.isNegativeZero = isNegativeZero;
        module2.exports.extend = extend;
      }
    });
    var require_exception = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/exception.js"(exports2, module2) {
        "use strict";
        function YAMLException(reason, mark) {
          Error.call(this);
          this.name = "YAMLException";
          this.reason = reason;
          this.mark = mark;
          this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            this.stack = new Error().stack || "";
          }
        }
        YAMLException.prototype = Object.create(Error.prototype);
        YAMLException.prototype.constructor = YAMLException;
        YAMLException.prototype.toString = function toString(compact) {
          var result = this.name + ": ";
          result += this.reason || "(unknown reason)";
          if (!compact && this.mark) {
            result += " " + this.mark.toString();
          }
          return result;
        };
        module2.exports = YAMLException;
      }
    });
    var require_mark = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/mark.js"(exports2, module2) {
        "use strict";
        var common = require_common2();
        function Mark(name, buffer, position, line, column) {
          this.name = name;
          this.buffer = buffer;
          this.position = position;
          this.line = line;
          this.column = column;
        }
        Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
          var head, start, tail, end, snippet;
          if (!this.buffer)
            return null;
          indent = indent || 4;
          maxLength = maxLength || 75;
          head = "";
          start = this.position;
          while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
              head = " ... ";
              start += 5;
              break;
            }
          }
          tail = "";
          end = this.position;
          while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
              tail = " ... ";
              end -= 5;
              break;
            }
          }
          snippet = this.buffer.slice(start, end);
          return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
        };
        Mark.prototype.toString = function toString(compact) {
          var snippet, where = "";
          if (this.name) {
            where += 'in "' + this.name + '" ';
          }
          where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
          if (!compact) {
            snippet = this.getSnippet();
            if (snippet) {
              where += ":\n" + snippet;
            }
          }
          return where;
        };
        module2.exports = Mark;
      }
    });
    var require_type = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type.js"(exports2, module2) {
        "use strict";
        var YAMLException = require_exception();
        var TYPE_CONSTRUCTOR_OPTIONS = [
          "kind",
          "resolve",
          "construct",
          "instanceOf",
          "predicate",
          "represent",
          "defaultStyle",
          "styleAliases"
        ];
        var YAML_NODE_KINDS = [
          "scalar",
          "sequence",
          "mapping"
        ];
        function compileStyleAliases(map) {
          var result = {};
          if (map !== null) {
            Object.keys(map).forEach(function(style) {
              map[style].forEach(function(alias) {
                result[String(alias)] = style;
              });
            });
          }
          return result;
        }
        function Type(tag, options) {
          options = options || {};
          Object.keys(options).forEach(function(name) {
            if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
              throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
            }
          });
          this.tag = tag;
          this.kind = options["kind"] || null;
          this.resolve = options["resolve"] || function() {
            return true;
          };
          this.construct = options["construct"] || function(data) {
            return data;
          };
          this.instanceOf = options["instanceOf"] || null;
          this.predicate = options["predicate"] || null;
          this.represent = options["represent"] || null;
          this.defaultStyle = options["defaultStyle"] || null;
          this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
          if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
            throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
          }
        }
        module2.exports = Type;
      }
    });
    var require_schema = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/schema.js"(exports2, module2) {
        "use strict";
        var common = require_common2();
        var YAMLException = require_exception();
        var Type = require_type();
        function compileList(schema, name, result) {
          var exclude = [];
          schema.include.forEach(function(includedSchema) {
            result = compileList(includedSchema, name, result);
          });
          schema[name].forEach(function(currentType) {
            result.forEach(function(previousType, previousIndex) {
              if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
                exclude.push(previousIndex);
              }
            });
            result.push(currentType);
          });
          return result.filter(function(type, index) {
            return exclude.indexOf(index) === -1;
          });
        }
        function compileMap() {
          var result = {
            scalar: {},
            sequence: {},
            mapping: {},
            fallback: {}
          }, index, length;
          function collectType(type) {
            result[type.kind][type.tag] = result["fallback"][type.tag] = type;
          }
          for (index = 0, length = arguments.length; index < length; index += 1) {
            arguments[index].forEach(collectType);
          }
          return result;
        }
        function Schema(definition) {
          this.include = definition.include || [];
          this.implicit = definition.implicit || [];
          this.explicit = definition.explicit || [];
          this.implicit.forEach(function(type) {
            if (type.loadKind && type.loadKind !== "scalar") {
              throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
            }
          });
          this.compiledImplicit = compileList(this, "implicit", []);
          this.compiledExplicit = compileList(this, "explicit", []);
          this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
        }
        Schema.DEFAULT = null;
        Schema.create = function createSchema() {
          var schemas, types;
          switch (arguments.length) {
            case 1:
              schemas = Schema.DEFAULT;
              types = arguments[0];
              break;
            case 2:
              schemas = arguments[0];
              types = arguments[1];
              break;
            default:
              throw new YAMLException("Wrong number of arguments for Schema.create function");
          }
          schemas = common.toArray(schemas);
          types = common.toArray(types);
          if (!schemas.every(function(schema) {
            return schema instanceof Schema;
          })) {
            throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
          }
          if (!types.every(function(type) {
            return type instanceof Type;
          })) {
            throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
          }
          return new Schema({
            include: schemas,
            explicit: types
          });
        };
        module2.exports = Schema;
      }
    });
    var require_str = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        module2.exports = new Type("tag:yaml.org,2002:str", {
          kind: "scalar",
          construct: function(data) {
            return data !== null ? data : "";
          }
        });
      }
    });
    var require_seq = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        module2.exports = new Type("tag:yaml.org,2002:seq", {
          kind: "sequence",
          construct: function(data) {
            return data !== null ? data : [];
          }
        });
      }
    });
    var require_map = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        module2.exports = new Type("tag:yaml.org,2002:map", {
          kind: "mapping",
          construct: function(data) {
            return data !== null ? data : {};
          }
        });
      }
    });
    var require_failsafe = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports2, module2) {
        "use strict";
        var Schema = require_schema();
        module2.exports = new Schema({
          explicit: [
            require_str(),
            require_seq(),
            require_map()
          ]
        });
      }
    });
    var require_null = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        function resolveYamlNull(data) {
          if (data === null)
            return true;
          var max = data.length;
          return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
        }
        function constructYamlNull() {
          return null;
        }
        function isNull(object) {
          return object === null;
        }
        module2.exports = new Type("tag:yaml.org,2002:null", {
          kind: "scalar",
          resolve: resolveYamlNull,
          construct: constructYamlNull,
          predicate: isNull,
          represent: {
            canonical: function() {
              return "~";
            },
            lowercase: function() {
              return "null";
            },
            uppercase: function() {
              return "NULL";
            },
            camelcase: function() {
              return "Null";
            }
          },
          defaultStyle: "lowercase"
        });
      }
    });
    var require_bool = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        function resolveYamlBoolean(data) {
          if (data === null)
            return false;
          var max = data.length;
          return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
        }
        function constructYamlBoolean(data) {
          return data === "true" || data === "True" || data === "TRUE";
        }
        function isBoolean(object) {
          return Object.prototype.toString.call(object) === "[object Boolean]";
        }
        module2.exports = new Type("tag:yaml.org,2002:bool", {
          kind: "scalar",
          resolve: resolveYamlBoolean,
          construct: constructYamlBoolean,
          predicate: isBoolean,
          represent: {
            lowercase: function(object) {
              return object ? "true" : "false";
            },
            uppercase: function(object) {
              return object ? "TRUE" : "FALSE";
            },
            camelcase: function(object) {
              return object ? "True" : "False";
            }
          },
          defaultStyle: "lowercase"
        });
      }
    });
    var require_int = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports2, module2) {
        "use strict";
        var common = require_common2();
        var Type = require_type();
        function isHexCode(c) {
          return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
        }
        function isOctCode(c) {
          return 48 <= c && c <= 55;
        }
        function isDecCode(c) {
          return 48 <= c && c <= 57;
        }
        function resolveYamlInteger(data) {
          if (data === null)
            return false;
          var max = data.length, index = 0, hasDigits = false, ch;
          if (!max)
            return false;
          ch = data[index];
          if (ch === "-" || ch === "+") {
            ch = data[++index];
          }
          if (ch === "0") {
            if (index + 1 === max)
              return true;
            ch = data[++index];
            if (ch === "b") {
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_")
                  continue;
                if (ch !== "0" && ch !== "1")
                  return false;
                hasDigits = true;
              }
              return hasDigits && ch !== "_";
            }
            if (ch === "x") {
              index++;
              for (; index < max; index++) {
                ch = data[index];
                if (ch === "_")
                  continue;
                if (!isHexCode(data.charCodeAt(index)))
                  return false;
                hasDigits = true;
              }
              return hasDigits && ch !== "_";
            }
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_")
                continue;
              if (!isOctCode(data.charCodeAt(index)))
                return false;
              hasDigits = true;
            }
            return hasDigits && ch !== "_";
          }
          if (ch === "_")
            return false;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch === ":")
              break;
            if (!isDecCode(data.charCodeAt(index))) {
              return false;
            }
            hasDigits = true;
          }
          if (!hasDigits || ch === "_")
            return false;
          if (ch !== ":")
            return true;
          return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
        }
        function constructYamlInteger(data) {
          var value = data, sign = 1, ch, base, digits = [];
          if (value.indexOf("_") !== -1) {
            value = value.replace(/_/g, "");
          }
          ch = value[0];
          if (ch === "-" || ch === "+") {
            if (ch === "-")
              sign = -1;
            value = value.slice(1);
            ch = value[0];
          }
          if (value === "0")
            return 0;
          if (ch === "0") {
            if (value[1] === "b")
              return sign * parseInt(value.slice(2), 2);
            if (value[1] === "x")
              return sign * parseInt(value, 16);
            return sign * parseInt(value, 8);
          }
          if (value.indexOf(":") !== -1) {
            value.split(":").forEach(function(v) {
              digits.unshift(parseInt(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function(d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseInt(value, 10);
        }
        function isInteger2(object) {
          return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
        }
        module2.exports = new Type("tag:yaml.org,2002:int", {
          kind: "scalar",
          resolve: resolveYamlInteger,
          construct: constructYamlInteger,
          predicate: isInteger2,
          represent: {
            binary: function(obj) {
              return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
            },
            octal: function(obj) {
              return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
            },
            decimal: function(obj) {
              return obj.toString(10);
            },
            /* eslint-disable max-len */
            hexadecimal: function(obj) {
              return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
            }
          },
          defaultStyle: "decimal",
          styleAliases: {
            binary: [2, "bin"],
            octal: [8, "oct"],
            decimal: [10, "dec"],
            hexadecimal: [16, "hex"]
          }
        });
      }
    });
    var require_float = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports2, module2) {
        "use strict";
        var common = require_common2();
        var Type = require_type();
        var YAML_FLOAT_PATTERN = new RegExp(
          // 2.5e4, 2.5 and integers
          "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
        );
        function resolveYamlFloat(data) {
          if (data === null)
            return false;
          if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
          // Probably should update regexp & check speed
          data[data.length - 1] === "_") {
            return false;
          }
          return true;
        }
        function constructYamlFloat(data) {
          var value, sign, base, digits;
          value = data.replace(/_/g, "").toLowerCase();
          sign = value[0] === "-" ? -1 : 1;
          digits = [];
          if ("+-".indexOf(value[0]) >= 0) {
            value = value.slice(1);
          }
          if (value === ".inf") {
            return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
          } else if (value === ".nan") {
            return NaN;
          } else if (value.indexOf(":") >= 0) {
            value.split(":").forEach(function(v) {
              digits.unshift(parseFloat(v, 10));
            });
            value = 0;
            base = 1;
            digits.forEach(function(d) {
              value += d * base;
              base *= 60;
            });
            return sign * value;
          }
          return sign * parseFloat(value, 10);
        }
        var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
        function representYamlFloat(object, style) {
          var res;
          if (isNaN(object)) {
            switch (style) {
              case "lowercase":
                return ".nan";
              case "uppercase":
                return ".NAN";
              case "camelcase":
                return ".NaN";
            }
          } else if (Number.POSITIVE_INFINITY === object) {
            switch (style) {
              case "lowercase":
                return ".inf";
              case "uppercase":
                return ".INF";
              case "camelcase":
                return ".Inf";
            }
          } else if (Number.NEGATIVE_INFINITY === object) {
            switch (style) {
              case "lowercase":
                return "-.inf";
              case "uppercase":
                return "-.INF";
              case "camelcase":
                return "-.Inf";
            }
          } else if (common.isNegativeZero(object)) {
            return "-0.0";
          }
          res = object.toString(10);
          return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
        }
        function isFloat2(object) {
          return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
        }
        module2.exports = new Type("tag:yaml.org,2002:float", {
          kind: "scalar",
          resolve: resolveYamlFloat,
          construct: constructYamlFloat,
          predicate: isFloat2,
          represent: representYamlFloat,
          defaultStyle: "lowercase"
        });
      }
    });
    var require_json2 = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports2, module2) {
        "use strict";
        var Schema = require_schema();
        module2.exports = new Schema({
          include: [
            require_failsafe()
          ],
          implicit: [
            require_null(),
            require_bool(),
            require_int(),
            require_float()
          ]
        });
      }
    });
    var require_core = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports2, module2) {
        "use strict";
        var Schema = require_schema();
        module2.exports = new Schema({
          include: [
            require_json2()
          ]
        });
      }
    });
    var require_timestamp = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        var YAML_DATE_REGEXP = new RegExp(
          "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
        );
        var YAML_TIMESTAMP_REGEXP = new RegExp(
          "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
        );
        function resolveYamlTimestamp(data) {
          if (data === null)
            return false;
          if (YAML_DATE_REGEXP.exec(data) !== null)
            return true;
          if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
            return true;
          return false;
        }
        function constructYamlTimestamp(data) {
          var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
          match = YAML_DATE_REGEXP.exec(data);
          if (match === null)
            match = YAML_TIMESTAMP_REGEXP.exec(data);
          if (match === null)
            throw new Error("Date resolve error");
          year = +match[1];
          month = +match[2] - 1;
          day = +match[3];
          if (!match[4]) {
            return new Date(Date.UTC(year, month, day));
          }
          hour = +match[4];
          minute = +match[5];
          second = +match[6];
          if (match[7]) {
            fraction = match[7].slice(0, 3);
            while (fraction.length < 3) {
              fraction += "0";
            }
            fraction = +fraction;
          }
          if (match[9]) {
            tz_hour = +match[10];
            tz_minute = +(match[11] || 0);
            delta = (tz_hour * 60 + tz_minute) * 6e4;
            if (match[9] === "-")
              delta = -delta;
          }
          date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
          if (delta)
            date.setTime(date.getTime() - delta);
          return date;
        }
        function representYamlTimestamp(object) {
          return object.toISOString();
        }
        module2.exports = new Type("tag:yaml.org,2002:timestamp", {
          kind: "scalar",
          resolve: resolveYamlTimestamp,
          construct: constructYamlTimestamp,
          instanceOf: Date,
          represent: representYamlTimestamp
        });
      }
    });
    var require_merge = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        function resolveYamlMerge(data) {
          return data === "<<" || data === null;
        }
        module2.exports = new Type("tag:yaml.org,2002:merge", {
          kind: "scalar",
          resolve: resolveYamlMerge
        });
      }
    });
    var require_binary = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports2, module2) {
        "use strict";
        var NodeBuffer;
        try {
          _require = require;
          NodeBuffer = _require("buffer").Buffer;
        } catch (__) {
        }
        var _require;
        var Type = require_type();
        var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
        function resolveYamlBinary(data) {
          if (data === null)
            return false;
          var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
          for (idx = 0; idx < max; idx++) {
            code = map.indexOf(data.charAt(idx));
            if (code > 64)
              continue;
            if (code < 0)
              return false;
            bitlen += 6;
          }
          return bitlen % 8 === 0;
        }
        function constructYamlBinary(data) {
          var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
          for (idx = 0; idx < max; idx++) {
            if (idx % 4 === 0 && idx) {
              result.push(bits >> 16 & 255);
              result.push(bits >> 8 & 255);
              result.push(bits & 255);
            }
            bits = bits << 6 | map.indexOf(input.charAt(idx));
          }
          tailbits = max % 4 * 6;
          if (tailbits === 0) {
            result.push(bits >> 16 & 255);
            result.push(bits >> 8 & 255);
            result.push(bits & 255);
          } else if (tailbits === 18) {
            result.push(bits >> 10 & 255);
            result.push(bits >> 2 & 255);
          } else if (tailbits === 12) {
            result.push(bits >> 4 & 255);
          }
          if (NodeBuffer) {
            return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
          }
          return result;
        }
        function representYamlBinary(object) {
          var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
          for (idx = 0; idx < max; idx++) {
            if (idx % 3 === 0 && idx) {
              result += map[bits >> 18 & 63];
              result += map[bits >> 12 & 63];
              result += map[bits >> 6 & 63];
              result += map[bits & 63];
            }
            bits = (bits << 8) + object[idx];
          }
          tail = max % 3;
          if (tail === 0) {
            result += map[bits >> 18 & 63];
            result += map[bits >> 12 & 63];
            result += map[bits >> 6 & 63];
            result += map[bits & 63];
          } else if (tail === 2) {
            result += map[bits >> 10 & 63];
            result += map[bits >> 4 & 63];
            result += map[bits << 2 & 63];
            result += map[64];
          } else if (tail === 1) {
            result += map[bits >> 2 & 63];
            result += map[bits << 4 & 63];
            result += map[64];
            result += map[64];
          }
          return result;
        }
        function isBinary(object) {
          return NodeBuffer && NodeBuffer.isBuffer(object);
        }
        module2.exports = new Type("tag:yaml.org,2002:binary", {
          kind: "scalar",
          resolve: resolveYamlBinary,
          construct: constructYamlBinary,
          predicate: isBinary,
          represent: representYamlBinary
        });
      }
    });
    var require_omap = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var _toString = Object.prototype.toString;
        function resolveYamlOmap(data) {
          if (data === null)
            return true;
          var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            pairHasKey = false;
            if (_toString.call(pair) !== "[object Object]")
              return false;
            for (pairKey in pair) {
              if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey)
                  pairHasKey = true;
                else
                  return false;
              }
            }
            if (!pairHasKey)
              return false;
            if (objectKeys.indexOf(pairKey) === -1)
              objectKeys.push(pairKey);
            else
              return false;
          }
          return true;
        }
        function constructYamlOmap(data) {
          return data !== null ? data : [];
        }
        module2.exports = new Type("tag:yaml.org,2002:omap", {
          kind: "sequence",
          resolve: resolveYamlOmap,
          construct: constructYamlOmap
        });
      }
    });
    var require_pairs = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        var _toString = Object.prototype.toString;
        function resolveYamlPairs(data) {
          if (data === null)
            return true;
          var index, length, pair, keys, result, object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            if (_toString.call(pair) !== "[object Object]")
              return false;
            keys = Object.keys(pair);
            if (keys.length !== 1)
              return false;
            result[index] = [keys[0], pair[keys[0]]];
          }
          return true;
        }
        function constructYamlPairs(data) {
          if (data === null)
            return [];
          var index, length, pair, keys, result, object = data;
          result = new Array(object.length);
          for (index = 0, length = object.length; index < length; index += 1) {
            pair = object[index];
            keys = Object.keys(pair);
            result[index] = [keys[0], pair[keys[0]]];
          }
          return result;
        }
        module2.exports = new Type("tag:yaml.org,2002:pairs", {
          kind: "sequence",
          resolve: resolveYamlPairs,
          construct: constructYamlPairs
        });
      }
    });
    var require_set = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        function resolveYamlSet(data) {
          if (data === null)
            return true;
          var key, object = data;
          for (key in object) {
            if (_hasOwnProperty.call(object, key)) {
              if (object[key] !== null)
                return false;
            }
          }
          return true;
        }
        function constructYamlSet(data) {
          return data !== null ? data : {};
        }
        module2.exports = new Type("tag:yaml.org,2002:set", {
          kind: "mapping",
          resolve: resolveYamlSet,
          construct: constructYamlSet
        });
      }
    });
    var require_default_safe = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports2, module2) {
        "use strict";
        var Schema = require_schema();
        module2.exports = new Schema({
          include: [
            require_core()
          ],
          implicit: [
            require_timestamp(),
            require_merge()
          ],
          explicit: [
            require_binary(),
            require_omap(),
            require_pairs(),
            require_set()
          ]
        });
      }
    });
    var require_undefined = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        function resolveJavascriptUndefined() {
          return true;
        }
        function constructJavascriptUndefined() {
          return void 0;
        }
        function representJavascriptUndefined() {
          return "";
        }
        function isUndefined(object) {
          return typeof object === "undefined";
        }
        module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
          kind: "scalar",
          resolve: resolveJavascriptUndefined,
          construct: constructJavascriptUndefined,
          predicate: isUndefined,
          represent: representJavascriptUndefined
        });
      }
    });
    var require_regexp = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports2, module2) {
        "use strict";
        var Type = require_type();
        function resolveJavascriptRegExp(data) {
          if (data === null)
            return false;
          if (data.length === 0)
            return false;
          var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
          if (regexp[0] === "/") {
            if (tail)
              modifiers = tail[1];
            if (modifiers.length > 3)
              return false;
            if (regexp[regexp.length - modifiers.length - 1] !== "/")
              return false;
          }
          return true;
        }
        function constructJavascriptRegExp(data) {
          var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
          if (regexp[0] === "/") {
            if (tail)
              modifiers = tail[1];
            regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
          }
          return new RegExp(regexp, modifiers);
        }
        function representJavascriptRegExp(object) {
          var result = "/" + object.source + "/";
          if (object.global)
            result += "g";
          if (object.multiline)
            result += "m";
          if (object.ignoreCase)
            result += "i";
          return result;
        }
        function isRegExp(object) {
          return Object.prototype.toString.call(object) === "[object RegExp]";
        }
        module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
          kind: "scalar",
          resolve: resolveJavascriptRegExp,
          construct: constructJavascriptRegExp,
          predicate: isRegExp,
          represent: representJavascriptRegExp
        });
      }
    });
    var require_function = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports2, module2) {
        "use strict";
        var esprima;
        try {
          _require = require;
          esprima = _require("esprima");
        } catch (_) {
          if (typeof window !== "undefined")
            esprima = window.esprima;
        }
        var _require;
        var Type = require_type();
        function resolveJavascriptFunction(data) {
          if (data === null)
            return false;
          try {
            var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
            if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        function constructJavascriptFunction(data) {
          var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
          if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
            throw new Error("Failed to resolve function");
          }
          ast.body[0].expression.params.forEach(function(param) {
            params.push(param.name);
          });
          body = ast.body[0].expression.body.range;
          if (ast.body[0].expression.body.type === "BlockStatement") {
            return new Function(params, source.slice(body[0] + 1, body[1] - 1));
          }
          return new Function(params, "return " + source.slice(body[0], body[1]));
        }
        function representJavascriptFunction(object) {
          return object.toString();
        }
        function isFunction(object) {
          return Object.prototype.toString.call(object) === "[object Function]";
        }
        module2.exports = new Type("tag:yaml.org,2002:js/function", {
          kind: "scalar",
          resolve: resolveJavascriptFunction,
          construct: constructJavascriptFunction,
          predicate: isFunction,
          represent: representJavascriptFunction
        });
      }
    });
    var require_default_full = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports2, module2) {
        "use strict";
        var Schema = require_schema();
        module2.exports = Schema.DEFAULT = new Schema({
          include: [
            require_default_safe()
          ],
          explicit: [
            require_undefined(),
            require_regexp(),
            require_function()
          ]
        });
      }
    });
    var require_loader = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/loader.js"(exports2, module2) {
        "use strict";
        var common = require_common2();
        var YAMLException = require_exception();
        var Mark = require_mark();
        var DEFAULT_SAFE_SCHEMA = require_default_safe();
        var DEFAULT_FULL_SCHEMA = require_default_full();
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CONTEXT_FLOW_IN = 1;
        var CONTEXT_FLOW_OUT = 2;
        var CONTEXT_BLOCK_IN = 3;
        var CONTEXT_BLOCK_OUT = 4;
        var CHOMPING_CLIP = 1;
        var CHOMPING_STRIP = 2;
        var CHOMPING_KEEP = 3;
        var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
        var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
        var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
        var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
        function _class(obj) {
          return Object.prototype.toString.call(obj);
        }
        function is_EOL(c) {
          return c === 10 || c === 13;
        }
        function is_WHITE_SPACE(c) {
          return c === 9 || c === 32;
        }
        function is_WS_OR_EOL(c) {
          return c === 9 || c === 32 || c === 10 || c === 13;
        }
        function is_FLOW_INDICATOR(c) {
          return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
        }
        function fromHexCode(c) {
          var lc;
          if (48 <= c && c <= 57) {
            return c - 48;
          }
          lc = c | 32;
          if (97 <= lc && lc <= 102) {
            return lc - 97 + 10;
          }
          return -1;
        }
        function escapedHexLen(c) {
          if (c === 120) {
            return 2;
          }
          if (c === 117) {
            return 4;
          }
          if (c === 85) {
            return 8;
          }
          return 0;
        }
        function fromDecimalCode(c) {
          if (48 <= c && c <= 57) {
            return c - 48;
          }
          return -1;
        }
        function simpleEscapeSequence(c) {
          return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
        }
        function charFromCodepoint(c) {
          if (c <= 65535) {
            return String.fromCharCode(c);
          }
          return String.fromCharCode(
            (c - 65536 >> 10) + 55296,
            (c - 65536 & 1023) + 56320
          );
        }
        var simpleEscapeCheck = new Array(256);
        var simpleEscapeMap = new Array(256);
        for (i = 0; i < 256; i++) {
          simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
          simpleEscapeMap[i] = simpleEscapeSequence(i);
        }
        var i;
        function State(input, options) {
          this.input = input;
          this.filename = options["filename"] || null;
          this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
          this.onWarning = options["onWarning"] || null;
          this.legacy = options["legacy"] || false;
          this.json = options["json"] || false;
          this.listener = options["listener"] || null;
          this.implicitTypes = this.schema.compiledImplicit;
          this.typeMap = this.schema.compiledTypeMap;
          this.length = input.length;
          this.position = 0;
          this.line = 0;
          this.lineStart = 0;
          this.lineIndent = 0;
          this.documents = [];
        }
        function generateError(state, message) {
          return new YAMLException(
            message,
            new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
          );
        }
        function throwError(state, message) {
          throw generateError(state, message);
        }
        function throwWarning(state, message) {
          if (state.onWarning) {
            state.onWarning.call(null, generateError(state, message));
          }
        }
        var directiveHandlers = {
          YAML: function handleYamlDirective(state, name, args) {
            var match, major, minor;
            if (state.version !== null) {
              throwError(state, "duplication of %YAML directive");
            }
            if (args.length !== 1) {
              throwError(state, "YAML directive accepts exactly one argument");
            }
            match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
            if (match === null) {
              throwError(state, "ill-formed argument of the YAML directive");
            }
            major = parseInt(match[1], 10);
            minor = parseInt(match[2], 10);
            if (major !== 1) {
              throwError(state, "unacceptable YAML version of the document");
            }
            state.version = args[0];
            state.checkLineBreaks = minor < 2;
            if (minor !== 1 && minor !== 2) {
              throwWarning(state, "unsupported YAML version of the document");
            }
          },
          TAG: function handleTagDirective(state, name, args) {
            var handle, prefix;
            if (args.length !== 2) {
              throwError(state, "TAG directive accepts exactly two arguments");
            }
            handle = args[0];
            prefix = args[1];
            if (!PATTERN_TAG_HANDLE.test(handle)) {
              throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
            }
            if (_hasOwnProperty.call(state.tagMap, handle)) {
              throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
            }
            if (!PATTERN_TAG_URI.test(prefix)) {
              throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
            }
            state.tagMap[handle] = prefix;
          }
        };
        function captureSegment(state, start, end, checkJson) {
          var _position, _length, _character, _result;
          if (start < end) {
            _result = state.input.slice(start, end);
            if (checkJson) {
              for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                  throwError(state, "expected valid JSON character");
                }
              }
            } else if (PATTERN_NON_PRINTABLE.test(_result)) {
              throwError(state, "the stream contains non-printable characters");
            }
            state.result += _result;
          }
        }
        function mergeMappings(state, destination, source, overridableKeys) {
          var sourceKeys, key, index, quantity;
          if (!common.isObject(source)) {
            throwError(state, "cannot merge mappings; the provided source object is unacceptable");
          }
          sourceKeys = Object.keys(source);
          for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
            key = sourceKeys[index];
            if (!_hasOwnProperty.call(destination, key)) {
              destination[key] = source[key];
              overridableKeys[key] = true;
            }
          }
        }
        function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
          var index, quantity;
          if (Array.isArray(keyNode)) {
            keyNode = Array.prototype.slice.call(keyNode);
            for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
              if (Array.isArray(keyNode[index])) {
                throwError(state, "nested arrays are not supported inside keys");
              }
              if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                keyNode[index] = "[object Object]";
              }
            }
          }
          if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
            keyNode = "[object Object]";
          }
          keyNode = String(keyNode);
          if (_result === null) {
            _result = {};
          }
          if (keyTag === "tag:yaml.org,2002:merge") {
            if (Array.isArray(valueNode)) {
              for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                mergeMappings(state, _result, valueNode[index], overridableKeys);
              }
            } else {
              mergeMappings(state, _result, valueNode, overridableKeys);
            }
          } else {
            if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
              state.line = startLine || state.line;
              state.position = startPos || state.position;
              throwError(state, "duplicated mapping key");
            }
            _result[keyNode] = valueNode;
            delete overridableKeys[keyNode];
          }
          return _result;
        }
        function readLineBreak(state) {
          var ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 10) {
            state.position++;
          } else if (ch === 13) {
            state.position++;
            if (state.input.charCodeAt(state.position) === 10) {
              state.position++;
            }
          } else {
            throwError(state, "a line break is expected");
          }
          state.line += 1;
          state.lineStart = state.position;
        }
        function skipSeparationSpace(state, allowComments, checkIndent) {
          var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (allowComments && ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 10 && ch !== 13 && ch !== 0);
            }
            if (is_EOL(ch)) {
              readLineBreak(state);
              ch = state.input.charCodeAt(state.position);
              lineBreaks++;
              state.lineIndent = 0;
              while (ch === 32) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
            } else {
              break;
            }
          }
          if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
            throwWarning(state, "deficient indentation");
          }
          return lineBreaks;
        }
        function testDocumentSeparator(state) {
          var _position = state.position, ch;
          ch = state.input.charCodeAt(_position);
          if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
            _position += 3;
            ch = state.input.charCodeAt(_position);
            if (ch === 0 || is_WS_OR_EOL(ch)) {
              return true;
            }
          }
          return false;
        }
        function writeFoldedLines(state, count) {
          if (count === 1) {
            state.result += " ";
          } else if (count > 1) {
            state.result += common.repeat("\n", count - 1);
          }
        }
        function readPlainScalar(state, nodeIndent, withinFlowCollection) {
          var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
          ch = state.input.charCodeAt(state.position);
          if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
            return false;
          }
          if (ch === 63 || ch === 45) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
              return false;
            }
          }
          state.kind = "scalar";
          state.result = "";
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
          while (ch !== 0) {
            if (ch === 58) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                break;
              }
            } else if (ch === 35) {
              preceding = state.input.charCodeAt(state.position - 1);
              if (is_WS_OR_EOL(preceding)) {
                break;
              }
            } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
              break;
            } else if (is_EOL(ch)) {
              _line = state.line;
              _lineStart = state.lineStart;
              _lineIndent = state.lineIndent;
              skipSeparationSpace(state, false, -1);
              if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
              } else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
              }
            }
            if (hasPendingContent) {
              captureSegment(state, captureStart, captureEnd, false);
              writeFoldedLines(state, state.line - _line);
              captureStart = captureEnd = state.position;
              hasPendingContent = false;
            }
            if (!is_WHITE_SPACE(ch)) {
              captureEnd = state.position + 1;
            }
            ch = state.input.charCodeAt(++state.position);
          }
          captureSegment(state, captureStart, captureEnd, false);
          if (state.result) {
            return true;
          }
          state.kind = _kind;
          state.result = _result;
          return false;
        }
        function readSingleQuotedScalar(state, nodeIndent) {
          var ch, captureStart, captureEnd;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 39) {
            return false;
          }
          state.kind = "scalar";
          state.result = "";
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 39) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (ch === 39) {
                captureStart = state.position;
                state.position++;
                captureEnd = state.position;
              } else {
                return true;
              }
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, "unexpected end of the document within a single quoted scalar");
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, "unexpected end of the stream within a single quoted scalar");
        }
        function readDoubleQuotedScalar(state, nodeIndent) {
          var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 34) {
            return false;
          }
          state.kind = "scalar";
          state.result = "";
          state.position++;
          captureStart = captureEnd = state.position;
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            if (ch === 34) {
              captureSegment(state, captureStart, state.position, true);
              state.position++;
              return true;
            } else if (ch === 92) {
              captureSegment(state, captureStart, state.position, true);
              ch = state.input.charCodeAt(++state.position);
              if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);
              } else if (ch < 256 && simpleEscapeCheck[ch]) {
                state.result += simpleEscapeMap[ch];
                state.position++;
              } else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for (; hexLength > 0; hexLength--) {
                  ch = state.input.charCodeAt(++state.position);
                  if ((tmp = fromHexCode(ch)) >= 0) {
                    hexResult = (hexResult << 4) + tmp;
                  } else {
                    throwError(state, "expected hexadecimal character");
                  }
                }
                state.result += charFromCodepoint(hexResult);
                state.position++;
              } else {
                throwError(state, "unknown escape sequence");
              }
              captureStart = captureEnd = state.position;
            } else if (is_EOL(ch)) {
              captureSegment(state, captureStart, captureEnd, true);
              writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
              captureStart = captureEnd = state.position;
            } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
              throwError(state, "unexpected end of the document within a double quoted scalar");
            } else {
              state.position++;
              captureEnd = state.position;
            }
          }
          throwError(state, "unexpected end of the stream within a double quoted scalar");
        }
        function readFlowCollection(state, nodeIndent) {
          var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 91) {
            terminator = 93;
            isMapping = false;
            _result = [];
          } else if (ch === 123) {
            terminator = 125;
            isMapping = true;
            _result = {};
          } else {
            return false;
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(++state.position);
          while (ch !== 0) {
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === terminator) {
              state.position++;
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = isMapping ? "mapping" : "sequence";
              state.result = _result;
              return true;
            } else if (!readNext) {
              throwError(state, "missed comma between flow collection entries");
            }
            keyTag = keyNode = valueNode = null;
            isPair = isExplicitPair = false;
            if (ch === 63) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            keyTag = state.tag;
            keyNode = state.result;
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if ((isExplicitPair || state.line === _line) && ch === 58) {
              isPair = true;
              ch = state.input.charCodeAt(++state.position);
              skipSeparationSpace(state, true, nodeIndent);
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              valueNode = state.result;
            }
            if (isMapping) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
            } else if (isPair) {
              _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
            } else {
              _result.push(keyNode);
            }
            skipSeparationSpace(state, true, nodeIndent);
            ch = state.input.charCodeAt(state.position);
            if (ch === 44) {
              readNext = true;
              ch = state.input.charCodeAt(++state.position);
            } else {
              readNext = false;
            }
          }
          throwError(state, "unexpected end of the stream within a flow collection");
        }
        function readBlockScalar(state, nodeIndent) {
          var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch === 124) {
            folding = false;
          } else if (ch === 62) {
            folding = true;
          } else {
            return false;
          }
          state.kind = "scalar";
          state.result = "";
          while (ch !== 0) {
            ch = state.input.charCodeAt(++state.position);
            if (ch === 43 || ch === 45) {
              if (CHOMPING_CLIP === chomping) {
                chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
              } else {
                throwError(state, "repeat of a chomping mode identifier");
              }
            } else if ((tmp = fromDecimalCode(ch)) >= 0) {
              if (tmp === 0) {
                throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
              } else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
              } else {
                throwError(state, "repeat of an indentation width identifier");
              }
            } else {
              break;
            }
          }
          if (is_WHITE_SPACE(ch)) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (is_WHITE_SPACE(ch));
            if (ch === 35) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (!is_EOL(ch) && ch !== 0);
            }
          }
          while (ch !== 0) {
            readLineBreak(state);
            state.lineIndent = 0;
            ch = state.input.charCodeAt(state.position);
            while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
              state.lineIndent++;
              ch = state.input.charCodeAt(++state.position);
            }
            if (!detectedIndent && state.lineIndent > textIndent) {
              textIndent = state.lineIndent;
            }
            if (is_EOL(ch)) {
              emptyLines++;
              continue;
            }
            if (state.lineIndent < textIndent) {
              if (chomping === CHOMPING_KEEP) {
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
              } else if (chomping === CHOMPING_CLIP) {
                if (didReadContent) {
                  state.result += "\n";
                }
              }
              break;
            }
            if (folding) {
              if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
              } else if (atMoreIndented) {
                atMoreIndented = false;
                state.result += common.repeat("\n", emptyLines + 1);
              } else if (emptyLines === 0) {
                if (didReadContent) {
                  state.result += " ";
                }
              } else {
                state.result += common.repeat("\n", emptyLines);
              }
            } else {
              state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
            }
            didReadContent = true;
            detectedIndent = true;
            emptyLines = 0;
            captureStart = state.position;
            while (!is_EOL(ch) && ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, state.position, false);
          }
          return true;
        }
        function readBlockSequence(state, nodeIndent) {
          var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            if (ch !== 45) {
              break;
            }
            following = state.input.charCodeAt(state.position + 1);
            if (!is_WS_OR_EOL(following)) {
              break;
            }
            detected = true;
            state.position++;
            if (skipSeparationSpace(state, true, -1)) {
              if (state.lineIndent <= nodeIndent) {
                _result.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
              }
            }
            _line = state.line;
            composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
            _result.push(state.result);
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
              throwError(state, "bad indentation of a sequence entry");
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = "sequence";
            state.result = _result;
            return true;
          }
          return false;
        }
        function readBlockMapping(state, nodeIndent, flowIndent) {
          var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = _result;
          }
          ch = state.input.charCodeAt(state.position);
          while (ch !== 0) {
            following = state.input.charCodeAt(state.position + 1);
            _line = state.line;
            _pos = state.position;
            if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
              if (ch === 63) {
                if (atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                  keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
              } else if (atExplicitKey) {
                atExplicitKey = false;
                allowCompact = true;
              } else {
                throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
              }
              state.position += 1;
              ch = following;
            } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
              if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 58) {
                  ch = state.input.charCodeAt(++state.position);
                  if (!is_WS_OR_EOL(ch)) {
                    throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                  }
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = false;
                  allowCompact = false;
                  keyTag = state.tag;
                  keyNode = state.result;
                } else if (detected) {
                  throwError(state, "can not read an implicit mapping pair; a colon is missed");
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;
                }
              } else if (detected) {
                throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
              } else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true;
              }
            } else {
              break;
            }
            if (state.line === _line || state.lineIndent > nodeIndent) {
              if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                  keyNode = state.result;
                } else {
                  valueNode = state.result;
                }
              }
              if (!atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
                keyTag = keyNode = valueNode = null;
              }
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
            }
            if (state.lineIndent > nodeIndent && ch !== 0) {
              throwError(state, "bad indentation of a mapping entry");
            } else if (state.lineIndent < nodeIndent) {
              break;
            }
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          }
          if (detected) {
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = "mapping";
            state.result = _result;
          }
          return detected;
        }
        function readTagProperty(state) {
          var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 33)
            return false;
          if (state.tag !== null) {
            throwError(state, "duplication of a tag property");
          }
          ch = state.input.charCodeAt(++state.position);
          if (ch === 60) {
            isVerbatim = true;
            ch = state.input.charCodeAt(++state.position);
          } else if (ch === 33) {
            isNamed = true;
            tagHandle = "!!";
            ch = state.input.charCodeAt(++state.position);
          } else {
            tagHandle = "!";
          }
          _position = state.position;
          if (isVerbatim) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && ch !== 62);
            if (state.position < state.length) {
              tagName = state.input.slice(_position, state.position);
              ch = state.input.charCodeAt(++state.position);
            } else {
              throwError(state, "unexpected end of the stream within a verbatim tag");
            }
          } else {
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              if (ch === 33) {
                if (!isNamed) {
                  tagHandle = state.input.slice(_position - 1, state.position + 1);
                  if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                    throwError(state, "named tag handle cannot contain such characters");
                  }
                  isNamed = true;
                  _position = state.position + 1;
                } else {
                  throwError(state, "tag suffix cannot contain exclamation marks");
                }
              }
              ch = state.input.charCodeAt(++state.position);
            }
            tagName = state.input.slice(_position, state.position);
            if (PATTERN_FLOW_INDICATORS.test(tagName)) {
              throwError(state, "tag suffix cannot contain flow indicator characters");
            }
          }
          if (tagName && !PATTERN_TAG_URI.test(tagName)) {
            throwError(state, "tag name cannot contain such characters: " + tagName);
          }
          if (isVerbatim) {
            state.tag = tagName;
          } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
            state.tag = state.tagMap[tagHandle] + tagName;
          } else if (tagHandle === "!") {
            state.tag = "!" + tagName;
          } else if (tagHandle === "!!") {
            state.tag = "tag:yaml.org,2002:" + tagName;
          } else {
            throwError(state, 'undeclared tag handle "' + tagHandle + '"');
          }
          return true;
        }
        function readAnchorProperty(state) {
          var _position, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 38)
            return false;
          if (state.anchor !== null) {
            throwError(state, "duplication of an anchor property");
          }
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, "name of an anchor node must contain at least one character");
          }
          state.anchor = state.input.slice(_position, state.position);
          return true;
        }
        function readAlias(state) {
          var _position, alias, ch;
          ch = state.input.charCodeAt(state.position);
          if (ch !== 42)
            return false;
          ch = state.input.charCodeAt(++state.position);
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (state.position === _position) {
            throwError(state, "name of an alias node must contain at least one character");
          }
          alias = state.input.slice(_position, state.position);
          if (!state.anchorMap.hasOwnProperty(alias)) {
            throwError(state, 'unidentified alias "' + alias + '"');
          }
          state.result = state.anchorMap[alias];
          skipSeparationSpace(state, true, -1);
          return true;
        }
        function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
          var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
          if (state.listener !== null) {
            state.listener("open", state);
          }
          state.tag = null;
          state.anchor = null;
          state.kind = null;
          state.result = null;
          allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
          if (allowToSeek) {
            if (skipSeparationSpace(state, true, -1)) {
              atNewLine = true;
              if (state.lineIndent > parentIndent) {
                indentStatus = 1;
              } else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
              } else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
              }
            }
          }
          if (indentStatus === 1) {
            while (readTagProperty(state) || readAnchorProperty(state)) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              } else {
                allowBlockCollections = false;
              }
            }
          }
          if (allowBlockCollections) {
            allowBlockCollections = atNewLine || allowCompact;
          }
          if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
            if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
              flowIndent = parentIndent;
            } else {
              flowIndent = parentIndent + 1;
            }
            blockIndent = state.position - state.lineStart;
            if (indentStatus === 1) {
              if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                hasContent = true;
              } else {
                if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                  hasContent = true;
                } else if (readAlias(state)) {
                  hasContent = true;
                  if (state.tag !== null || state.anchor !== null) {
                    throwError(state, "alias node should not have any properties");
                  }
                } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                  hasContent = true;
                  if (state.tag === null) {
                    state.tag = "?";
                  }
                }
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else if (indentStatus === 0) {
              hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
            }
          }
          if (state.tag !== null && state.tag !== "!") {
            if (state.tag === "?") {
              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
              type = state.typeMap[state.kind || "fallback"][state.tag];
              if (state.result !== null && type.kind !== state.kind) {
                throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
              }
              if (!type.resolve(state.result)) {
                throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
              } else {
                state.result = type.construct(state.result);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            } else {
              throwError(state, "unknown tag !<" + state.tag + ">");
            }
          }
          if (state.listener !== null) {
            state.listener("close", state);
          }
          return state.tag !== null || state.anchor !== null || hasContent;
        }
        function readDocument(state) {
          var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
          state.version = null;
          state.checkLineBreaks = state.legacy;
          state.tagMap = {};
          state.anchorMap = {};
          while ((ch = state.input.charCodeAt(state.position)) !== 0) {
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
            if (state.lineIndent > 0 || ch !== 37) {
              break;
            }
            hasDirectives = true;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            directiveName = state.input.slice(_position, state.position);
            directiveArgs = [];
            if (directiveName.length < 1) {
              throwError(state, "directive name must not be less than one character in length");
            }
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              if (ch === 35) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 0 && !is_EOL(ch));
                break;
              }
              if (is_EOL(ch))
                break;
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveArgs.push(state.input.slice(_position, state.position));
            }
            if (ch !== 0)
              readLineBreak(state);
            if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
              directiveHandlers[directiveName](state, directiveName, directiveArgs);
            } else {
              throwWarning(state, 'unknown document directive "' + directiveName + '"');
            }
          }
          skipSeparationSpace(state, true, -1);
          if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
          } else if (hasDirectives) {
            throwError(state, "directives end mark is expected");
          }
          composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
          skipSeparationSpace(state, true, -1);
          if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
            throwWarning(state, "non-ASCII line breaks are interpreted as content");
          }
          state.documents.push(state.result);
          if (state.position === state.lineStart && testDocumentSeparator(state)) {
            if (state.input.charCodeAt(state.position) === 46) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            }
            return;
          }
          if (state.position < state.length - 1) {
            throwError(state, "end of the stream or a document separator is expected");
          } else {
            return;
          }
        }
        function loadDocuments(input, options) {
          input = String(input);
          options = options || {};
          if (input.length !== 0) {
            if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
              input += "\n";
            }
            if (input.charCodeAt(0) === 65279) {
              input = input.slice(1);
            }
          }
          var state = new State(input, options);
          state.input += "\0";
          while (state.input.charCodeAt(state.position) === 32) {
            state.lineIndent += 1;
            state.position += 1;
          }
          while (state.position < state.length - 1) {
            readDocument(state);
          }
          return state.documents;
        }
        function loadAll(input, iterator, options) {
          var documents = loadDocuments(input, options), index, length;
          if (typeof iterator !== "function") {
            return documents;
          }
          for (index = 0, length = documents.length; index < length; index += 1) {
            iterator(documents[index]);
          }
        }
        function load(input, options) {
          var documents = loadDocuments(input, options);
          if (documents.length === 0) {
            return void 0;
          } else if (documents.length === 1) {
            return documents[0];
          }
          throw new YAMLException("expected a single document in the stream, but found more");
        }
        function safeLoadAll(input, output, options) {
          if (typeof output === "function") {
            loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
          } else {
            return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
          }
        }
        function safeLoad(input, options) {
          return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        module2.exports.loadAll = loadAll;
        module2.exports.load = load;
        module2.exports.safeLoadAll = safeLoadAll;
        module2.exports.safeLoad = safeLoad;
      }
    });
    var require_dumper = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports2, module2) {
        "use strict";
        var common = require_common2();
        var YAMLException = require_exception();
        var DEFAULT_FULL_SCHEMA = require_default_full();
        var DEFAULT_SAFE_SCHEMA = require_default_safe();
        var _toString = Object.prototype.toString;
        var _hasOwnProperty = Object.prototype.hasOwnProperty;
        var CHAR_TAB = 9;
        var CHAR_LINE_FEED = 10;
        var CHAR_SPACE = 32;
        var CHAR_EXCLAMATION = 33;
        var CHAR_DOUBLE_QUOTE = 34;
        var CHAR_SHARP = 35;
        var CHAR_PERCENT = 37;
        var CHAR_AMPERSAND = 38;
        var CHAR_SINGLE_QUOTE = 39;
        var CHAR_ASTERISK = 42;
        var CHAR_COMMA2 = 44;
        var CHAR_MINUS = 45;
        var CHAR_COLON2 = 58;
        var CHAR_GREATER_THAN = 62;
        var CHAR_QUESTION = 63;
        var CHAR_COMMERCIAL_AT = 64;
        var CHAR_LEFT_SQUARE_BRACKET = 91;
        var CHAR_RIGHT_SQUARE_BRACKET = 93;
        var CHAR_GRAVE_ACCENT = 96;
        var CHAR_LEFT_CURLY_BRACKET = 123;
        var CHAR_VERTICAL_LINE = 124;
        var CHAR_RIGHT_CURLY_BRACKET = 125;
        var ESCAPE_SEQUENCES = {};
        ESCAPE_SEQUENCES[0] = "\\0";
        ESCAPE_SEQUENCES[7] = "\\a";
        ESCAPE_SEQUENCES[8] = "\\b";
        ESCAPE_SEQUENCES[9] = "\\t";
        ESCAPE_SEQUENCES[10] = "\\n";
        ESCAPE_SEQUENCES[11] = "\\v";
        ESCAPE_SEQUENCES[12] = "\\f";
        ESCAPE_SEQUENCES[13] = "\\r";
        ESCAPE_SEQUENCES[27] = "\\e";
        ESCAPE_SEQUENCES[34] = '\\"';
        ESCAPE_SEQUENCES[92] = "\\\\";
        ESCAPE_SEQUENCES[133] = "\\N";
        ESCAPE_SEQUENCES[160] = "\\_";
        ESCAPE_SEQUENCES[8232] = "\\L";
        ESCAPE_SEQUENCES[8233] = "\\P";
        var DEPRECATED_BOOLEANS_SYNTAX = [
          "y",
          "Y",
          "yes",
          "Yes",
          "YES",
          "on",
          "On",
          "ON",
          "n",
          "N",
          "no",
          "No",
          "NO",
          "off",
          "Off",
          "OFF"
        ];
        function compileStyleMap(schema, map) {
          var result, keys, index, length, tag, style, type;
          if (map === null)
            return {};
          result = {};
          keys = Object.keys(map);
          for (index = 0, length = keys.length; index < length; index += 1) {
            tag = keys[index];
            style = String(map[tag]);
            if (tag.slice(0, 2) === "!!") {
              tag = "tag:yaml.org,2002:" + tag.slice(2);
            }
            type = schema.compiledTypeMap["fallback"][tag];
            if (type && _hasOwnProperty.call(type.styleAliases, style)) {
              style = type.styleAliases[style];
            }
            result[tag] = style;
          }
          return result;
        }
        function encodeHex(character) {
          var string, handle, length;
          string = character.toString(16).toUpperCase();
          if (character <= 255) {
            handle = "x";
            length = 2;
          } else if (character <= 65535) {
            handle = "u";
            length = 4;
          } else if (character <= 4294967295) {
            handle = "U";
            length = 8;
          } else {
            throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
          }
          return "\\" + handle + common.repeat("0", length - string.length) + string;
        }
        function State(options) {
          this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
          this.indent = Math.max(1, options["indent"] || 2);
          this.noArrayIndent = options["noArrayIndent"] || false;
          this.skipInvalid = options["skipInvalid"] || false;
          this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
          this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
          this.sortKeys = options["sortKeys"] || false;
          this.lineWidth = options["lineWidth"] || 80;
          this.noRefs = options["noRefs"] || false;
          this.noCompatMode = options["noCompatMode"] || false;
          this.condenseFlow = options["condenseFlow"] || false;
          this.implicitTypes = this.schema.compiledImplicit;
          this.explicitTypes = this.schema.compiledExplicit;
          this.tag = null;
          this.result = "";
          this.duplicates = [];
          this.usedDuplicates = null;
        }
        function indentString(string, spaces) {
          var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
          while (position < length) {
            next = string.indexOf("\n", position);
            if (next === -1) {
              line = string.slice(position);
              position = length;
            } else {
              line = string.slice(position, next + 1);
              position = next + 1;
            }
            if (line.length && line !== "\n")
              result += ind;
            result += line;
          }
          return result;
        }
        function generateNextLine(state, level) {
          return "\n" + common.repeat(" ", state.indent * level);
        }
        function testImplicitResolving(state, str) {
          var index, length, type;
          for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
            type = state.implicitTypes[index];
            if (type.resolve(str)) {
              return true;
            }
          }
          return false;
        }
        function isWhitespace(c) {
          return c === CHAR_SPACE || c === CHAR_TAB;
        }
        function isPrintable(c) {
          return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
        }
        function isPlainSafe(c) {
          return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA2 && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON2 && c !== CHAR_SHARP;
        }
        function isPlainSafeFirst(c) {
          return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON2 && c !== CHAR_COMMA2 && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
        }
        function needIndentIndicator(string) {
          var leadingSpaceRe = /^\n* /;
          return leadingSpaceRe.test(string);
        }
        var STYLE_PLAIN = 1;
        var STYLE_SINGLE = 2;
        var STYLE_LITERAL = 3;
        var STYLE_FOLDED = 4;
        var STYLE_DOUBLE = 5;
        function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
          var i;
          var char;
          var hasLineBreak = false;
          var hasFoldableLine = false;
          var shouldTrackWidth = lineWidth !== -1;
          var previousLineBreak = -1;
          var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
          if (singleLineOnly) {
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              plain = plain && isPlainSafe(char);
            }
          } else {
            for (i = 0; i < string.length; i++) {
              char = string.charCodeAt(i);
              if (char === CHAR_LINE_FEED) {
                hasLineBreak = true;
                if (shouldTrackWidth) {
                  hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                  i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                  previousLineBreak = i;
                }
              } else if (!isPrintable(char)) {
                return STYLE_DOUBLE;
              }
              plain = plain && isPlainSafe(char);
            }
            hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
          }
          if (!hasLineBreak && !hasFoldableLine) {
            return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
          }
          if (indentPerLevel > 9 && needIndentIndicator(string)) {
            return STYLE_DOUBLE;
          }
          return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
        }
        function writeScalar(state, string, level, iskey) {
          state.dump = (function() {
            if (string.length === 0) {
              return "''";
            }
            if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
              return "'" + string + "'";
            }
            var indent = state.indent * Math.max(1, level);
            var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
            var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
            function testAmbiguity(string2) {
              return testImplicitResolving(state, string2);
            }
            switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
              case STYLE_PLAIN:
                return string;
              case STYLE_SINGLE:
                return "'" + string.replace(/'/g, "''") + "'";
              case STYLE_LITERAL:
                return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
              case STYLE_FOLDED:
                return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
              case STYLE_DOUBLE:
                return '"' + escapeString(string, lineWidth) + '"';
              default:
                throw new YAMLException("impossible error: invalid scalar style");
            }
          })();
        }
        function blockHeader(string, indentPerLevel) {
          var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
          var clip = string[string.length - 1] === "\n";
          var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
          var chomp = keep ? "+" : clip ? "" : "-";
          return indentIndicator + chomp + "\n";
        }
        function dropEndingNewline(string) {
          return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
        }
        function foldString(string, width) {
          var lineRe = /(\n+)([^\n]*)/g;
          var result = (function() {
            var nextLF = string.indexOf("\n");
            nextLF = nextLF !== -1 ? nextLF : string.length;
            lineRe.lastIndex = nextLF;
            return foldLine(string.slice(0, nextLF), width);
          })();
          var prevMoreIndented = string[0] === "\n" || string[0] === " ";
          var moreIndented;
          var match;
          while (match = lineRe.exec(string)) {
            var prefix = match[1], line = match[2];
            moreIndented = line[0] === " ";
            result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
            prevMoreIndented = moreIndented;
          }
          return result;
        }
        function foldLine(line, width) {
          if (line === "" || line[0] === " ")
            return line;
          var breakRe = / [^ ]/g;
          var match;
          var start = 0, end, curr = 0, next = 0;
          var result = "";
          while (match = breakRe.exec(line)) {
            next = match.index;
            if (next - start > width) {
              end = curr > start ? curr : next;
              result += "\n" + line.slice(start, end);
              start = end + 1;
            }
            curr = next;
          }
          result += "\n";
          if (line.length - start > width && curr > start) {
            result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
          } else {
            result += line.slice(start);
          }
          return result.slice(1);
        }
        function escapeString(string) {
          var result = "";
          var char, nextChar;
          var escapeSeq;
          for (var i = 0; i < string.length; i++) {
            char = string.charCodeAt(i);
            if (char >= 55296 && char <= 56319) {
              nextChar = string.charCodeAt(i + 1);
              if (nextChar >= 56320 && nextChar <= 57343) {
                result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
                i++;
                continue;
              }
            }
            escapeSeq = ESCAPE_SEQUENCES[char];
            result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
          }
          return result;
        }
        function writeFlowSequence(state, level, object) {
          var _result = "", _tag = state.tag, index, length;
          for (index = 0, length = object.length; index < length; index += 1) {
            if (writeNode(state, level, object[index], false, false)) {
              if (index !== 0)
                _result += "," + (!state.condenseFlow ? " " : "");
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = "[" + _result + "]";
        }
        function writeBlockSequence(state, level, object, compact) {
          var _result = "", _tag = state.tag, index, length;
          for (index = 0, length = object.length; index < length; index += 1) {
            if (writeNode(state, level + 1, object[index], true, true)) {
              if (!compact || index !== 0) {
                _result += generateNextLine(state, level);
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                _result += "-";
              } else {
                _result += "- ";
              }
              _result += state.dump;
            }
          }
          state.tag = _tag;
          state.dump = _result || "[]";
        }
        function writeFlowMapping(state, level, object) {
          var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = state.condenseFlow ? '"' : "";
            if (index !== 0)
              pairBuffer += ", ";
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level, objectKey, false, false)) {
              continue;
            }
            if (state.dump.length > 1024)
              pairBuffer += "? ";
            pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
            if (!writeNode(state, level, objectValue, false, false)) {
              continue;
            }
            pairBuffer += state.dump;
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = "{" + _result + "}";
        }
        function writeBlockMapping(state, level, object, compact) {
          var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
          if (state.sortKeys === true) {
            objectKeyList.sort();
          } else if (typeof state.sortKeys === "function") {
            objectKeyList.sort(state.sortKeys);
          } else if (state.sortKeys) {
            throw new YAMLException("sortKeys must be a boolean or a function");
          }
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            pairBuffer = "";
            if (!compact || index !== 0) {
              pairBuffer += generateNextLine(state, level);
            }
            objectKey = objectKeyList[index];
            objectValue = object[objectKey];
            if (!writeNode(state, level + 1, objectKey, true, true, true)) {
              continue;
            }
            explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
            if (explicitPair) {
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += "?";
              } else {
                pairBuffer += "? ";
              }
            }
            pairBuffer += state.dump;
            if (explicitPair) {
              pairBuffer += generateNextLine(state, level);
            }
            if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
              continue;
            }
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
              pairBuffer += ":";
            } else {
              pairBuffer += ": ";
            }
            pairBuffer += state.dump;
            _result += pairBuffer;
          }
          state.tag = _tag;
          state.dump = _result || "{}";
        }
        function detectType(state, object, explicit) {
          var _result, typeList, index, length, type, style;
          typeList = explicit ? state.explicitTypes : state.implicitTypes;
          for (index = 0, length = typeList.length; index < length; index += 1) {
            type = typeList[index];
            if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
              state.tag = explicit ? type.tag : "?";
              if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if (_toString.call(type.represent) === "[object Function]") {
                  _result = type.represent(object, style);
                } else if (_hasOwnProperty.call(type.represent, style)) {
                  _result = type.represent[style](object, style);
                } else {
                  throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
              }
              return true;
            }
          }
          return false;
        }
        function writeNode(state, level, object, block, compact, iskey) {
          state.tag = null;
          state.dump = object;
          if (!detectType(state, object, false)) {
            detectType(state, object, true);
          }
          var type = _toString.call(state.dump);
          if (block) {
            block = state.flowLevel < 0 || state.flowLevel > level;
          }
          var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
          if (objectOrArray) {
            duplicateIndex = state.duplicates.indexOf(object);
            duplicate = duplicateIndex !== -1;
          }
          if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
            compact = false;
          }
          if (duplicate && state.usedDuplicates[duplicateIndex]) {
            state.dump = "*ref_" + duplicateIndex;
          } else {
            if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
              state.usedDuplicates[duplicateIndex] = true;
            }
            if (type === "[object Object]") {
              if (block && Object.keys(state.dump).length !== 0) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + state.dump;
                }
              } else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
              }
            } else if (type === "[object Array]") {
              var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
              if (block && state.dump.length !== 0) {
                writeBlockSequence(state, arrayLevel, state.dump, compact);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + state.dump;
                }
              } else {
                writeFlowSequence(state, arrayLevel, state.dump);
                if (duplicate) {
                  state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                }
              }
            } else if (type === "[object String]") {
              if (state.tag !== "?") {
                writeScalar(state, state.dump, level, iskey);
              }
            } else {
              if (state.skipInvalid)
                return false;
              throw new YAMLException("unacceptable kind of an object to dump " + type);
            }
            if (state.tag !== null && state.tag !== "?") {
              state.dump = "!<" + state.tag + "> " + state.dump;
            }
          }
          return true;
        }
        function getDuplicateReferences(object, state) {
          var objects = [], duplicatesIndexes = [], index, length;
          inspectNode(object, objects, duplicatesIndexes);
          for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
            state.duplicates.push(objects[duplicatesIndexes[index]]);
          }
          state.usedDuplicates = new Array(length);
        }
        function inspectNode(object, objects, duplicatesIndexes) {
          var objectKeyList, index, length;
          if (object !== null && typeof object === "object") {
            index = objects.indexOf(object);
            if (index !== -1) {
              if (duplicatesIndexes.indexOf(index) === -1) {
                duplicatesIndexes.push(index);
              }
            } else {
              objects.push(object);
              if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                  inspectNode(object[index], objects, duplicatesIndexes);
                }
              } else {
                objectKeyList = Object.keys(object);
                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                  inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
              }
            }
          }
        }
        function dump(input, options) {
          options = options || {};
          var state = new State(options);
          if (!state.noRefs)
            getDuplicateReferences(input, state);
          if (writeNode(state, 0, input, true, true))
            return state.dump + "\n";
          return "";
        }
        function safeDump(input, options) {
          return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
        }
        module2.exports.dump = dump;
        module2.exports.safeDump = safeDump;
      }
    });
    var require_js_yaml = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/lib/js-yaml.js"(exports2, module2) {
        "use strict";
        var loader = require_loader();
        var dumper = require_dumper();
        function deprecated(name) {
          return function() {
            throw new Error("Function " + name + " is deprecated and cannot be used.");
          };
        }
        module2.exports.Type = require_type();
        module2.exports.Schema = require_schema();
        module2.exports.FAILSAFE_SCHEMA = require_failsafe();
        module2.exports.JSON_SCHEMA = require_json2();
        module2.exports.CORE_SCHEMA = require_core();
        module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
        module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
        module2.exports.load = loader.load;
        module2.exports.loadAll = loader.loadAll;
        module2.exports.safeLoad = loader.safeLoad;
        module2.exports.safeLoadAll = loader.safeLoadAll;
        module2.exports.dump = dumper.dump;
        module2.exports.safeDump = dumper.safeDump;
        module2.exports.YAMLException = require_exception();
        module2.exports.MINIMAL_SCHEMA = require_failsafe();
        module2.exports.SAFE_SCHEMA = require_default_safe();
        module2.exports.DEFAULT_SCHEMA = require_default_full();
        module2.exports.scan = deprecated("scan");
        module2.exports.parse = deprecated("parse");
        module2.exports.compose = deprecated("compose");
        module2.exports.addConstructor = deprecated("addConstructor");
      }
    });
    var require_js_yaml2 = __commonJS({
      "../../node_modules/.pnpm/js-yaml@3.13.1/node_modules/js-yaml/index.js"(exports2, module2) {
        "use strict";
        var yaml3 = require_js_yaml();
        module2.exports = yaml3;
      }
    });
    var require_parser = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/parser.js"(exports2, module2) {
        "use strict";
        var ParserEND = 1114112;
        var ParserError = class _ParserError extends Error {
          /* istanbul ignore next */
          constructor(msg, filename, linenumber) {
            super("[ParserError] " + msg, filename, linenumber);
            this.name = "ParserError";
            this.code = "ParserError";
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, _ParserError);
          }
        };
        var State = class {
          constructor(parser) {
            this.parser = parser;
            this.buf = "";
            this.returned = null;
            this.result = null;
            this.resultTable = null;
            this.resultArr = null;
          }
        };
        var Parser = class {
          constructor() {
            this.pos = 0;
            this.col = 0;
            this.line = 0;
            this.obj = {};
            this.ctx = this.obj;
            this.stack = [];
            this._buf = "";
            this.char = null;
            this.ii = 0;
            this.state = new State(this.parseStart);
          }
          parse(str) {
            if (str.length === 0 || str.length == null)
              return;
            this._buf = String(str);
            this.ii = -1;
            this.char = -1;
            let getNext;
            while (getNext === false || this.nextChar()) {
              getNext = this.runOne();
            }
            this._buf = null;
          }
          nextChar() {
            if (this.char === 10) {
              ++this.line;
              this.col = -1;
            }
            ++this.ii;
            this.char = this._buf.codePointAt(this.ii);
            ++this.pos;
            ++this.col;
            return this.haveBuffer();
          }
          haveBuffer() {
            return this.ii < this._buf.length;
          }
          runOne() {
            return this.state.parser.call(this, this.state.returned);
          }
          finish() {
            this.char = ParserEND;
            let last;
            do {
              last = this.state.parser;
              this.runOne();
            } while (this.state.parser !== last);
            this.ctx = null;
            this.state = null;
            this._buf = null;
            return this.obj;
          }
          next(fn) {
            if (typeof fn !== "function")
              throw new ParserError("Tried to set state to non-existent state: " + JSON.stringify(fn));
            this.state.parser = fn;
          }
          goto(fn) {
            this.next(fn);
            return this.runOne();
          }
          call(fn, returnWith) {
            if (returnWith)
              this.next(returnWith);
            this.stack.push(this.state);
            this.state = new State(fn);
          }
          callNow(fn, returnWith) {
            this.call(fn, returnWith);
            return this.runOne();
          }
          return(value) {
            if (this.stack.length === 0)
              throw this.error(new ParserError("Stack underflow"));
            if (value === void 0)
              value = this.state.buf;
            this.state = this.stack.pop();
            this.state.returned = value;
          }
          returnNow(value) {
            this.return(value);
            return this.runOne();
          }
          consume() {
            if (this.char === ParserEND)
              throw this.error(new ParserError("Unexpected end-of-buffer"));
            this.state.buf += this._buf[this.ii];
          }
          error(err) {
            err.line = this.line;
            err.col = this.col;
            err.pos = this.pos;
            return err;
          }
          /* istanbul ignore next */
          parseStart() {
            throw new ParserError("Must declare a parseStart method");
          }
        };
        Parser.END = ParserEND;
        Parser.Error = ParserError;
        module2.exports = Parser;
      }
    });
    var require_create_datetime = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/create-datetime.js"(exports2, module2) {
        "use strict";
        module2.exports = (value) => {
          const date = new Date(value);
          if (isNaN(date)) {
            throw new TypeError("Invalid Datetime");
          } else {
            return date;
          }
        };
      }
    });
    var require_format_num = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/format-num.js"(exports2, module2) {
        "use strict";
        module2.exports = (d, num) => {
          num = String(num);
          while (num.length < d)
            num = "0" + num;
          return num;
        };
      }
    });
    var require_create_datetime_float = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/create-datetime-float.js"(exports2, module2) {
        "use strict";
        var f = require_format_num();
        var FloatingDateTime = class extends Date {
          constructor(value) {
            super(value + "Z");
            this.isFloating = true;
          }
          toISOString() {
            const date = `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
            const time = `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
            return `${date}T${time}`;
          }
        };
        module2.exports = (value) => {
          const date = new FloatingDateTime(value);
          if (isNaN(date)) {
            throw new TypeError("Invalid Datetime");
          } else {
            return date;
          }
        };
      }
    });
    var require_create_date = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/create-date.js"(exports2, module2) {
        "use strict";
        var f = require_format_num();
        var DateTime = global.Date;
        var Date2 = class extends DateTime {
          constructor(value) {
            super(value);
            this.isDate = true;
          }
          toISOString() {
            return `${this.getUTCFullYear()}-${f(2, this.getUTCMonth() + 1)}-${f(2, this.getUTCDate())}`;
          }
        };
        module2.exports = (value) => {
          const date = new Date2(value);
          if (isNaN(date)) {
            throw new TypeError("Invalid Datetime");
          } else {
            return date;
          }
        };
      }
    });
    var require_create_time = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/create-time.js"(exports2, module2) {
        "use strict";
        var f = require_format_num();
        var Time = class extends Date {
          constructor(value) {
            super(`0000-01-01T${value}Z`);
            this.isTime = true;
          }
          toISOString() {
            return `${f(2, this.getUTCHours())}:${f(2, this.getUTCMinutes())}:${f(2, this.getUTCSeconds())}.${f(3, this.getUTCMilliseconds())}`;
          }
        };
        module2.exports = (value) => {
          const date = new Time(value);
          if (isNaN(date)) {
            throw new TypeError("Invalid Datetime");
          } else {
            return date;
          }
        };
      }
    });
    var require_toml_parser = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/lib/toml-parser.js"(exports, module) {
        "use strict";
        module.exports = makeParserClass(require_parser());
        module.exports.makeParserClass = makeParserClass;
        var TomlError = class _TomlError extends Error {
          constructor(msg) {
            super(msg);
            this.name = "TomlError";
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, _TomlError);
            this.fromTOML = true;
            this.wrapped = null;
          }
        };
        TomlError.wrap = (err) => {
          const terr = new TomlError(err.message);
          terr.code = err.code;
          terr.wrapped = err;
          return terr;
        };
        module.exports.TomlError = TomlError;
        var createDateTime = require_create_datetime();
        var createDateTimeFloat = require_create_datetime_float();
        var createDate = require_create_date();
        var createTime = require_create_time();
        var CTRL_I = 9;
        var CTRL_J = 10;
        var CTRL_M = 13;
        var CTRL_CHAR_BOUNDARY = 31;
        var CHAR_SP = 32;
        var CHAR_QUOT = 34;
        var CHAR_NUM = 35;
        var CHAR_APOS = 39;
        var CHAR_PLUS = 43;
        var CHAR_COMMA = 44;
        var CHAR_HYPHEN = 45;
        var CHAR_PERIOD = 46;
        var CHAR_0 = 48;
        var CHAR_1 = 49;
        var CHAR_7 = 55;
        var CHAR_9 = 57;
        var CHAR_COLON = 58;
        var CHAR_EQUALS = 61;
        var CHAR_A = 65;
        var CHAR_E = 69;
        var CHAR_F = 70;
        var CHAR_T = 84;
        var CHAR_U = 85;
        var CHAR_Z = 90;
        var CHAR_LOWBAR = 95;
        var CHAR_a = 97;
        var CHAR_b = 98;
        var CHAR_e = 101;
        var CHAR_f = 102;
        var CHAR_i = 105;
        var CHAR_l = 108;
        var CHAR_n = 110;
        var CHAR_o = 111;
        var CHAR_r = 114;
        var CHAR_s = 115;
        var CHAR_t = 116;
        var CHAR_u = 117;
        var CHAR_x = 120;
        var CHAR_z = 122;
        var CHAR_LCUB = 123;
        var CHAR_RCUB = 125;
        var CHAR_LSQB = 91;
        var CHAR_BSOL = 92;
        var CHAR_RSQB = 93;
        var CHAR_DEL = 127;
        var SURROGATE_FIRST = 55296;
        var SURROGATE_LAST = 57343;
        var escapes = {
          [CHAR_b]: "\b",
          [CHAR_t]: "	",
          [CHAR_n]: "\n",
          [CHAR_f]: "\f",
          [CHAR_r]: "\r",
          [CHAR_QUOT]: '"',
          [CHAR_BSOL]: "\\"
        };
        function isDigit(cp) {
          return cp >= CHAR_0 && cp <= CHAR_9;
        }
        function isHexit(cp) {
          return cp >= CHAR_A && cp <= CHAR_F || cp >= CHAR_a && cp <= CHAR_f || cp >= CHAR_0 && cp <= CHAR_9;
        }
        function isBit(cp) {
          return cp === CHAR_1 || cp === CHAR_0;
        }
        function isOctit(cp) {
          return cp >= CHAR_0 && cp <= CHAR_7;
        }
        function isAlphaNumQuoteHyphen(cp) {
          return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_APOS || cp === CHAR_QUOT || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
        }
        function isAlphaNumHyphen(cp) {
          return cp >= CHAR_A && cp <= CHAR_Z || cp >= CHAR_a && cp <= CHAR_z || cp >= CHAR_0 && cp <= CHAR_9 || cp === CHAR_LOWBAR || cp === CHAR_HYPHEN;
        }
        var _type = Symbol("type");
        var _declared = Symbol("declared");
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var defineProperty = Object.defineProperty;
        var descriptor = { configurable: true, enumerable: true, writable: true, value: void 0 };
        function hasKey(obj, key) {
          if (hasOwnProperty.call(obj, key))
            return true;
          if (key === "__proto__")
            defineProperty(obj, "__proto__", descriptor);
          return false;
        }
        var INLINE_TABLE = Symbol("inline-table");
        function InlineTable() {
          return Object.defineProperties({}, {
            [_type]: { value: INLINE_TABLE }
          });
        }
        function isInlineTable(obj) {
          if (obj === null || typeof obj !== "object")
            return false;
          return obj[_type] === INLINE_TABLE;
        }
        var TABLE = Symbol("table");
        function Table() {
          return Object.defineProperties({}, {
            [_type]: { value: TABLE },
            [_declared]: { value: false, writable: true }
          });
        }
        function isTable(obj) {
          if (obj === null || typeof obj !== "object")
            return false;
          return obj[_type] === TABLE;
        }
        var _contentType = Symbol("content-type");
        var INLINE_LIST = Symbol("inline-list");
        function InlineList(type) {
          return Object.defineProperties([], {
            [_type]: { value: INLINE_LIST },
            [_contentType]: { value: type }
          });
        }
        function isInlineList(obj) {
          if (obj === null || typeof obj !== "object")
            return false;
          return obj[_type] === INLINE_LIST;
        }
        var LIST = Symbol("list");
        function List() {
          return Object.defineProperties([], {
            [_type]: { value: LIST }
          });
        }
        function isList(obj) {
          if (obj === null || typeof obj !== "object")
            return false;
          return obj[_type] === LIST;
        }
        var _custom;
        try {
          const utilInspect = eval("require('util').inspect");
          _custom = utilInspect.custom;
        } catch (_) {
        }
        var _inspect = _custom || "inspect";
        var BoxedBigInt = class {
          constructor(value) {
            try {
              this.value = global.BigInt.asIntN(64, value);
            } catch (_) {
              this.value = null;
            }
            Object.defineProperty(this, _type, { value: INTEGER });
          }
          isNaN() {
            return this.value === null;
          }
          /* istanbul ignore next */
          toString() {
            return String(this.value);
          }
          /* istanbul ignore next */
          [_inspect]() {
            return `[BigInt: ${this.toString()}]}`;
          }
          valueOf() {
            return this.value;
          }
        };
        var INTEGER = Symbol("integer");
        function Integer(value) {
          let num = Number(value);
          if (Object.is(num, -0))
            num = 0;
          if (global.BigInt && !Number.isSafeInteger(num)) {
            return new BoxedBigInt(value);
          } else {
            return Object.defineProperties(new Number(num), {
              isNaN: { value: function() {
                return isNaN(this);
              } },
              [_type]: { value: INTEGER },
              [_inspect]: { value: () => `[Integer: ${value}]` }
            });
          }
        }
        function isInteger(obj) {
          if (obj === null || typeof obj !== "object")
            return false;
          return obj[_type] === INTEGER;
        }
        var FLOAT = Symbol("float");
        function Float(value) {
          return Object.defineProperties(new Number(value), {
            [_type]: { value: FLOAT },
            [_inspect]: { value: () => `[Float: ${value}]` }
          });
        }
        function isFloat(obj) {
          if (obj === null || typeof obj !== "object")
            return false;
          return obj[_type] === FLOAT;
        }
        function tomlType(value) {
          const type = typeof value;
          if (type === "object") {
            if (value === null)
              return "null";
            if (value instanceof Date)
              return "datetime";
            if (_type in value) {
              switch (value[_type]) {
                case INLINE_TABLE:
                  return "inline-table";
                case INLINE_LIST:
                  return "inline-list";
                case TABLE:
                  return "table";
                case LIST:
                  return "list";
                case FLOAT:
                  return "float";
                case INTEGER:
                  return "integer";
              }
            }
          }
          return type;
        }
        function makeParserClass(Parser) {
          class TOMLParser extends Parser {
            constructor() {
              super();
              this.ctx = this.obj = Table();
            }
            /* MATCH HELPER */
            atEndOfWord() {
              return this.char === CHAR_NUM || this.char === CTRL_I || this.char === CHAR_SP || this.atEndOfLine();
            }
            atEndOfLine() {
              return this.char === Parser.END || this.char === CTRL_J || this.char === CTRL_M;
            }
            parseStart() {
              if (this.char === Parser.END) {
                return null;
              } else if (this.char === CHAR_LSQB) {
                return this.call(this.parseTableOrList);
              } else if (this.char === CHAR_NUM) {
                return this.call(this.parseComment);
              } else if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
                return null;
              } else if (isAlphaNumQuoteHyphen(this.char)) {
                return this.callNow(this.parseAssignStatement);
              } else {
                throw this.error(new TomlError(`Unknown character "${this.char}"`));
              }
            }
            // HELPER, this strips any whitespace and comments to the end of the line
            // then RETURNS. Last state in a production.
            parseWhitespaceToEOL() {
              if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
                return null;
              } else if (this.char === CHAR_NUM) {
                return this.goto(this.parseComment);
              } else if (this.char === Parser.END || this.char === CTRL_J) {
                return this.return();
              } else {
                throw this.error(new TomlError("Unexpected character, expected only whitespace or comments till end of line"));
              }
            }
            /* ASSIGNMENT: key = value */
            parseAssignStatement() {
              return this.callNow(this.parseAssign, this.recordAssignStatement);
            }
            recordAssignStatement(kv) {
              let target = this.ctx;
              let finalKey = kv.key.pop();
              for (let kw of kv.key) {
                if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
                  throw this.error(new TomlError("Can't redefine existing key"));
                }
                target = target[kw] = target[kw] || Table();
              }
              if (hasKey(target, finalKey)) {
                throw this.error(new TomlError("Can't redefine existing key"));
              }
              if (isInteger(kv.value) || isFloat(kv.value)) {
                target[finalKey] = kv.value.valueOf();
              } else {
                target[finalKey] = kv.value;
              }
              return this.goto(this.parseWhitespaceToEOL);
            }
            /* ASSSIGNMENT expression, key = value possibly inside an inline table */
            parseAssign() {
              return this.callNow(this.parseKeyword, this.recordAssignKeyword);
            }
            recordAssignKeyword(key) {
              if (this.state.resultTable) {
                this.state.resultTable.push(key);
              } else {
                this.state.resultTable = [key];
              }
              return this.goto(this.parseAssignKeywordPreDot);
            }
            parseAssignKeywordPreDot() {
              if (this.char === CHAR_PERIOD) {
                return this.next(this.parseAssignKeywordPostDot);
              } else if (this.char !== CHAR_SP && this.char !== CTRL_I) {
                return this.goto(this.parseAssignEqual);
              }
            }
            parseAssignKeywordPostDot() {
              if (this.char !== CHAR_SP && this.char !== CTRL_I) {
                return this.callNow(this.parseKeyword, this.recordAssignKeyword);
              }
            }
            parseAssignEqual() {
              if (this.char === CHAR_EQUALS) {
                return this.next(this.parseAssignPreValue);
              } else {
                throw this.error(new TomlError('Invalid character, expected "="'));
              }
            }
            parseAssignPreValue() {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else {
                return this.callNow(this.parseValue, this.recordAssignValue);
              }
            }
            recordAssignValue(value) {
              return this.returnNow({ key: this.state.resultTable, value });
            }
            /* COMMENTS: #...eol */
            parseComment() {
              do {
                if (this.char === Parser.END || this.char === CTRL_J) {
                  return this.return();
                }
              } while (this.nextChar());
            }
            /* TABLES AND LISTS, [foo] and [[foo]] */
            parseTableOrList() {
              if (this.char === CHAR_LSQB) {
                this.next(this.parseList);
              } else {
                return this.goto(this.parseTable);
              }
            }
            /* TABLE [foo.bar.baz] */
            parseTable() {
              this.ctx = this.obj;
              return this.goto(this.parseTableNext);
            }
            parseTableNext() {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else {
                return this.callNow(this.parseKeyword, this.parseTableMore);
              }
            }
            parseTableMore(keyword) {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else if (this.char === CHAR_RSQB) {
                if (hasKey(this.ctx, keyword) && (!isTable(this.ctx[keyword]) || this.ctx[keyword][_declared])) {
                  throw this.error(new TomlError("Can't redefine existing key"));
                } else {
                  this.ctx = this.ctx[keyword] = this.ctx[keyword] || Table();
                  this.ctx[_declared] = true;
                }
                return this.next(this.parseWhitespaceToEOL);
              } else if (this.char === CHAR_PERIOD) {
                if (!hasKey(this.ctx, keyword)) {
                  this.ctx = this.ctx[keyword] = Table();
                } else if (isTable(this.ctx[keyword])) {
                  this.ctx = this.ctx[keyword];
                } else if (isList(this.ctx[keyword])) {
                  this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                } else {
                  throw this.error(new TomlError("Can't redefine existing key"));
                }
                return this.next(this.parseTableNext);
              } else {
                throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
              }
            }
            /* LIST [[a.b.c]] */
            parseList() {
              this.ctx = this.obj;
              return this.goto(this.parseListNext);
            }
            parseListNext() {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else {
                return this.callNow(this.parseKeyword, this.parseListMore);
              }
            }
            parseListMore(keyword) {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else if (this.char === CHAR_RSQB) {
                if (!hasKey(this.ctx, keyword)) {
                  this.ctx[keyword] = List();
                }
                if (isInlineList(this.ctx[keyword])) {
                  throw this.error(new TomlError("Can't extend an inline array"));
                } else if (isList(this.ctx[keyword])) {
                  const next = Table();
                  this.ctx[keyword].push(next);
                  this.ctx = next;
                } else {
                  throw this.error(new TomlError("Can't redefine an existing key"));
                }
                return this.next(this.parseListEnd);
              } else if (this.char === CHAR_PERIOD) {
                if (!hasKey(this.ctx, keyword)) {
                  this.ctx = this.ctx[keyword] = Table();
                } else if (isInlineList(this.ctx[keyword])) {
                  throw this.error(new TomlError("Can't extend an inline array"));
                } else if (isInlineTable(this.ctx[keyword])) {
                  throw this.error(new TomlError("Can't extend an inline table"));
                } else if (isList(this.ctx[keyword])) {
                  this.ctx = this.ctx[keyword][this.ctx[keyword].length - 1];
                } else if (isTable(this.ctx[keyword])) {
                  this.ctx = this.ctx[keyword];
                } else {
                  throw this.error(new TomlError("Can't redefine an existing key"));
                }
                return this.next(this.parseListNext);
              } else {
                throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
              }
            }
            parseListEnd(keyword) {
              if (this.char === CHAR_RSQB) {
                return this.next(this.parseWhitespaceToEOL);
              } else {
                throw this.error(new TomlError("Unexpected character, expected whitespace, . or ]"));
              }
            }
            /* VALUE string, number, boolean, inline list, inline object */
            parseValue() {
              if (this.char === Parser.END) {
                throw this.error(new TomlError("Key without value"));
              } else if (this.char === CHAR_QUOT) {
                return this.next(this.parseDoubleString);
              }
              if (this.char === CHAR_APOS) {
                return this.next(this.parseSingleString);
              } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                return this.goto(this.parseNumberSign);
              } else if (this.char === CHAR_i) {
                return this.next(this.parseInf);
              } else if (this.char === CHAR_n) {
                return this.next(this.parseNan);
              } else if (isDigit(this.char)) {
                return this.goto(this.parseNumberOrDateTime);
              } else if (this.char === CHAR_t || this.char === CHAR_f) {
                return this.goto(this.parseBoolean);
              } else if (this.char === CHAR_LSQB) {
                return this.call(this.parseInlineList, this.recordValue);
              } else if (this.char === CHAR_LCUB) {
                return this.call(this.parseInlineTable, this.recordValue);
              } else {
                throw this.error(new TomlError("Unexpected character, expecting string, number, datetime, boolean, inline array or inline table"));
              }
            }
            recordValue(value) {
              return this.returnNow(value);
            }
            parseInf() {
              if (this.char === CHAR_n) {
                return this.next(this.parseInf2);
              } else {
                throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
              }
            }
            parseInf2() {
              if (this.char === CHAR_f) {
                if (this.state.buf === "-") {
                  return this.return(-Infinity);
                } else {
                  return this.return(Infinity);
                }
              } else {
                throw this.error(new TomlError('Unexpected character, expected "inf", "+inf" or "-inf"'));
              }
            }
            parseNan() {
              if (this.char === CHAR_a) {
                return this.next(this.parseNan2);
              } else {
                throw this.error(new TomlError('Unexpected character, expected "nan"'));
              }
            }
            parseNan2() {
              if (this.char === CHAR_n) {
                return this.return(NaN);
              } else {
                throw this.error(new TomlError('Unexpected character, expected "nan"'));
              }
            }
            /* KEYS, barewords or basic, literal, or dotted */
            parseKeyword() {
              if (this.char === CHAR_QUOT) {
                return this.next(this.parseBasicString);
              } else if (this.char === CHAR_APOS) {
                return this.next(this.parseLiteralString);
              } else {
                return this.goto(this.parseBareKey);
              }
            }
            /* KEYS: barewords */
            parseBareKey() {
              do {
                if (this.char === Parser.END) {
                  throw this.error(new TomlError("Key ended without value"));
                } else if (isAlphaNumHyphen(this.char)) {
                  this.consume();
                } else if (this.state.buf.length === 0) {
                  throw this.error(new TomlError("Empty bare keys are not allowed"));
                } else {
                  return this.returnNow();
                }
              } while (this.nextChar());
            }
            /* STRINGS, single quoted (literal) */
            parseSingleString() {
              if (this.char === CHAR_APOS) {
                return this.next(this.parseLiteralMultiStringMaybe);
              } else {
                return this.goto(this.parseLiteralString);
              }
            }
            parseLiteralString() {
              do {
                if (this.char === CHAR_APOS) {
                  return this.return();
                } else if (this.atEndOfLine()) {
                  throw this.error(new TomlError("Unterminated string"));
                } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
                  throw this.errorControlCharInString();
                } else {
                  this.consume();
                }
              } while (this.nextChar());
            }
            parseLiteralMultiStringMaybe() {
              if (this.char === CHAR_APOS) {
                return this.next(this.parseLiteralMultiString);
              } else {
                return this.returnNow();
              }
            }
            parseLiteralMultiString() {
              if (this.char === CTRL_M) {
                return null;
              } else if (this.char === CTRL_J) {
                return this.next(this.parseLiteralMultiStringContent);
              } else {
                return this.goto(this.parseLiteralMultiStringContent);
              }
            }
            parseLiteralMultiStringContent() {
              do {
                if (this.char === CHAR_APOS) {
                  return this.next(this.parseLiteralMultiEnd);
                } else if (this.char === Parser.END) {
                  throw this.error(new TomlError("Unterminated multi-line string"));
                } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
                  throw this.errorControlCharInString();
                } else {
                  this.consume();
                }
              } while (this.nextChar());
            }
            parseLiteralMultiEnd() {
              if (this.char === CHAR_APOS) {
                return this.next(this.parseLiteralMultiEnd2);
              } else {
                this.state.buf += "'";
                return this.goto(this.parseLiteralMultiStringContent);
              }
            }
            parseLiteralMultiEnd2() {
              if (this.char === CHAR_APOS) {
                return this.return();
              } else {
                this.state.buf += "''";
                return this.goto(this.parseLiteralMultiStringContent);
              }
            }
            /* STRINGS double quoted */
            parseDoubleString() {
              if (this.char === CHAR_QUOT) {
                return this.next(this.parseMultiStringMaybe);
              } else {
                return this.goto(this.parseBasicString);
              }
            }
            parseBasicString() {
              do {
                if (this.char === CHAR_BSOL) {
                  return this.call(this.parseEscape, this.recordEscapeReplacement);
                } else if (this.char === CHAR_QUOT) {
                  return this.return();
                } else if (this.atEndOfLine()) {
                  throw this.error(new TomlError("Unterminated string"));
                } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I) {
                  throw this.errorControlCharInString();
                } else {
                  this.consume();
                }
              } while (this.nextChar());
            }
            recordEscapeReplacement(replacement) {
              this.state.buf += replacement;
              return this.goto(this.parseBasicString);
            }
            parseMultiStringMaybe() {
              if (this.char === CHAR_QUOT) {
                return this.next(this.parseMultiString);
              } else {
                return this.returnNow();
              }
            }
            parseMultiString() {
              if (this.char === CTRL_M) {
                return null;
              } else if (this.char === CTRL_J) {
                return this.next(this.parseMultiStringContent);
              } else {
                return this.goto(this.parseMultiStringContent);
              }
            }
            parseMultiStringContent() {
              do {
                if (this.char === CHAR_BSOL) {
                  return this.call(this.parseMultiEscape, this.recordMultiEscapeReplacement);
                } else if (this.char === CHAR_QUOT) {
                  return this.next(this.parseMultiEnd);
                } else if (this.char === Parser.END) {
                  throw this.error(new TomlError("Unterminated multi-line string"));
                } else if (this.char === CHAR_DEL || this.char <= CTRL_CHAR_BOUNDARY && this.char !== CTRL_I && this.char !== CTRL_J && this.char !== CTRL_M) {
                  throw this.errorControlCharInString();
                } else {
                  this.consume();
                }
              } while (this.nextChar());
            }
            errorControlCharInString() {
              let displayCode = "\\u00";
              if (this.char < 16) {
                displayCode += "0";
              }
              displayCode += this.char.toString(16);
              return this.error(new TomlError(`Control characters (codes < 0x1f and 0x7f) are not allowed in strings, use ${displayCode} instead`));
            }
            recordMultiEscapeReplacement(replacement) {
              this.state.buf += replacement;
              return this.goto(this.parseMultiStringContent);
            }
            parseMultiEnd() {
              if (this.char === CHAR_QUOT) {
                return this.next(this.parseMultiEnd2);
              } else {
                this.state.buf += '"';
                return this.goto(this.parseMultiStringContent);
              }
            }
            parseMultiEnd2() {
              if (this.char === CHAR_QUOT) {
                return this.return();
              } else {
                this.state.buf += '""';
                return this.goto(this.parseMultiStringContent);
              }
            }
            parseMultiEscape() {
              if (this.char === CTRL_M || this.char === CTRL_J) {
                return this.next(this.parseMultiTrim);
              } else if (this.char === CHAR_SP || this.char === CTRL_I) {
                return this.next(this.parsePreMultiTrim);
              } else {
                return this.goto(this.parseEscape);
              }
            }
            parsePreMultiTrim() {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else if (this.char === CTRL_M || this.char === CTRL_J) {
                return this.next(this.parseMultiTrim);
              } else {
                throw this.error(new TomlError("Can't escape whitespace"));
              }
            }
            parseMultiTrim() {
              if (this.char === CTRL_J || this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M) {
                return null;
              } else {
                return this.returnNow();
              }
            }
            parseEscape() {
              if (this.char in escapes) {
                return this.return(escapes[this.char]);
              } else if (this.char === CHAR_u) {
                return this.call(this.parseSmallUnicode, this.parseUnicodeReturn);
              } else if (this.char === CHAR_U) {
                return this.call(this.parseLargeUnicode, this.parseUnicodeReturn);
              } else {
                throw this.error(new TomlError("Unknown escape character: " + this.char));
              }
            }
            parseUnicodeReturn(char) {
              try {
                const codePoint = parseInt(char, 16);
                if (codePoint >= SURROGATE_FIRST && codePoint <= SURROGATE_LAST) {
                  throw this.error(new TomlError("Invalid unicode, character in range 0xD800 - 0xDFFF is reserved"));
                }
                return this.returnNow(String.fromCodePoint(codePoint));
              } catch (err) {
                throw this.error(TomlError.wrap(err));
              }
            }
            parseSmallUnicode() {
              if (!isHexit(this.char)) {
                throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
              } else {
                this.consume();
                if (this.state.buf.length >= 4)
                  return this.return();
              }
            }
            parseLargeUnicode() {
              if (!isHexit(this.char)) {
                throw this.error(new TomlError("Invalid character in unicode sequence, expected hex"));
              } else {
                this.consume();
                if (this.state.buf.length >= 8)
                  return this.return();
              }
            }
            /* NUMBERS */
            parseNumberSign() {
              this.consume();
              return this.next(this.parseMaybeSignedInfOrNan);
            }
            parseMaybeSignedInfOrNan() {
              if (this.char === CHAR_i) {
                return this.next(this.parseInf);
              } else if (this.char === CHAR_n) {
                return this.next(this.parseNan);
              } else {
                return this.callNow(this.parseNoUnder, this.parseNumberIntegerStart);
              }
            }
            parseNumberIntegerStart() {
              if (this.char === CHAR_0) {
                this.consume();
                return this.next(this.parseNumberIntegerExponentOrDecimal);
              } else {
                return this.goto(this.parseNumberInteger);
              }
            }
            parseNumberIntegerExponentOrDecimal() {
              if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
              } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
              } else {
                return this.returnNow(Integer(this.state.buf));
              }
            }
            parseNumberInteger() {
              if (isDigit(this.char)) {
                this.consume();
              } else if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder);
              } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
              } else if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
              } else {
                const result = Integer(this.state.buf);
                if (result.isNaN()) {
                  throw this.error(new TomlError("Invalid number"));
                } else {
                  return this.returnNow(result);
                }
              }
            }
            parseNoUnder() {
              if (this.char === CHAR_LOWBAR || this.char === CHAR_PERIOD || this.char === CHAR_E || this.char === CHAR_e) {
                throw this.error(new TomlError("Unexpected character, expected digit"));
              } else if (this.atEndOfWord()) {
                throw this.error(new TomlError("Incomplete number"));
              }
              return this.returnNow();
            }
            parseNumberFloat() {
              if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder, this.parseNumberFloat);
              } else if (isDigit(this.char)) {
                this.consume();
              } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
              } else {
                return this.returnNow(Float(this.state.buf));
              }
            }
            parseNumberExponentSign() {
              if (isDigit(this.char)) {
                return this.goto(this.parseNumberExponent);
              } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.call(this.parseNoUnder, this.parseNumberExponent);
              } else {
                throw this.error(new TomlError("Unexpected character, expected -, + or digit"));
              }
            }
            parseNumberExponent() {
              if (isDigit(this.char)) {
                this.consume();
              } else if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder);
              } else {
                return this.returnNow(Float(this.state.buf));
              }
            }
            /* NUMBERS or DATETIMES  */
            parseNumberOrDateTime() {
              if (this.char === CHAR_0) {
                this.consume();
                return this.next(this.parseNumberBaseOrDateTime);
              } else {
                return this.goto(this.parseNumberOrDateTimeOnly);
              }
            }
            parseNumberOrDateTimeOnly() {
              if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder, this.parseNumberInteger);
              } else if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length > 4)
                  this.next(this.parseNumberInteger);
              } else if (this.char === CHAR_E || this.char === CHAR_e) {
                this.consume();
                return this.next(this.parseNumberExponentSign);
              } else if (this.char === CHAR_PERIOD) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseNumberFloat);
              } else if (this.char === CHAR_HYPHEN) {
                return this.goto(this.parseDateTime);
              } else if (this.char === CHAR_COLON) {
                return this.goto(this.parseOnlyTimeHour);
              } else {
                return this.returnNow(Integer(this.state.buf));
              }
            }
            parseDateTimeOnly() {
              if (this.state.buf.length < 4) {
                if (isDigit(this.char)) {
                  return this.consume();
                } else if (this.char === CHAR_COLON) {
                  return this.goto(this.parseOnlyTimeHour);
                } else {
                  throw this.error(new TomlError("Expected digit while parsing year part of a date"));
                }
              } else {
                if (this.char === CHAR_HYPHEN) {
                  return this.goto(this.parseDateTime);
                } else {
                  throw this.error(new TomlError("Expected hyphen (-) while parsing year part of date"));
                }
              }
            }
            parseNumberBaseOrDateTime() {
              if (this.char === CHAR_b) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerBin);
              } else if (this.char === CHAR_o) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerOct);
              } else if (this.char === CHAR_x) {
                this.consume();
                return this.call(this.parseNoUnder, this.parseIntegerHex);
              } else if (this.char === CHAR_PERIOD) {
                return this.goto(this.parseNumberInteger);
              } else if (isDigit(this.char)) {
                return this.goto(this.parseDateTimeOnly);
              } else {
                return this.returnNow(Integer(this.state.buf));
              }
            }
            parseIntegerHex() {
              if (isHexit(this.char)) {
                this.consume();
              } else if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder);
              } else {
                const result = Integer(this.state.buf);
                if (result.isNaN()) {
                  throw this.error(new TomlError("Invalid number"));
                } else {
                  return this.returnNow(result);
                }
              }
            }
            parseIntegerOct() {
              if (isOctit(this.char)) {
                this.consume();
              } else if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder);
              } else {
                const result = Integer(this.state.buf);
                if (result.isNaN()) {
                  throw this.error(new TomlError("Invalid number"));
                } else {
                  return this.returnNow(result);
                }
              }
            }
            parseIntegerBin() {
              if (isBit(this.char)) {
                this.consume();
              } else if (this.char === CHAR_LOWBAR) {
                return this.call(this.parseNoUnder);
              } else {
                const result = Integer(this.state.buf);
                if (result.isNaN()) {
                  throw this.error(new TomlError("Invalid number"));
                } else {
                  return this.returnNow(result);
                }
              }
            }
            /* DATETIME */
            parseDateTime() {
              if (this.state.buf.length < 4) {
                throw this.error(new TomlError("Years less than 1000 must be zero padded to four characters"));
              }
              this.state.result = this.state.buf;
              this.state.buf = "";
              return this.next(this.parseDateMonth);
            }
            parseDateMonth() {
              if (this.char === CHAR_HYPHEN) {
                if (this.state.buf.length < 2) {
                  throw this.error(new TomlError("Months less than 10 must be zero padded to two characters"));
                }
                this.state.result += "-" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseDateDay);
              } else if (isDigit(this.char)) {
                this.consume();
              } else {
                throw this.error(new TomlError("Incomplete datetime"));
              }
            }
            parseDateDay() {
              if (this.char === CHAR_T || this.char === CHAR_SP) {
                if (this.state.buf.length < 2) {
                  throw this.error(new TomlError("Days less than 10 must be zero padded to two characters"));
                }
                this.state.result += "-" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseStartTimeHour);
              } else if (this.atEndOfWord()) {
                return this.return(createDate(this.state.result + "-" + this.state.buf));
              } else if (isDigit(this.char)) {
                this.consume();
              } else {
                throw this.error(new TomlError("Incomplete datetime"));
              }
            }
            parseStartTimeHour() {
              if (this.atEndOfWord()) {
                return this.returnNow(createDate(this.state.result));
              } else {
                return this.goto(this.parseTimeHour);
              }
            }
            parseTimeHour() {
              if (this.char === CHAR_COLON) {
                if (this.state.buf.length < 2) {
                  throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                }
                this.state.result += "T" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseTimeMin);
              } else if (isDigit(this.char)) {
                this.consume();
              } else {
                throw this.error(new TomlError("Incomplete datetime"));
              }
            }
            parseTimeMin() {
              if (this.state.buf.length < 2 && isDigit(this.char)) {
                this.consume();
              } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
                this.state.result += ":" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseTimeSec);
              } else {
                throw this.error(new TomlError("Incomplete datetime"));
              }
            }
            parseTimeSec() {
              if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length === 2) {
                  this.state.result += ":" + this.state.buf;
                  this.state.buf = "";
                  return this.next(this.parseTimeZoneOrFraction);
                }
              } else {
                throw this.error(new TomlError("Incomplete datetime"));
              }
            }
            parseOnlyTimeHour() {
              if (this.char === CHAR_COLON) {
                if (this.state.buf.length < 2) {
                  throw this.error(new TomlError("Hours less than 10 must be zero padded to two characters"));
                }
                this.state.result = this.state.buf;
                this.state.buf = "";
                return this.next(this.parseOnlyTimeMin);
              } else {
                throw this.error(new TomlError("Incomplete time"));
              }
            }
            parseOnlyTimeMin() {
              if (this.state.buf.length < 2 && isDigit(this.char)) {
                this.consume();
              } else if (this.state.buf.length === 2 && this.char === CHAR_COLON) {
                this.state.result += ":" + this.state.buf;
                this.state.buf = "";
                return this.next(this.parseOnlyTimeSec);
              } else {
                throw this.error(new TomlError("Incomplete time"));
              }
            }
            parseOnlyTimeSec() {
              if (isDigit(this.char)) {
                this.consume();
                if (this.state.buf.length === 2) {
                  return this.next(this.parseOnlyTimeFractionMaybe);
                }
              } else {
                throw this.error(new TomlError("Incomplete time"));
              }
            }
            parseOnlyTimeFractionMaybe() {
              this.state.result += ":" + this.state.buf;
              if (this.char === CHAR_PERIOD) {
                this.state.buf = "";
                this.next(this.parseOnlyTimeFraction);
              } else {
                return this.return(createTime(this.state.result));
              }
            }
            parseOnlyTimeFraction() {
              if (isDigit(this.char)) {
                this.consume();
              } else if (this.atEndOfWord()) {
                if (this.state.buf.length === 0)
                  throw this.error(new TomlError("Expected digit in milliseconds"));
                return this.returnNow(createTime(this.state.result + "." + this.state.buf));
              } else {
                throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
              }
            }
            parseTimeZoneOrFraction() {
              if (this.char === CHAR_PERIOD) {
                this.consume();
                this.next(this.parseDateTimeFraction);
              } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.next(this.parseTimeZoneHour);
              } else if (this.char === CHAR_Z) {
                this.consume();
                return this.return(createDateTime(this.state.result + this.state.buf));
              } else if (this.atEndOfWord()) {
                return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
              } else {
                throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
              }
            }
            parseDateTimeFraction() {
              if (isDigit(this.char)) {
                this.consume();
              } else if (this.state.buf.length === 1) {
                throw this.error(new TomlError("Expected digit in milliseconds"));
              } else if (this.char === CHAR_HYPHEN || this.char === CHAR_PLUS) {
                this.consume();
                this.next(this.parseTimeZoneHour);
              } else if (this.char === CHAR_Z) {
                this.consume();
                return this.return(createDateTime(this.state.result + this.state.buf));
              } else if (this.atEndOfWord()) {
                return this.returnNow(createDateTimeFloat(this.state.result + this.state.buf));
              } else {
                throw this.error(new TomlError("Unexpected character in datetime, expected period (.), minus (-), plus (+) or Z"));
              }
            }
            parseTimeZoneHour() {
              if (isDigit(this.char)) {
                this.consume();
                if (/\d\d$/.test(this.state.buf))
                  return this.next(this.parseTimeZoneSep);
              } else {
                throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
              }
            }
            parseTimeZoneSep() {
              if (this.char === CHAR_COLON) {
                this.consume();
                this.next(this.parseTimeZoneMin);
              } else {
                throw this.error(new TomlError("Unexpected character in datetime, expected colon"));
              }
            }
            parseTimeZoneMin() {
              if (isDigit(this.char)) {
                this.consume();
                if (/\d\d$/.test(this.state.buf))
                  return this.return(createDateTime(this.state.result + this.state.buf));
              } else {
                throw this.error(new TomlError("Unexpected character in datetime, expected digit"));
              }
            }
            /* BOOLEAN */
            parseBoolean() {
              if (this.char === CHAR_t) {
                this.consume();
                return this.next(this.parseTrue_r);
              } else if (this.char === CHAR_f) {
                this.consume();
                return this.next(this.parseFalse_a);
              }
            }
            parseTrue_r() {
              if (this.char === CHAR_r) {
                this.consume();
                return this.next(this.parseTrue_u);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            parseTrue_u() {
              if (this.char === CHAR_u) {
                this.consume();
                return this.next(this.parseTrue_e);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            parseTrue_e() {
              if (this.char === CHAR_e) {
                return this.return(true);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            parseFalse_a() {
              if (this.char === CHAR_a) {
                this.consume();
                return this.next(this.parseFalse_l);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            parseFalse_l() {
              if (this.char === CHAR_l) {
                this.consume();
                return this.next(this.parseFalse_s);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            parseFalse_s() {
              if (this.char === CHAR_s) {
                this.consume();
                return this.next(this.parseFalse_e);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            parseFalse_e() {
              if (this.char === CHAR_e) {
                return this.return(false);
              } else {
                throw this.error(new TomlError("Invalid boolean, expected true or false"));
              }
            }
            /* INLINE LISTS */
            parseInlineList() {
              if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
                return null;
              } else if (this.char === Parser.END) {
                throw this.error(new TomlError("Unterminated inline array"));
              } else if (this.char === CHAR_NUM) {
                return this.call(this.parseComment);
              } else if (this.char === CHAR_RSQB) {
                return this.return(this.state.resultArr || InlineList());
              } else {
                return this.callNow(this.parseValue, this.recordInlineListValue);
              }
            }
            recordInlineListValue(value) {
              if (this.state.resultArr) {
                const listType = this.state.resultArr[_contentType];
                const valueType = tomlType(value);
                if (listType !== valueType) {
                  throw this.error(new TomlError(`Inline lists must be a single type, not a mix of ${listType} and ${valueType}`));
                }
              } else {
                this.state.resultArr = InlineList(tomlType(value));
              }
              if (isFloat(value) || isInteger(value)) {
                this.state.resultArr.push(value.valueOf());
              } else {
                this.state.resultArr.push(value);
              }
              return this.goto(this.parseInlineListNext);
            }
            parseInlineListNext() {
              if (this.char === CHAR_SP || this.char === CTRL_I || this.char === CTRL_M || this.char === CTRL_J) {
                return null;
              } else if (this.char === CHAR_NUM) {
                return this.call(this.parseComment);
              } else if (this.char === CHAR_COMMA) {
                return this.next(this.parseInlineList);
              } else if (this.char === CHAR_RSQB) {
                return this.goto(this.parseInlineList);
              } else {
                throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
              }
            }
            /* INLINE TABLE */
            parseInlineTable() {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
                throw this.error(new TomlError("Unterminated inline array"));
              } else if (this.char === CHAR_RCUB) {
                return this.return(this.state.resultTable || InlineTable());
              } else {
                if (!this.state.resultTable)
                  this.state.resultTable = InlineTable();
                return this.callNow(this.parseAssign, this.recordInlineTableValue);
              }
            }
            recordInlineTableValue(kv) {
              let target = this.state.resultTable;
              let finalKey = kv.key.pop();
              for (let kw of kv.key) {
                if (hasKey(target, kw) && (!isTable(target[kw]) || target[kw][_declared])) {
                  throw this.error(new TomlError("Can't redefine existing key"));
                }
                target = target[kw] = target[kw] || Table();
              }
              if (hasKey(target, finalKey)) {
                throw this.error(new TomlError("Can't redefine existing key"));
              }
              if (isInteger(kv.value) || isFloat(kv.value)) {
                target[finalKey] = kv.value.valueOf();
              } else {
                target[finalKey] = kv.value;
              }
              return this.goto(this.parseInlineTableNext);
            }
            parseInlineTableNext() {
              if (this.char === CHAR_SP || this.char === CTRL_I) {
                return null;
              } else if (this.char === Parser.END || this.char === CHAR_NUM || this.char === CTRL_J || this.char === CTRL_M) {
                throw this.error(new TomlError("Unterminated inline array"));
              } else if (this.char === CHAR_COMMA) {
                return this.next(this.parseInlineTable);
              } else if (this.char === CHAR_RCUB) {
                return this.goto(this.parseInlineTable);
              } else {
                throw this.error(new TomlError("Invalid character, expected whitespace, comma (,) or close bracket (])"));
              }
            }
          }
          return TOMLParser;
        }
      }
    });
    var require_parse_pretty_error = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/parse-pretty-error.js"(exports2, module2) {
        "use strict";
        module2.exports = prettyError;
        function prettyError(err, buf) {
          if (err.pos == null || err.line == null)
            return err;
          let msg = err.message;
          msg += ` at row ${err.line + 1}, col ${err.col + 1}, pos ${err.pos}:
`;
          if (buf && buf.split) {
            const lines = buf.split(/\n/);
            const lineNumWidth = String(Math.min(lines.length, err.line + 3)).length;
            let linePadding = " ";
            while (linePadding.length < lineNumWidth)
              linePadding += " ";
            for (let ii = Math.max(0, err.line - 1); ii < Math.min(lines.length, err.line + 2); ++ii) {
              let lineNum = String(ii + 1);
              if (lineNum.length < lineNumWidth)
                lineNum = " " + lineNum;
              if (err.line === ii) {
                msg += lineNum + "> " + lines[ii] + "\n";
                msg += linePadding + "  ";
                for (let hh = 0; hh < err.col; ++hh) {
                  msg += " ";
                }
                msg += "^\n";
              } else {
                msg += lineNum + ": " + lines[ii] + "\n";
              }
            }
          }
          err.message = msg + "\n";
          return err;
        }
      }
    });
    var require_parse_string = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/parse-string.js"(exports2, module2) {
        "use strict";
        module2.exports = parseString;
        var TOMLParser = require_toml_parser();
        var prettyError = require_parse_pretty_error();
        function parseString(str) {
          if (global.Buffer && global.Buffer.isBuffer(str)) {
            str = str.toString("utf8");
          }
          const parser = new TOMLParser();
          try {
            parser.parse(str);
            return parser.finish();
          } catch (err) {
            throw prettyError(err, str);
          }
        }
      }
    });
    var require_parse_async = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/parse-async.js"(exports2, module2) {
        "use strict";
        module2.exports = parseAsync;
        var TOMLParser = require_toml_parser();
        var prettyError = require_parse_pretty_error();
        function parseAsync(str, opts) {
          if (!opts)
            opts = {};
          const index = 0;
          const blocksize = opts.blocksize || 40960;
          const parser = new TOMLParser();
          return new Promise((resolve, reject) => {
            setImmediate(parseAsyncNext, index, blocksize, resolve, reject);
          });
          function parseAsyncNext(index2, blocksize2, resolve, reject) {
            if (index2 >= str.length) {
              try {
                return resolve(parser.finish());
              } catch (err) {
                return reject(prettyError(err, str));
              }
            }
            try {
              parser.parse(str.slice(index2, index2 + blocksize2));
              setImmediate(parseAsyncNext, index2 + blocksize2, blocksize2, resolve, reject);
            } catch (err) {
              reject(prettyError(err, str));
            }
          }
        }
      }
    });
    var require_parse_stream = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/parse-stream.js"(exports2, module2) {
        "use strict";
        module2.exports = parseStream;
        var stream = require("stream");
        var TOMLParser = require_toml_parser();
        function parseStream(stm) {
          if (stm) {
            return parseReadable(stm);
          } else {
            return parseTransform(stm);
          }
        }
        function parseReadable(stm) {
          const parser = new TOMLParser();
          stm.setEncoding("utf8");
          return new Promise((resolve, reject) => {
            let readable;
            let ended = false;
            let errored = false;
            function finish() {
              ended = true;
              if (readable)
                return;
              try {
                resolve(parser.finish());
              } catch (err) {
                reject(err);
              }
            }
            function error(err) {
              errored = true;
              reject(err);
            }
            stm.once("end", finish);
            stm.once("error", error);
            readNext();
            function readNext() {
              readable = true;
              let data;
              while ((data = stm.read()) !== null) {
                try {
                  parser.parse(data);
                } catch (err) {
                  return error(err);
                }
              }
              readable = false;
              if (ended)
                return finish();
              if (errored)
                return;
              stm.once("readable", readNext);
            }
          });
        }
        function parseTransform() {
          const parser = new TOMLParser();
          return new stream.Transform({
            objectMode: true,
            transform(chunk, encoding, cb) {
              try {
                parser.parse(chunk.toString(encoding));
              } catch (err) {
                this.emit("error", err);
              }
              cb();
            },
            flush(cb) {
              try {
                this.push(parser.finish());
              } catch (err) {
                this.emit("error", err);
              }
              cb();
            }
          });
        }
      }
    });
    var require_parse2 = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/parse.js"(exports2, module2) {
        "use strict";
        module2.exports = require_parse_string();
        module2.exports.async = require_parse_async();
        module2.exports.stream = require_parse_stream();
        module2.exports.prettyError = require_parse_pretty_error();
      }
    });
    var require_stringify = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/stringify.js"(exports2, module2) {
        "use strict";
        module2.exports = stringify;
        module2.exports.value = stringifyInline;
        function stringify(obj) {
          if (obj === null)
            throw typeError("null");
          if (obj === void 0)
            throw typeError("undefined");
          if (typeof obj !== "object")
            throw typeError(typeof obj);
          if (typeof obj.toJSON === "function")
            obj = obj.toJSON();
          if (obj == null)
            return null;
          const type = tomlType2(obj);
          if (type !== "table")
            throw typeError(type);
          return stringifyObject("", "", obj);
        }
        function typeError(type) {
          return new Error("Can only stringify objects, not " + type);
        }
        function arrayOneTypeError() {
          return new Error("Array values can't have mixed types");
        }
        function getInlineKeys(obj) {
          return Object.keys(obj).filter((key) => isInline(obj[key]));
        }
        function getComplexKeys(obj) {
          return Object.keys(obj).filter((key) => !isInline(obj[key]));
        }
        function toJSON(obj) {
          let nobj = Array.isArray(obj) ? [] : Object.prototype.hasOwnProperty.call(obj, "__proto__") ? { ["__proto__"]: void 0 } : {};
          for (let prop of Object.keys(obj)) {
            if (obj[prop] && typeof obj[prop].toJSON === "function" && !("toISOString" in obj[prop])) {
              nobj[prop] = obj[prop].toJSON();
            } else {
              nobj[prop] = obj[prop];
            }
          }
          return nobj;
        }
        function stringifyObject(prefix, indent, obj) {
          obj = toJSON(obj);
          var inlineKeys;
          var complexKeys;
          inlineKeys = getInlineKeys(obj);
          complexKeys = getComplexKeys(obj);
          var result = [];
          var inlineIndent = indent || "";
          inlineKeys.forEach((key) => {
            var type = tomlType2(obj[key]);
            if (type !== "undefined" && type !== "null") {
              result.push(inlineIndent + stringifyKey(key) + " = " + stringifyAnyInline(obj[key], true));
            }
          });
          if (result.length > 0)
            result.push("");
          var complexIndent = prefix && inlineKeys.length > 0 ? indent + "  " : "";
          complexKeys.forEach((key) => {
            result.push(stringifyComplex(prefix, complexIndent, key, obj[key]));
          });
          return result.join("\n");
        }
        function isInline(value) {
          switch (tomlType2(value)) {
            case "undefined":
            case "null":
            case "integer":
            case "nan":
            case "float":
            case "boolean":
            case "string":
            case "datetime":
              return true;
            case "array":
              return value.length === 0 || tomlType2(value[0]) !== "table";
            case "table":
              return Object.keys(value).length === 0;
            default:
              return false;
          }
        }
        function tomlType2(value) {
          if (value === void 0) {
            return "undefined";
          } else if (value === null) {
            return "null";
          } else if (typeof value === "bigint" || Number.isInteger(value) && !Object.is(value, -0)) {
            return "integer";
          } else if (typeof value === "number") {
            return "float";
          } else if (typeof value === "boolean") {
            return "boolean";
          } else if (typeof value === "string") {
            return "string";
          } else if ("toISOString" in value) {
            return isNaN(value) ? "undefined" : "datetime";
          } else if (Array.isArray(value)) {
            return "array";
          } else {
            return "table";
          }
        }
        function stringifyKey(key) {
          var keyStr = String(key);
          if (/^[-A-Za-z0-9_]+$/.test(keyStr)) {
            return keyStr;
          } else {
            return stringifyBasicString(keyStr);
          }
        }
        function stringifyBasicString(str) {
          return '"' + escapeString(str).replace(/"/g, '\\"') + '"';
        }
        function stringifyLiteralString(str) {
          return "'" + str + "'";
        }
        function numpad(num, str) {
          while (str.length < num)
            str = "0" + str;
          return str;
        }
        function escapeString(str) {
          return str.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/([\u0000-\u001f\u007f])/, (c) => "\\u" + numpad(4, c.codePointAt(0).toString(16)));
        }
        function stringifyMultilineString(str) {
          let escaped = str.split(/\n/).map((str2) => {
            return escapeString(str2).replace(/"(?="")/g, '\\"');
          }).join("\n");
          if (escaped.slice(-1) === '"')
            escaped += "\\\n";
          return '"""\n' + escaped + '"""';
        }
        function stringifyAnyInline(value, multilineOk) {
          let type = tomlType2(value);
          if (type === "string") {
            if (multilineOk && /\n/.test(value)) {
              type = "string-multiline";
            } else if (!/[\b\t\n\f\r']/.test(value) && /"/.test(value)) {
              type = "string-literal";
            }
          }
          return stringifyInline(value, type);
        }
        function stringifyInline(value, type) {
          if (!type)
            type = tomlType2(value);
          switch (type) {
            case "string-multiline":
              return stringifyMultilineString(value);
            case "string":
              return stringifyBasicString(value);
            case "string-literal":
              return stringifyLiteralString(value);
            case "integer":
              return stringifyInteger(value);
            case "float":
              return stringifyFloat(value);
            case "boolean":
              return stringifyBoolean(value);
            case "datetime":
              return stringifyDatetime(value);
            case "array":
              return stringifyInlineArray(value.filter((_) => tomlType2(_) !== "null" && tomlType2(_) !== "undefined" && tomlType2(_) !== "nan"));
            case "table":
              return stringifyInlineTable(value);
            default:
              throw typeError(type);
          }
        }
        function stringifyInteger(value) {
          return String(value).replace(/\B(?=(\d{3})+(?!\d))/g, "_");
        }
        function stringifyFloat(value) {
          if (value === Infinity) {
            return "inf";
          } else if (value === -Infinity) {
            return "-inf";
          } else if (Object.is(value, NaN)) {
            return "nan";
          } else if (Object.is(value, -0)) {
            return "-0.0";
          }
          var chunks = String(value).split(".");
          var int = chunks[0];
          var dec = chunks[1] || 0;
          return stringifyInteger(int) + "." + dec;
        }
        function stringifyBoolean(value) {
          return String(value);
        }
        function stringifyDatetime(value) {
          return value.toISOString();
        }
        function isNumber(type) {
          return type === "float" || type === "integer";
        }
        function arrayType(values) {
          var contentType = tomlType2(values[0]);
          if (values.every((_) => tomlType2(_) === contentType))
            return contentType;
          if (values.every((_) => isNumber(tomlType2(_))))
            return "float";
          return "mixed";
        }
        function validateArray(values) {
          const type = arrayType(values);
          if (type === "mixed") {
            throw arrayOneTypeError();
          }
          return type;
        }
        function stringifyInlineArray(values) {
          values = toJSON(values);
          const type = validateArray(values);
          var result = "[";
          var stringified = values.map((_) => stringifyInline(_, type));
          if (stringified.join(", ").length > 60 || /\n/.test(stringified)) {
            result += "\n  " + stringified.join(",\n  ") + "\n";
          } else {
            result += " " + stringified.join(", ") + (stringified.length > 0 ? " " : "");
          }
          return result + "]";
        }
        function stringifyInlineTable(value) {
          value = toJSON(value);
          var result = [];
          Object.keys(value).forEach((key) => {
            result.push(stringifyKey(key) + " = " + stringifyAnyInline(value[key], false));
          });
          return "{ " + result.join(", ") + (result.length > 0 ? " " : "") + "}";
        }
        function stringifyComplex(prefix, indent, key, value) {
          var valueType = tomlType2(value);
          if (valueType === "array") {
            return stringifyArrayOfTables(prefix, indent, key, value);
          } else if (valueType === "table") {
            return stringifyComplexTable(prefix, indent, key, value);
          } else {
            throw typeError(valueType);
          }
        }
        function stringifyArrayOfTables(prefix, indent, key, values) {
          values = toJSON(values);
          validateArray(values);
          var firstValueType = tomlType2(values[0]);
          if (firstValueType !== "table")
            throw typeError(firstValueType);
          var fullKey = prefix + stringifyKey(key);
          var result = "";
          values.forEach((table) => {
            if (result.length > 0)
              result += "\n";
            result += indent + "[[" + fullKey + "]]\n";
            result += stringifyObject(fullKey + ".", indent, table);
          });
          return result;
        }
        function stringifyComplexTable(prefix, indent, key, value) {
          var fullKey = prefix + stringifyKey(key);
          var result = "";
          if (getInlineKeys(value).length > 0) {
            result += indent + "[" + fullKey + "]\n";
          }
          return result + stringifyObject(fullKey + ".", indent, value);
        }
      }
    });
    var require_toml = __commonJS({
      "../../node_modules/.pnpm/@iarna+toml@2.2.3/node_modules/@iarna/toml/toml.js"(exports2) {
        "use strict";
        exports2.parse = require_parse2();
        exports2.stringify = require_stringify();
      }
    });
    var require_dist = __commonJS({
      "../error-utils/dist/index.js"(exports2, module2) {
        "use strict";
        var __create22 = Object.create;
        var __defProp22 = Object.defineProperty;
        var __getOwnPropDesc22 = Object.getOwnPropertyDescriptor;
        var __getOwnPropNames22 = Object.getOwnPropertyNames;
        var __getProtoOf22 = Object.getPrototypeOf;
        var __hasOwnProp22 = Object.prototype.hasOwnProperty;
        var __export2 = (target, all) => {
          for (var name in all)
            __defProp22(target, name, { get: all[name], enumerable: true });
        };
        var __copyProps22 = (to, from, except, desc) => {
          if (from && typeof from === "object" || typeof from === "function") {
            for (let key of __getOwnPropNames22(from))
              if (!__hasOwnProp22.call(to, key) && key !== except)
                __defProp22(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc22(from, key)) || desc.enumerable });
          }
          return to;
        };
        var __toESM22 = (mod, isNodeMode, target) => (target = mod != null ? __create22(__getProtoOf22(mod)) : {}, __copyProps22(
          // If the importer is in node compatibility mode or this is not an ESM
          // file that has been converted to a CommonJS file using a Babel-
          // compatible transform (i.e. "__esModule" has not been set), then set
          // "default" to the CommonJS "module.exports" for node compatibility.
          isNodeMode || !mod || !mod.__esModule ? __defProp22(target, "default", { value: mod, enumerable: true }) : target,
          mod
        ));
        var __toCommonJS2 = (mod) => __copyProps22(__defProp22({}, "__esModule", { value: true }), mod);
        var src_exports2 = {};
        __export2(src_exports2, {
          errorToString: () => errorToString,
          isErrnoException: () => isErrnoException3,
          isError: () => isError,
          isErrorLike: () => isErrorLike,
          isObject: () => isObject,
          isSpawnError: () => isSpawnError,
          normalizeError: () => normalizeError
        });
        module2.exports = __toCommonJS2(src_exports2);
        var import_node_util = __toESM22(require("util"));
        var isObject = (obj) => typeof obj === "object" && obj !== null;
        var isError = (error) => {
          return import_node_util.default.types.isNativeError(error);
        };
        var isErrnoException3 = (error) => {
          return isError(error) && "code" in error;
        };
        var isErrorLike = (error) => isObject(error) && "message" in error;
        var errorToString = (error, fallback) => {
          if (isError(error) || isErrorLike(error))
            return error.message;
          if (typeof error === "string")
            return error;
          return fallback ?? "An unknown error has ocurred.";
        };
        var normalizeError = (error) => {
          if (isError(error))
            return error;
          const errorMessage = errorToString(error);
          return isErrorLike(error) ? Object.assign(new Error(errorMessage), error) : new Error(errorMessage);
        };
        function isSpawnError(v) {
          return isErrnoException3(v) && "spawnargs" in v;
        }
      }
    });
    var require_unicode = __commonJS({
      "../../node_modules/.pnpm/json5@2.2.3/node_modules/json5/lib/unicode.js"(exports2, module2) {
        module2.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
        module2.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
        module2.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
      }
    });
    var require_util2 = __commonJS({
      "../../node_modules/.pnpm/json5@2.2.3/node_modules/json5/lib/util.js"(exports2, module2) {
        var unicode = require_unicode();
        module2.exports = {
          isSpaceSeparator(c) {
            return typeof c === "string" && unicode.Space_Separator.test(c);
          },
          isIdStartChar(c) {
            return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
          },
          isIdContinueChar(c) {
            return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
          },
          isDigit(c) {
            return typeof c === "string" && /[0-9]/.test(c);
          },
          isHexDigit(c) {
            return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
          }
        };
      }
    });
    var require_parse3 = __commonJS({
      "../../node_modules/.pnpm/json5@2.2.3/node_modules/json5/lib/parse.js"(exports2, module2) {
        var util = require_util2();
        var source;
        var parseState;
        var stack;
        var pos;
        var line;
        var column;
        var token;
        var key;
        var root;
        module2.exports = function parse3(text, reviver) {
          source = String(text);
          parseState = "start";
          stack = [];
          pos = 0;
          line = 1;
          column = 0;
          token = void 0;
          key = void 0;
          root = void 0;
          do {
            token = lex();
            parseStates[parseState]();
          } while (token.type !== "eof");
          if (typeof reviver === "function") {
            return internalize({ "": root }, "", reviver);
          }
          return root;
        };
        function internalize(holder, name, reviver) {
          const value = holder[name];
          if (value != null && typeof value === "object") {
            if (Array.isArray(value)) {
              for (let i = 0; i < value.length; i++) {
                const key2 = String(i);
                const replacement = internalize(value, key2, reviver);
                if (replacement === void 0) {
                  delete value[key2];
                } else {
                  Object.defineProperty(value, key2, {
                    value: replacement,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
            } else {
              for (const key2 in value) {
                const replacement = internalize(value, key2, reviver);
                if (replacement === void 0) {
                  delete value[key2];
                } else {
                  Object.defineProperty(value, key2, {
                    value: replacement,
                    writable: true,
                    enumerable: true,
                    configurable: true
                  });
                }
              }
            }
          }
          return reviver.call(holder, name, value);
        }
        var lexState;
        var buffer;
        var doubleQuote;
        var sign;
        var c;
        function lex() {
          lexState = "default";
          buffer = "";
          doubleQuote = false;
          sign = 1;
          for (; ; ) {
            c = peek();
            const token2 = lexStates[lexState]();
            if (token2) {
              return token2;
            }
          }
        }
        function peek() {
          if (source[pos]) {
            return String.fromCodePoint(source.codePointAt(pos));
          }
        }
        function read() {
          const c2 = peek();
          if (c2 === "\n") {
            line++;
            column = 0;
          } else if (c2) {
            column += c2.length;
          } else {
            column++;
          }
          if (c2) {
            pos += c2.length;
          }
          return c2;
        }
        var lexStates = {
          default() {
            switch (c) {
              case "	":
              case "\v":
              case "\f":
              case " ":
              case "\xA0":
              case "\uFEFF":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                read();
                return;
              case "/":
                read();
                lexState = "comment";
                return;
              case void 0:
                read();
                return newToken("eof");
            }
            if (util.isSpaceSeparator(c)) {
              read();
              return;
            }
            return lexStates[parseState]();
          },
          comment() {
            switch (c) {
              case "*":
                read();
                lexState = "multiLineComment";
                return;
              case "/":
                read();
                lexState = "singleLineComment";
                return;
            }
            throw invalidChar(read());
          },
          multiLineComment() {
            switch (c) {
              case "*":
                read();
                lexState = "multiLineCommentAsterisk";
                return;
              case void 0:
                throw invalidChar(read());
            }
            read();
          },
          multiLineCommentAsterisk() {
            switch (c) {
              case "*":
                read();
                return;
              case "/":
                read();
                lexState = "default";
                return;
              case void 0:
                throw invalidChar(read());
            }
            read();
            lexState = "multiLineComment";
          },
          singleLineComment() {
            switch (c) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                read();
                lexState = "default";
                return;
              case void 0:
                read();
                return newToken("eof");
            }
            read();
          },
          value() {
            switch (c) {
              case "{":
              case "[":
                return newToken("punctuator", read());
              case "n":
                read();
                literal("ull");
                return newToken("null", null);
              case "t":
                read();
                literal("rue");
                return newToken("boolean", true);
              case "f":
                read();
                literal("alse");
                return newToken("boolean", false);
              case "-":
              case "+":
                if (read() === "-") {
                  sign = -1;
                }
                lexState = "sign";
                return;
              case ".":
                buffer = read();
                lexState = "decimalPointLeading";
                return;
              case "0":
                buffer = read();
                lexState = "zero";
                return;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                buffer = read();
                lexState = "decimalInteger";
                return;
              case "I":
                read();
                literal("nfinity");
                return newToken("numeric", Infinity);
              case "N":
                read();
                literal("aN");
                return newToken("numeric", NaN);
              case '"':
              case "'":
                doubleQuote = read() === '"';
                buffer = "";
                lexState = "string";
                return;
            }
            throw invalidChar(read());
          },
          identifierNameStartEscape() {
            if (c !== "u") {
              throw invalidChar(read());
            }
            read();
            const u = unicodeEscape();
            switch (u) {
              case "$":
              case "_":
                break;
              default:
                if (!util.isIdStartChar(u)) {
                  throw invalidIdentifier();
                }
                break;
            }
            buffer += u;
            lexState = "identifierName";
          },
          identifierName() {
            switch (c) {
              case "$":
              case "_":
              case "\u200C":
              case "\u200D":
                buffer += read();
                return;
              case "\\":
                read();
                lexState = "identifierNameEscape";
                return;
            }
            if (util.isIdContinueChar(c)) {
              buffer += read();
              return;
            }
            return newToken("identifier", buffer);
          },
          identifierNameEscape() {
            if (c !== "u") {
              throw invalidChar(read());
            }
            read();
            const u = unicodeEscape();
            switch (u) {
              case "$":
              case "_":
              case "\u200C":
              case "\u200D":
                break;
              default:
                if (!util.isIdContinueChar(u)) {
                  throw invalidIdentifier();
                }
                break;
            }
            buffer += u;
            lexState = "identifierName";
          },
          sign() {
            switch (c) {
              case ".":
                buffer = read();
                lexState = "decimalPointLeading";
                return;
              case "0":
                buffer = read();
                lexState = "zero";
                return;
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                buffer = read();
                lexState = "decimalInteger";
                return;
              case "I":
                read();
                literal("nfinity");
                return newToken("numeric", sign * Infinity);
              case "N":
                read();
                literal("aN");
                return newToken("numeric", NaN);
            }
            throw invalidChar(read());
          },
          zero() {
            switch (c) {
              case ".":
                buffer += read();
                lexState = "decimalPoint";
                return;
              case "e":
              case "E":
                buffer += read();
                lexState = "decimalExponent";
                return;
              case "x":
              case "X":
                buffer += read();
                lexState = "hexadecimal";
                return;
            }
            return newToken("numeric", sign * 0);
          },
          decimalInteger() {
            switch (c) {
              case ".":
                buffer += read();
                lexState = "decimalPoint";
                return;
              case "e":
              case "E":
                buffer += read();
                lexState = "decimalExponent";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          },
          decimalPointLeading() {
            if (util.isDigit(c)) {
              buffer += read();
              lexState = "decimalFraction";
              return;
            }
            throw invalidChar(read());
          },
          decimalPoint() {
            switch (c) {
              case "e":
              case "E":
                buffer += read();
                lexState = "decimalExponent";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read();
              lexState = "decimalFraction";
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          },
          decimalFraction() {
            switch (c) {
              case "e":
              case "E":
                buffer += read();
                lexState = "decimalExponent";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          },
          decimalExponent() {
            switch (c) {
              case "+":
              case "-":
                buffer += read();
                lexState = "decimalExponentSign";
                return;
            }
            if (util.isDigit(c)) {
              buffer += read();
              lexState = "decimalExponentInteger";
              return;
            }
            throw invalidChar(read());
          },
          decimalExponentSign() {
            if (util.isDigit(c)) {
              buffer += read();
              lexState = "decimalExponentInteger";
              return;
            }
            throw invalidChar(read());
          },
          decimalExponentInteger() {
            if (util.isDigit(c)) {
              buffer += read();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          },
          hexadecimal() {
            if (util.isHexDigit(c)) {
              buffer += read();
              lexState = "hexadecimalInteger";
              return;
            }
            throw invalidChar(read());
          },
          hexadecimalInteger() {
            if (util.isHexDigit(c)) {
              buffer += read();
              return;
            }
            return newToken("numeric", sign * Number(buffer));
          },
          string() {
            switch (c) {
              case "\\":
                read();
                buffer += escape();
                return;
              case '"':
                if (doubleQuote) {
                  read();
                  return newToken("string", buffer);
                }
                buffer += read();
                return;
              case "'":
                if (!doubleQuote) {
                  read();
                  return newToken("string", buffer);
                }
                buffer += read();
                return;
              case "\n":
              case "\r":
                throw invalidChar(read());
              case "\u2028":
              case "\u2029":
                separatorChar(c);
                break;
              case void 0:
                throw invalidChar(read());
            }
            buffer += read();
          },
          start() {
            switch (c) {
              case "{":
              case "[":
                return newToken("punctuator", read());
            }
            lexState = "value";
          },
          beforePropertyName() {
            switch (c) {
              case "$":
              case "_":
                buffer = read();
                lexState = "identifierName";
                return;
              case "\\":
                read();
                lexState = "identifierNameStartEscape";
                return;
              case "}":
                return newToken("punctuator", read());
              case '"':
              case "'":
                doubleQuote = read() === '"';
                lexState = "string";
                return;
            }
            if (util.isIdStartChar(c)) {
              buffer += read();
              lexState = "identifierName";
              return;
            }
            throw invalidChar(read());
          },
          afterPropertyName() {
            if (c === ":") {
              return newToken("punctuator", read());
            }
            throw invalidChar(read());
          },
          beforePropertyValue() {
            lexState = "value";
          },
          afterPropertyValue() {
            switch (c) {
              case ",":
              case "}":
                return newToken("punctuator", read());
            }
            throw invalidChar(read());
          },
          beforeArrayValue() {
            if (c === "]") {
              return newToken("punctuator", read());
            }
            lexState = "value";
          },
          afterArrayValue() {
            switch (c) {
              case ",":
              case "]":
                return newToken("punctuator", read());
            }
            throw invalidChar(read());
          },
          end() {
            throw invalidChar(read());
          }
        };
        function newToken(type, value) {
          return {
            type,
            value,
            line,
            column
          };
        }
        function literal(s) {
          for (const c2 of s) {
            const p = peek();
            if (p !== c2) {
              throw invalidChar(read());
            }
            read();
          }
        }
        function escape() {
          const c2 = peek();
          switch (c2) {
            case "b":
              read();
              return "\b";
            case "f":
              read();
              return "\f";
            case "n":
              read();
              return "\n";
            case "r":
              read();
              return "\r";
            case "t":
              read();
              return "	";
            case "v":
              read();
              return "\v";
            case "0":
              read();
              if (util.isDigit(peek())) {
                throw invalidChar(read());
              }
              return "\0";
            case "x":
              read();
              return hexEscape();
            case "u":
              read();
              return unicodeEscape();
            case "\n":
            case "\u2028":
            case "\u2029":
              read();
              return "";
            case "\r":
              read();
              if (peek() === "\n") {
                read();
              }
              return "";
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              throw invalidChar(read());
            case void 0:
              throw invalidChar(read());
          }
          return read();
        }
        function hexEscape() {
          let buffer2 = "";
          let c2 = peek();
          if (!util.isHexDigit(c2)) {
            throw invalidChar(read());
          }
          buffer2 += read();
          c2 = peek();
          if (!util.isHexDigit(c2)) {
            throw invalidChar(read());
          }
          buffer2 += read();
          return String.fromCodePoint(parseInt(buffer2, 16));
        }
        function unicodeEscape() {
          let buffer2 = "";
          let count = 4;
          while (count-- > 0) {
            const c2 = peek();
            if (!util.isHexDigit(c2)) {
              throw invalidChar(read());
            }
            buffer2 += read();
          }
          return String.fromCodePoint(parseInt(buffer2, 16));
        }
        var parseStates = {
          start() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            push();
          },
          beforePropertyName() {
            switch (token.type) {
              case "identifier":
              case "string":
                key = token.value;
                parseState = "afterPropertyName";
                return;
              case "punctuator":
                pop();
                return;
              case "eof":
                throw invalidEOF();
            }
          },
          afterPropertyName() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            parseState = "beforePropertyValue";
          },
          beforePropertyValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            push();
          },
          beforeArrayValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            if (token.type === "punctuator" && token.value === "]") {
              pop();
              return;
            }
            push();
          },
          afterPropertyValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            switch (token.value) {
              case ",":
                parseState = "beforePropertyName";
                return;
              case "}":
                pop();
            }
          },
          afterArrayValue() {
            if (token.type === "eof") {
              throw invalidEOF();
            }
            switch (token.value) {
              case ",":
                parseState = "beforeArrayValue";
                return;
              case "]":
                pop();
            }
          },
          end() {
          }
        };
        function push() {
          let value;
          switch (token.type) {
            case "punctuator":
              switch (token.value) {
                case "{":
                  value = {};
                  break;
                case "[":
                  value = [];
                  break;
              }
              break;
            case "null":
            case "boolean":
            case "numeric":
            case "string":
              value = token.value;
              break;
          }
          if (root === void 0) {
            root = value;
          } else {
            const parent = stack[stack.length - 1];
            if (Array.isArray(parent)) {
              parent.push(value);
            } else {
              Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
          if (value !== null && typeof value === "object") {
            stack.push(value);
            if (Array.isArray(value)) {
              parseState = "beforeArrayValue";
            } else {
              parseState = "beforePropertyName";
            }
          } else {
            const current = stack[stack.length - 1];
            if (current == null) {
              parseState = "end";
            } else if (Array.isArray(current)) {
              parseState = "afterArrayValue";
            } else {
              parseState = "afterPropertyValue";
            }
          }
        }
        function pop() {
          stack.pop();
          const current = stack[stack.length - 1];
          if (current == null) {
            parseState = "end";
          } else if (Array.isArray(current)) {
            parseState = "afterArrayValue";
          } else {
            parseState = "afterPropertyValue";
          }
        }
        function invalidChar(c2) {
          if (c2 === void 0) {
            return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
          }
          return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
        }
        function invalidEOF() {
          return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
        }
        function invalidIdentifier() {
          column -= 5;
          return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
        }
        function separatorChar(c2) {
          console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
        }
        function formatChar(c2) {
          const replacements = {
            "'": "\\'",
            '"': '\\"',
            "\\": "\\\\",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "\v": "\\v",
            "\0": "\\0",
            "\u2028": "\\u2028",
            "\u2029": "\\u2029"
          };
          if (replacements[c2]) {
            return replacements[c2];
          }
          if (c2 < " ") {
            const hexString = c2.charCodeAt(0).toString(16);
            return "\\x" + ("00" + hexString).substring(hexString.length);
          }
          return c2;
        }
        function syntaxError(message) {
          const err = new SyntaxError(message);
          err.lineNumber = line;
          err.columnNumber = column;
          return err;
        }
      }
    });
    var require_stringify2 = __commonJS({
      "../../node_modules/.pnpm/json5@2.2.3/node_modules/json5/lib/stringify.js"(exports2, module2) {
        var util = require_util2();
        module2.exports = function stringify(value, replacer, space) {
          const stack = [];
          let indent = "";
          let propertyList;
          let replacerFunc;
          let gap = "";
          let quote;
          if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
            space = replacer.space;
            quote = replacer.quote;
            replacer = replacer.replacer;
          }
          if (typeof replacer === "function") {
            replacerFunc = replacer;
          } else if (Array.isArray(replacer)) {
            propertyList = [];
            for (const v of replacer) {
              let item;
              if (typeof v === "string") {
                item = v;
              } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
                item = String(v);
              }
              if (item !== void 0 && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
              }
            }
          }
          if (space instanceof Number) {
            space = Number(space);
          } else if (space instanceof String) {
            space = String(space);
          }
          if (typeof space === "number") {
            if (space > 0) {
              space = Math.min(10, Math.floor(space));
              gap = "          ".substr(0, space);
            }
          } else if (typeof space === "string") {
            gap = space.substr(0, 10);
          }
          return serializeProperty("", { "": value });
          function serializeProperty(key, holder) {
            let value2 = holder[key];
            if (value2 != null) {
              if (typeof value2.toJSON5 === "function") {
                value2 = value2.toJSON5(key);
              } else if (typeof value2.toJSON === "function") {
                value2 = value2.toJSON(key);
              }
            }
            if (replacerFunc) {
              value2 = replacerFunc.call(holder, key, value2);
            }
            if (value2 instanceof Number) {
              value2 = Number(value2);
            } else if (value2 instanceof String) {
              value2 = String(value2);
            } else if (value2 instanceof Boolean) {
              value2 = value2.valueOf();
            }
            switch (value2) {
              case null:
                return "null";
              case true:
                return "true";
              case false:
                return "false";
            }
            if (typeof value2 === "string") {
              return quoteString(value2, false);
            }
            if (typeof value2 === "number") {
              return String(value2);
            }
            if (typeof value2 === "object") {
              return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
            }
            return void 0;
          }
          function quoteString(value2) {
            const quotes = {
              "'": 0.1,
              '"': 0.2
            };
            const replacements = {
              "'": "\\'",
              '"': '\\"',
              "\\": "\\\\",
              "\b": "\\b",
              "\f": "\\f",
              "\n": "\\n",
              "\r": "\\r",
              "	": "\\t",
              "\v": "\\v",
              "\0": "\\0",
              "\u2028": "\\u2028",
              "\u2029": "\\u2029"
            };
            let product = "";
            for (let i = 0; i < value2.length; i++) {
              const c = value2[i];
              switch (c) {
                case "'":
                case '"':
                  quotes[c]++;
                  product += c;
                  continue;
                case "\0":
                  if (util.isDigit(value2[i + 1])) {
                    product += "\\x00";
                    continue;
                  }
              }
              if (replacements[c]) {
                product += replacements[c];
                continue;
              }
              if (c < " ") {
                let hexString = c.charCodeAt(0).toString(16);
                product += "\\x" + ("00" + hexString).substring(hexString.length);
                continue;
              }
              product += c;
            }
            const quoteChar = quote || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
            product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
            return quoteChar + product + quoteChar;
          }
          function serializeObject(value2) {
            if (stack.indexOf(value2) >= 0) {
              throw TypeError("Converting circular structure to JSON5");
            }
            stack.push(value2);
            let stepback = indent;
            indent = indent + gap;
            let keys = propertyList || Object.keys(value2);
            let partial = [];
            for (const key of keys) {
              const propertyString = serializeProperty(key, value2);
              if (propertyString !== void 0) {
                let member = serializeKey(key) + ":";
                if (gap !== "") {
                  member += " ";
                }
                member += propertyString;
                partial.push(member);
              }
            }
            let final;
            if (partial.length === 0) {
              final = "{}";
            } else {
              let properties;
              if (gap === "") {
                properties = partial.join(",");
                final = "{" + properties + "}";
              } else {
                let separator = ",\n" + indent;
                properties = partial.join(separator);
                final = "{\n" + indent + properties + ",\n" + stepback + "}";
              }
            }
            stack.pop();
            indent = stepback;
            return final;
          }
          function serializeKey(key) {
            if (key.length === 0) {
              return quoteString(key, true);
            }
            const firstChar = String.fromCodePoint(key.codePointAt(0));
            if (!util.isIdStartChar(firstChar)) {
              return quoteString(key, true);
            }
            for (let i = firstChar.length; i < key.length; i++) {
              if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
                return quoteString(key, true);
              }
            }
            return key;
          }
          function serializeArray(value2) {
            if (stack.indexOf(value2) >= 0) {
              throw TypeError("Converting circular structure to JSON5");
            }
            stack.push(value2);
            let stepback = indent;
            indent = indent + gap;
            let partial = [];
            for (let i = 0; i < value2.length; i++) {
              const propertyString = serializeProperty(String(i), value2);
              partial.push(propertyString !== void 0 ? propertyString : "null");
            }
            let final;
            if (partial.length === 0) {
              final = "[]";
            } else {
              if (gap === "") {
                let properties = partial.join(",");
                final = "[" + properties + "]";
              } else {
                let separator = ",\n" + indent;
                let properties = partial.join(separator);
                final = "[\n" + indent + properties + ",\n" + stepback + "]";
              }
            }
            stack.pop();
            indent = stepback;
            return final;
          }
        };
      }
    });
    var require_lib5 = __commonJS({
      "../../node_modules/.pnpm/json5@2.2.3/node_modules/json5/lib/index.js"(exports2, module2) {
        var parse3 = require_parse3();
        var stringify = require_stringify2();
        var JSON5 = {
          parse: parse3,
          stringify
        };
        module2.exports = JSON5;
      }
    });
    var require_ignore = __commonJS({
      "../../node_modules/.pnpm/ignore@4.0.6/node_modules/ignore/index.js"(exports2, module2) {
        function make_array(subject) {
          return Array.isArray(subject) ? subject : [subject];
        }
        var REGEX_BLANK_LINE = /^\s+$/;
        var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
        var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
        var SLASH = "/";
        var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
        var define = (object, key, value) => Object.defineProperty(object, key, { value });
        var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
        var sanitizeRange = (range) => range.replace(
          REGEX_REGEXP_RANGE,
          (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : ""
        );
        var DEFAULT_REPLACER_PREFIX = [
          // > Trailing spaces are ignored unless they are quoted with backslash ("\")
          [
            // (a\ ) -> (a )
            // (a  ) -> (a)
            // (a \ ) -> (a  )
            /\\?\s+$/,
            (match) => match.indexOf("\\") === 0 ? " " : ""
          ],
          // replace (\ ) with ' '
          [
            /\\\s/g,
            () => " "
          ],
          // Escape metacharacters
          // which is written down by users but means special for regular expressions.
          // > There are 12 characters with special meanings:
          // > - the backslash \,
          // > - the caret ^,
          // > - the dollar sign $,
          // > - the period or dot .,
          // > - the vertical bar or pipe symbol |,
          // > - the question mark ?,
          // > - the asterisk or star *,
          // > - the plus sign +,
          // > - the opening parenthesis (,
          // > - the closing parenthesis ),
          // > - and the opening square bracket [,
          // > - the opening curly brace {,
          // > These special characters are often called "metacharacters".
          [
            /[\\^$.|*+(){]/g,
            (match) => `\\${match}`
          ],
          [
            // > [abc] matches any character inside the brackets
            // >    (in this case a, b, or c);
            /\[([^\]/]*)($|\])/g,
            (match, p1, p2) => p2 === "]" ? `[${sanitizeRange(p1)}]` : `\\${match}`
          ],
          [
            // > a question mark (?) matches a single character
            /(?!\\)\?/g,
            () => "[^/]"
          ],
          // leading slash
          [
            // > A leading slash matches the beginning of the pathname.
            // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
            // A leading slash matches the beginning of the pathname
            /^\//,
            () => "^"
          ],
          // replace special metacharacter slash after the leading slash
          [
            /\//g,
            () => "\\/"
          ],
          [
            // > A leading "**" followed by a slash means match in all directories.
            // > For example, "**/foo" matches file or directory "foo" anywhere,
            // > the same as pattern "foo".
            // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
            // >   under directory "foo".
            // Notice that the '*'s have been replaced as '\\*'
            /^\^*\\\*\\\*\\\//,
            // '**/foo' <-> 'foo'
            () => "^(?:.*\\/)?"
          ]
        ];
        var DEFAULT_REPLACER_SUFFIX = [
          // starting
          [
            // there will be no leading '/'
            //   (which has been replaced by section "leading slash")
            // If starts with '**', adding a '^' to the regular expression also works
            /^(?=[^^])/,
            function startingReplacer() {
              return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
            }
          ],
          // two globstars
          [
            // Use lookahead assertions so that we could match more than one `'/**'`
            /\\\/\\\*\\\*(?=\\\/|$)/g,
            // Zero, one or several directories
            // should not use '*', or it will be replaced by the next replacer
            // Check if it is not the last `'/**'`
            (match, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
          ],
          // intermediate wildcards
          [
            // Never replace escaped '*'
            // ignore rule '\*' will match the path '*'
            // 'abc.*/' -> go
            // 'abc.*'  -> skip this rule
            /(^|[^\\]+)\\\*(?=.+)/g,
            // '*.js' matches '.js'
            // '*.js' doesn't match 'abc'
            (match, p1) => `${p1}[^\\/]*`
          ],
          // trailing wildcard
          [
            /(\^|\\\/)?\\\*$/,
            (match, p1) => {
              const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
              return `${prefix}(?=$|\\/$)`;
            }
          ],
          [
            // unescape
            /\\\\\\/g,
            () => "\\"
          ]
        ];
        var POSITIVE_REPLACERS = [
          ...DEFAULT_REPLACER_PREFIX,
          // 'f'
          // matches
          // - /f(end)
          // - /f/
          // - (start)f(end)
          // - (start)f/
          // doesn't match
          // - oof
          // - foo
          // pseudo:
          // -> (^|/)f(/|$)
          // ending
          [
            // 'js' will not match 'js.'
            // 'ab' will not match 'abc'
            /(?:[^*/])$/,
            // 'js*' will not match 'a.js'
            // 'js/' will not match 'a.js'
            // 'js' will match 'a.js' and 'a.js/'
            (match) => `${match}(?=$|\\/)`
          ],
          ...DEFAULT_REPLACER_SUFFIX
        ];
        var NEGATIVE_REPLACERS = [
          ...DEFAULT_REPLACER_PREFIX,
          // #24, #38
          // The MISSING rule of [gitignore docs](https://git-scm.com/docs/gitignore)
          // A negative pattern without a trailing wildcard should not
          // re-include the things inside that directory.
          // eg:
          // ['node_modules/*', '!node_modules']
          // should ignore `node_modules/a.js`
          [
            /(?:[^*])$/,
            (match) => `${match}(?=$|\\/$)`
          ],
          ...DEFAULT_REPLACER_SUFFIX
        ];
        var cache = /* @__PURE__ */ Object.create(null);
        var make_regex = (pattern, negative, ignorecase) => {
          const r = cache[pattern];
          if (r) {
            return r;
          }
          const replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;
          const source = replacers.reduce(
            (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
            pattern
          );
          return cache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
        };
        var checkPattern = (pattern) => pattern && typeof pattern === "string" && !REGEX_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
        var createRule = (pattern, ignorecase) => {
          const origin = pattern;
          let negative = false;
          if (pattern.indexOf("!") === 0) {
            negative = true;
            pattern = pattern.substr(1);
          }
          pattern = pattern.replace(REGEX_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_LEADING_EXCAPED_HASH, "#");
          const regex = make_regex(pattern, negative, ignorecase);
          return {
            origin,
            pattern,
            negative,
            regex
          };
        };
        var IgnoreBase = class {
          constructor({
            ignorecase = true
          } = {}) {
            this._rules = [];
            this._ignorecase = ignorecase;
            define(this, KEY_IGNORE, true);
            this._initCache();
          }
          _initCache() {
            this._cache = /* @__PURE__ */ Object.create(null);
          }
          // @param {Array.<string>|string|Ignore} pattern
          add(pattern) {
            this._added = false;
            if (typeof pattern === "string") {
              pattern = pattern.split(/\r?\n/g);
            }
            make_array(pattern).forEach(this._addPattern, this);
            if (this._added) {
              this._initCache();
            }
            return this;
          }
          // legacy
          addPattern(pattern) {
            return this.add(pattern);
          }
          _addPattern(pattern) {
            if (pattern && pattern[KEY_IGNORE]) {
              this._rules = this._rules.concat(pattern._rules);
              this._added = true;
              return;
            }
            if (checkPattern(pattern)) {
              const rule = createRule(pattern, this._ignorecase);
              this._added = true;
              this._rules.push(rule);
            }
          }
          filter(paths) {
            return make_array(paths).filter((path7) => this._filter(path7));
          }
          createFilter() {
            return (path7) => this._filter(path7);
          }
          ignores(path7) {
            return !this._filter(path7);
          }
          // @returns `Boolean` true if the `path` is NOT ignored
          _filter(path7, slices) {
            if (!path7) {
              return false;
            }
            if (path7 in this._cache) {
              return this._cache[path7];
            }
            if (!slices) {
              slices = path7.split(SLASH);
            }
            slices.pop();
            return this._cache[path7] = slices.length ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path7) : this._test(path7);
          }
          // @returns {Boolean} true if a file is NOT ignored
          _test(path7) {
            let matched = 0;
            this._rules.forEach((rule) => {
              if (!(matched ^ rule.negative)) {
                matched = rule.negative ^ rule.regex.test(path7);
              }
            });
            return !matched;
          }
        };
        if (
          // Detect `process` so that it can run in browsers.
          typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
        ) {
          const filter = IgnoreBase.prototype._filter;
          const make_posix = (str) => /^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, "/");
          IgnoreBase.prototype._filter = function filterWin32(path7, slices) {
            path7 = make_posix(path7);
            return filter.call(this, path7, slices);
          };
        }
        module2.exports = (options) => new IgnoreBase(options);
      }
    });
    var src_exports = {};
    __export(src_exports, {
      BACKEND_FRAMEWORKS: () => BACKEND_FRAMEWORKS,
      BUILDER_COMPILE_STEP: () => BUILDER_COMPILE_STEP,
      BUILDER_INSTALLER_STEP: () => BUILDER_INSTALLER_STEP,
      BunVersion: () => BunVersion,
      EdgeFunction: () => EdgeFunction,
      FileBlob: () => FileBlob,
      FileFsRef: () => file_fs_ref_default,
      FileRef: () => FileRef,
      Lambda: () => Lambda,
      NODE_VERSIONS: () => NODE_VERSIONS,
      NodeVersion: () => NodeVersion,
      NodejsLambda: () => NodejsLambda,
      NowBuildError: () => NowBuildError,
      Prerender: () => Prerender,
      Span: () => Span,
      Version: () => Version,
      buildsSchema: () => buildsSchema,
      cloneEnv: () => cloneEnv,
      createLambda: () => createLambda,
      debug: () => debug,
      defaultCachePathGlob: () => defaultCachePathGlob,
      detectPackageManager: () => detectPackageManager,
      download: () => download,
      downloadFile: () => downloadFile,
      execCommand: () => execCommand,
      functionsSchema: () => functionsSchema,
      generateNodeBuilderFunctions: () => generateNodeBuilderFunctions,
      getDiscontinuedNodeVersions: () => getDiscontinuedNodeVersions,
      getEnvForPackageManager: () => getEnvForPackageManager,
      getIgnoreFilter: () => get_ignore_filter_default,
      getInstalledPackageVersion: () => getInstalledPackageVersion,
      getLambdaOptionsFromFunction: () => getLambdaOptionsFromFunction,
      getLatestNodeVersion: () => getLatestNodeVersion,
      getNodeBinPath: () => getNodeBinPath,
      getNodeBinPaths: () => getNodeBinPaths,
      getNodeVersion: () => getNodeVersion,
      getOsRelease: () => getOsRelease,
      getPathForPackageManager: () => getPathForPackageManager,
      getPlatformEnv: () => getPlatformEnv,
      getPrefixedEnvVars: () => getPrefixedEnvVars,
      getPrettyError: () => getPrettyError,
      getProvidedRuntime: () => getProvidedRuntime,
      getScriptName: () => getScriptName,
      getSpawnOptions: () => getSpawnOptions,
      getSupportedBunVersion: () => getSupportedBunVersion,
      getSupportedNodeVersion: () => getSupportedNodeVersion,
      getWriteableDirectory: () => getWritableDirectory,
      glob: () => glob,
      hardLinkDir: () => hardLinkDir,
      installDependencies: () => installDependencies,
      isBackendFramework: () => isBackendFramework,
      isBunVersion: () => isBunVersion,
      isDirectory: () => isDirectory,
      isExperimentalBackendsEnabled: () => isExperimentalBackendsEnabled,
      isSymbolicLink: () => isSymbolicLink,
      normalizePath: () => normalizePath,
      readConfigFile: () => readConfigFile,
      rename: () => rename,
      runBundleInstall: () => runBundleInstall,
      runCustomInstallCommand: () => runCustomInstallCommand,
      runNpmInstall: () => runNpmInstall,
      runPackageJsonScript: () => runPackageJsonScript,
      runPipInstall: () => runPipInstall,
      runShellScript: () => runShellScript,
      scanParentDirs: () => scanParentDirs,
      shouldServe: () => shouldServe,
      shouldUseExperimentalBackends: () => shouldUseExperimentalBackends,
      spawnAsync: () => spawnAsync,
      spawnCommand: () => spawnCommand,
      streamToBuffer: () => streamToBuffer,
      streamToBufferChunks: () => streamToBufferChunks,
      traverseUpDirectories: () => traverseUpDirectories,
      validateNpmrc: () => validateNpmrc,
      walkParentDirs: () => walkParentDirs
    });
    module.exports = __toCommonJS(src_exports);
    var import_assert = __toESM(require("assert"));
    var import_into_stream = __toESM(require_into_stream());
    var FileBlob = class _FileBlob {
      constructor({ mode = 33188, contentType, data }) {
        (0, import_assert.default)(typeof mode === "number");
        (0, import_assert.default)(typeof data === "string" || Buffer.isBuffer(data));
        this.type = "FileBlob";
        this.mode = mode;
        this.contentType = contentType;
        this.data = data;
      }
      static async fromStream({
        mode = 33188,
        contentType,
        stream
      }) {
        (0, import_assert.default)(typeof mode === "number");
        (0, import_assert.default)(typeof stream.pipe === "function");
        const chunks = [];
        await new Promise((resolve, reject) => {
          stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
          stream.on("error", (error) => reject(error));
          stream.on("end", () => resolve());
        });
        const data = Buffer.concat(chunks);
        return new _FileBlob({ mode, contentType, data });
      }
      async toStreamAsync() {
        return this.toStream();
      }
      toStream() {
        return (0, import_into_stream.default)(this.data);
      }
    };
    var import_assert2 = __toESM(require("assert"));
    var import_fs_extra = __toESM(require_lib());
    var import_multistream = __toESM(require_multistream());
    var import_path = __toESM(require("path"));
    var import_async_sema = __toESM(require_async_sema());
    var semaToPreventEMFILE = new import_async_sema.default(20);
    var FileFsRef = class _FileFsRef {
      constructor({
        mode = 33188,
        contentType,
        fsPath,
        size
      }) {
        (0, import_assert2.default)(typeof mode === "number");
        (0, import_assert2.default)(typeof fsPath === "string");
        this.type = "FileFsRef";
        this.mode = mode;
        this.contentType = contentType;
        this.fsPath = fsPath;
        this.size = size;
      }
      static async fromFsPath({
        mode,
        contentType,
        fsPath,
        size
      }) {
        let m = mode;
        let s = size;
        if (!m || typeof s === "undefined") {
          const stat = await import_fs_extra.default.lstat(fsPath);
          m = stat.mode;
          s = stat.size;
        }
        return new _FileFsRef({ mode: m, contentType, fsPath, size: s });
      }
      static async fromStream({
        mode = 33188,
        contentType,
        stream,
        fsPath
      }) {
        (0, import_assert2.default)(typeof mode === "number");
        (0, import_assert2.default)(typeof stream.pipe === "function");
        (0, import_assert2.default)(typeof fsPath === "string");
        await import_fs_extra.default.mkdirp(import_path.default.dirname(fsPath));
        await new Promise((resolve, reject) => {
          const dest = import_fs_extra.default.createWriteStream(fsPath, {
            mode: mode & 511
          });
          stream.pipe(dest);
          stream.on("error", reject);
          dest.on("finish", resolve);
          dest.on("error", reject);
        });
        return _FileFsRef.fromFsPath({ mode, contentType, fsPath });
      }
      async toStreamAsync() {
        await semaToPreventEMFILE.acquire();
        const release = () => semaToPreventEMFILE.release();
        const stream = import_fs_extra.default.createReadStream(this.fsPath);
        stream.on("close", release);
        stream.on("error", release);
        return stream;
      }
      toStream() {
        let flag = false;
        return (0, import_multistream.default)((cb) => {
          if (flag)
            return cb(null, null);
          flag = true;
          this.toStreamAsync().then((stream) => {
            cb(null, stream);
          }).catch((error) => {
            cb(error, null);
          });
        });
      }
    };
    var file_fs_ref_default = FileFsRef;
    var import_assert3 = __toESM(require("assert"));
    var import_node_fetch = __toESM(require_lib3());
    var import_multistream2 = __toESM(require_multistream());
    var import_async_retry = __toESM(require_lib4());
    var import_async_sema2 = __toESM(require_async_sema());
    var semaToDownloadFromS3 = new import_async_sema2.default(5);
    var BailableError = class extends Error {
      constructor(...args) {
        super(...args);
        this.bail = false;
      }
    };
    var FileRef = class {
      constructor({
        mode = 33188,
        digest,
        contentType,
        mutable = false
      }) {
        (0, import_assert3.default)(typeof mode === "number");
        (0, import_assert3.default)(typeof digest === "string");
        this.type = "FileRef";
        this.mode = mode;
        this.digest = digest;
        this.contentType = contentType;
        this.mutable = mutable;
      }
      /**
       * Retrieves the URL of the CloudFront distribution for the S3
       * bucket represented by {@link getNowFilesS3Url}.
       *
       * @returns The URL of the CloudFront distribution
       */
      getNowFilesCloudfrontUrl() {
        return getEnvAsUrlOrThrow("NOW_FILES_CLOUDFRONT_URL") || "https://dmmcy0pwk6bqi.cloudfront.net";
      }
      /**
       * Retrieves the URL of the S3 bucket for storing ephemeral files.
       *
       * @returns The URL of the S3 bucket
       */
      getNowEphemeralFilesS3Url() {
        return getEnvAsUrlOrThrow("NOW_EPHEMERAL_FILES_S3_URL") || "https://now-ephemeral-files.s3.amazonaws.com";
      }
      /**
       * Retrieves the URL of the S3 bucket for storing files.
       *
       * @returns The URL of the S3 bucket
       */
      getNowFilesS3Url() {
        return getEnvAsUrlOrThrow("NOW_FILES_S3_URL") || "https://now-files.s3.amazonaws.com";
      }
      async toStreamAsync() {
        let url = "";
        const [digestType, digestHash] = this.digest.split(":");
        if (digestType === "sha") {
          url = this.mutable ? `${this.getNowFilesS3Url()}/${digestHash}` : `${this.getNowFilesCloudfrontUrl()}/${digestHash}`;
        } else if (digestType === "sha+ephemeral") {
          url = `${this.getNowEphemeralFilesS3Url()}/${digestHash}`;
        } else {
          throw new Error("Expected digest to be sha");
        }
        await semaToDownloadFromS3.acquire();
        try {
          return await (0, import_async_retry.default)(
            async () => {
              const resp = await (0, import_node_fetch.default)(url);
              if (!resp.ok) {
                const error = new BailableError(
                  `download: ${resp.status} ${resp.statusText} for ${url}`
                );
                if (resp.status === 403)
                  error.bail = true;
                throw error;
              }
              return resp.body;
            },
            { factor: 1, retries: 3 }
          );
        } finally {
          semaToDownloadFromS3.release();
        }
      }
      toStream() {
        let flag = false;
        return (0, import_multistream2.default)((cb) => {
          if (flag)
            return cb(null, null);
          flag = true;
          this.toStreamAsync().then((stream) => {
            cb(null, stream);
          }).catch((error) => {
            cb(error, null);
          });
        });
      }
    };
    function getEnvAsUrlOrThrow(key) {
      const value = process.env[key];
      if (value === void 0)
        return void 0;
      try {
        new URL(value);
        return value;
      } catch (e) {
        if (e instanceof TypeError && "code" in e && e.code === "ERR_INVALID_URL") {
          throw new Error(
            `A non-URL value was supplied to the ${key} environment variable`
          );
        } else {
          throw e;
        }
      }
    }
    var import_assert4 = __toESM(require("assert"));
    var import_async_sema3 = __toESM(require_async_sema());
    var import_yazl = __toESM(require_yazl());
    var import_minimatch = __toESM(require_minimatch());
    var import_fs_extra3 = __toESM(require_lib());
    var import_path2 = __toESM(require("path"));
    var NowBuildError = class extends Error {
      constructor({ message, code, link, action }) {
        super(message);
        this.hideStackTrace = true;
        this.code = code;
        this.link = link;
        this.action = action;
      }
    };
    function getPrettyError(obj) {
      const docsUrl = "https://vercel.com/docs/concepts/projects/project-configuration";
      try {
        const { dataPath, params, message: ajvMessage } = obj;
        const prop = getTopLevelPropertyName(dataPath);
        let message = dataPath && dataPath.startsWith(".") ? `\`${dataPath.slice(1)}\` ` : "";
        if (params && typeof params.additionalProperty === "string") {
          const suggestion = getSuggestion(prop, params.additionalProperty);
          message += `should NOT have additional property \`${params.additionalProperty}\`. ${suggestion}`;
        } else if (params && typeof params.missingProperty === "string") {
          message += `missing required property \`${params.missingProperty}\`.`;
        } else {
          message += `${ajvMessage}.`;
        }
        return new NowBuildError({
          code: "INVALID_VERCEL_CONFIG",
          message,
          link: prop ? `${docsUrl}#${prop.toLowerCase()}` : docsUrl,
          action: "View Documentation"
        });
      } catch (e) {
        return new NowBuildError({
          code: "INVALID_VERCEL_CONFIG",
          message: `Failed to validate configuration.`,
          link: docsUrl,
          action: "View Documentation"
        });
      }
    }
    function getTopLevelPropertyName(dataPath) {
      if (dataPath && dataPath.startsWith(".")) {
        const lastIndex = dataPath.indexOf("[");
        return lastIndex > -1 ? dataPath.slice(1, lastIndex) : dataPath.slice(1);
      }
      return "";
    }
    var mapTypoToSuggestion = {
      "": {
        builder: "builds",
        "build.env": '{ "build": { "env": {"name": "value"} } }',
        "builds.env": '{ "build": { "env": {"name": "value"} } }'
      },
      rewrites: { src: "source", dest: "destination" },
      redirects: { src: "source", dest: "destination", status: "statusCode" },
      headers: { src: "source", header: "headers" },
      routes: {
        source: "src",
        destination: "dest",
        header: "headers",
        method: "methods"
      }
    };
    function getSuggestion(topLevelProp, additionalProperty) {
      const choices = mapTypoToSuggestion[topLevelProp];
      const choice = choices ? choices[additionalProperty] : void 0;
      return choice ? `Did you mean \`${choice}\`?` : "Please remove it.";
    }
    var getPlatformEnv = (name) => {
      const vName = `VERCEL_${name}`;
      const nName = `NOW_${name}`;
      const v = process.env[vName];
      const n = process.env[nName];
      if (typeof v === "string") {
        if (typeof n === "string") {
          throw new NowBuildError({
            code: "CONFLICTING_ENV_VAR_NAMES",
            message: `Both "${vName}" and "${nName}" env vars are defined. Please only define the "${vName}" env var.`,
            link: "https://vercel.link/combining-old-and-new-config"
          });
        }
        return v;
      }
      return n;
    };
    function debug(message, ...additional) {
      if (getPlatformEnv("BUILDER_DEBUG")) {
        console.log(message, ...additional);
      } else if (process.env.VERCEL_DEBUG_PREFIX) {
        console.log(`${process.env.VERCEL_DEBUG_PREFIX}${message}`, ...additional);
      }
    }
    var import_fs_extra2 = __toESM(require_lib());
    var import_end_of_stream = __toESM(require_end_of_stream());
    function streamToBuffer(stream) {
      return new Promise((resolve, reject) => {
        const buffers = [];
        stream.on("data", buffers.push.bind(buffers));
        (0, import_end_of_stream.default)(stream, (err) => {
          if (err) {
            reject(err);
            return;
          }
          switch (buffers.length) {
            case 0:
              resolve(Buffer.allocUnsafe(0));
              break;
            case 1:
              resolve(buffers[0]);
              break;
            default:
              resolve(Buffer.concat(buffers));
          }
        });
      });
    }
    var MB = 1024 * 1024;
    async function streamToBufferChunks(stream, chunkSize = 100 * MB) {
      const chunks = [];
      let currentChunk = [];
      let currentSize = 0;
      for await (const chunk of stream) {
        const buffer = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
        let offset = 0;
        while (offset < buffer.length) {
          const remainingSpace = chunkSize - currentSize;
          const sliceSize = Math.min(remainingSpace, buffer.length - offset);
          currentChunk.push(buffer.slice(offset, offset + sliceSize));
          currentSize += sliceSize;
          offset += sliceSize;
          if (currentSize >= chunkSize) {
            chunks.push(Buffer.concat(currentChunk));
            currentChunk = [];
            currentSize = 0;
          }
        }
      }
      if (currentChunk.length > 0) {
        chunks.push(Buffer.concat(currentChunk));
      }
      return chunks;
    }
    var S_IFDIR = 16384;
    var S_IFLNK = 40960;
    var S_IFMT = 61440;
    function isDirectory(mode) {
      return (mode & S_IFMT) === S_IFDIR;
    }
    function isSymbolicLink(mode) {
      return (mode & S_IFMT) === S_IFLNK;
    }
    async function prepareSymlinkTarget(file, fsPath) {
      const mkdirPromise = (0, import_fs_extra2.mkdirp)(import_path2.default.dirname(fsPath));
      if (file.type === "FileFsRef") {
        const [target] = await Promise.all([(0, import_fs_extra2.readlink)(file.fsPath), mkdirPromise]);
        return target;
      }
      if (file.type === "FileRef" || file.type === "FileBlob") {
        const targetPathBufferPromise = streamToBuffer(await file.toStreamAsync());
        const [targetPathBuffer] = await Promise.all([
          targetPathBufferPromise,
          mkdirPromise
        ]);
        return targetPathBuffer.toString("utf8");
      }
      throw new Error(
        `file.type "${file.type}" not supported for symlink`
      );
    }
    async function downloadFile(file, fsPath) {
      const { mode } = file;
      if (isDirectory(mode)) {
        await (0, import_fs_extra2.mkdirp)(fsPath);
        await (0, import_fs_extra2.chmod)(fsPath, mode);
        return file_fs_ref_default.fromFsPath({ mode, fsPath });
      }
      if (isSymbolicLink(mode)) {
        const target = await prepareSymlinkTarget(file, fsPath);
        await (0, import_fs_extra2.symlink)(target, fsPath);
        return file_fs_ref_default.fromFsPath({ mode, fsPath });
      }
      const stream = file.toStream();
      return file_fs_ref_default.fromStream({ mode, stream, fsPath });
    }
    async function removeFile(basePath, fileMatched) {
      const file = import_path2.default.join(basePath, fileMatched);
      await (0, import_fs_extra2.remove)(file);
    }
    async function download(files, basePath, meta) {
      const {
        isDev = false,
        skipDownload = false,
        filesChanged = null,
        filesRemoved = null
      } = meta || {};
      if (isDev || skipDownload) {
        return files;
      }
      debug("Downloading deployment source files...");
      const start = Date.now();
      const files2 = {};
      const filenames = Object.keys(files);
      await Promise.all(
        filenames.map(async (name) => {
          if (Array.isArray(filesRemoved) && filesRemoved.includes(name)) {
            await removeFile(basePath, name);
            return;
          }
          if (Array.isArray(filesChanged) && !filesChanged.includes(name)) {
            return;
          }
          const parts = name.split("/");
          for (let i = 1; i < parts.length; i++) {
            const dir = parts.slice(0, i).join("/");
            const parent = files[dir];
            if (parent && isSymbolicLink(parent.mode)) {
              console.warn(
                `Warning: file "${name}" is within a symlinked directory "${dir}" and will be ignored`
              );
              return;
            }
          }
          const file = files[name];
          const fsPath = import_path2.default.join(basePath, name);
          files2[name] = await downloadFile(file, fsPath);
        })
      );
      const duration = Date.now() - start;
      debug(`Downloaded ${filenames.length} source files: ${duration}ms`);
      return files2;
    }
    function getDefaultLambdaArchitecture(architecture) {
      if (architecture) {
        return architecture;
      }
      switch (process.arch) {
        case "arm":
        case "arm64": {
          return "arm64";
        }
        default: {
          return "x86_64";
        }
      }
    }
    var Lambda = class {
      constructor(opts) {
        const {
          handler,
          runtime,
          maxDuration,
          architecture,
          memory,
          environment = {},
          allowQuery,
          regions,
          supportsMultiPayloads,
          supportsWrapper,
          supportsResponseStreaming,
          experimentalResponseStreaming,
          operationType,
          framework,
          experimentalTriggers,
          supportsCancellation
        } = opts;
        if ("files" in opts) {
          (0, import_assert4.default)(typeof opts.files === "object", '"files" must be an object');
        }
        if ("zipBuffer" in opts) {
          (0, import_assert4.default)(Buffer.isBuffer(opts.zipBuffer), '"zipBuffer" must be a Buffer');
        }
        (0, import_assert4.default)(typeof handler === "string", '"handler" is not a string');
        (0, import_assert4.default)(typeof runtime === "string", '"runtime" is not a string');
        (0, import_assert4.default)(typeof environment === "object", '"environment" is not an object');
        if (architecture !== void 0) {
          (0, import_assert4.default)(
            architecture === "x86_64" || architecture === "arm64",
            '"architecture" must be either "x86_64" or "arm64"'
          );
        }
        if ("experimentalAllowBundling" in opts && opts.experimentalAllowBundling !== void 0) {
          (0, import_assert4.default)(
            typeof opts.experimentalAllowBundling === "boolean",
            '"experimentalAllowBundling" is not a boolean'
          );
        }
        if (memory !== void 0) {
          (0, import_assert4.default)(typeof memory === "number", '"memory" is not a number');
        }
        if (maxDuration !== void 0) {
          (0, import_assert4.default)(typeof maxDuration === "number", '"maxDuration" is not a number');
        }
        if (allowQuery !== void 0) {
          (0, import_assert4.default)(Array.isArray(allowQuery), '"allowQuery" is not an Array');
          (0, import_assert4.default)(
            allowQuery.every((q) => typeof q === "string"),
            '"allowQuery" is not a string Array'
          );
        }
        if (supportsMultiPayloads !== void 0) {
          (0, import_assert4.default)(
            typeof supportsMultiPayloads === "boolean",
            '"supportsMultiPayloads" is not a boolean'
          );
        }
        if (supportsWrapper !== void 0) {
          (0, import_assert4.default)(
            typeof supportsWrapper === "boolean",
            '"supportsWrapper" is not a boolean'
          );
        }
        if (regions !== void 0) {
          (0, import_assert4.default)(Array.isArray(regions), '"regions" is not an Array');
          (0, import_assert4.default)(
            regions.every((r) => typeof r === "string"),
            '"regions" is not a string Array'
          );
        }
        if (framework !== void 0) {
          (0, import_assert4.default)(typeof framework === "object", '"framework" is not an object');
          (0, import_assert4.default)(
            typeof framework.slug === "string",
            '"framework.slug" is not a string'
          );
          if (framework.version !== void 0) {
            (0, import_assert4.default)(
              typeof framework.version === "string",
              '"framework.version" is not a string'
            );
          }
        }
        if (experimentalTriggers !== void 0) {
          (0, import_assert4.default)(
            Array.isArray(experimentalTriggers),
            '"experimentalTriggers" is not an Array'
          );
          for (let i = 0; i < experimentalTriggers.length; i++) {
            const trigger = experimentalTriggers[i];
            const prefix = `"experimentalTriggers[${i}]"`;
            (0, import_assert4.default)(
              typeof trigger === "object" && trigger !== null,
              `${prefix} is not an object`
            );
            (0, import_assert4.default)(
              trigger.type === "queue/v1beta",
              `${prefix}.type must be "queue/v1beta"`
            );
            (0, import_assert4.default)(
              typeof trigger.topic === "string",
              `${prefix}.topic is required and must be a string`
            );
            (0, import_assert4.default)(trigger.topic.length > 0, `${prefix}.topic cannot be empty`);
            (0, import_assert4.default)(
              typeof trigger.consumer === "string",
              `${prefix}.consumer is required and must be a string`
            );
            (0, import_assert4.default)(
              trigger.consumer.length > 0,
              `${prefix}.consumer cannot be empty`
            );
            if (trigger.maxDeliveries !== void 0) {
              (0, import_assert4.default)(
                typeof trigger.maxDeliveries === "number",
                `${prefix}.maxDeliveries must be a number`
              );
              (0, import_assert4.default)(
                Number.isInteger(trigger.maxDeliveries) && trigger.maxDeliveries >= 1,
                `${prefix}.maxDeliveries must be at least 1`
              );
            }
            if (trigger.retryAfterSeconds !== void 0) {
              (0, import_assert4.default)(
                typeof trigger.retryAfterSeconds === "number",
                `${prefix}.retryAfterSeconds must be a number`
              );
              (0, import_assert4.default)(
                trigger.retryAfterSeconds > 0,
                `${prefix}.retryAfterSeconds must be a positive number`
              );
            }
            if (trigger.initialDelaySeconds !== void 0) {
              (0, import_assert4.default)(
                typeof trigger.initialDelaySeconds === "number",
                `${prefix}.initialDelaySeconds must be a number`
              );
              (0, import_assert4.default)(
                trigger.initialDelaySeconds >= 0,
                `${prefix}.initialDelaySeconds must be a non-negative number`
              );
            }
          }
        }
        if (supportsCancellation !== void 0) {
          (0, import_assert4.default)(
            typeof supportsCancellation === "boolean",
            '"supportsCancellation" is not a boolean'
          );
        }
        this.type = "Lambda";
        this.operationType = operationType;
        this.files = "files" in opts ? opts.files : void 0;
        this.handler = handler;
        this.runtime = runtime;
        this.architecture = getDefaultLambdaArchitecture(architecture);
        this.memory = memory;
        this.maxDuration = maxDuration;
        this.environment = environment;
        this.allowQuery = allowQuery;
        this.regions = regions;
        this.zipBuffer = "zipBuffer" in opts ? opts.zipBuffer : void 0;
        this.supportsMultiPayloads = supportsMultiPayloads;
        this.supportsWrapper = supportsWrapper;
        this.supportsResponseStreaming = supportsResponseStreaming ?? experimentalResponseStreaming;
        this.framework = framework;
        this.experimentalAllowBundling = "experimentalAllowBundling" in opts ? opts.experimentalAllowBundling : void 0;
        this.experimentalTriggers = experimentalTriggers;
        this.supportsCancellation = supportsCancellation;
      }
      async createZip() {
        let { zipBuffer } = this;
        if (!zipBuffer) {
          if (!this.files) {
            throw new Error("`files` is not defined");
          }
          await sema.acquire();
          try {
            zipBuffer = await createZip(this.files);
          } finally {
            sema.release();
          }
        }
        return zipBuffer;
      }
      /**
       * @deprecated Use the `supportsResponseStreaming` property instead.
       */
      get experimentalResponseStreaming() {
        return this.supportsResponseStreaming;
      }
      set experimentalResponseStreaming(v) {
        this.supportsResponseStreaming = v;
      }
    };
    var sema = new import_async_sema3.default(10);
    var mtime = /* @__PURE__ */ new Date(154e10);
    async function createLambda(opts) {
      const lambda = new Lambda(opts);
      lambda.zipBuffer = await lambda.createZip();
      return lambda;
    }
    async function createZip(files) {
      const names = Object.keys(files).sort();
      const symlinkTargets = /* @__PURE__ */ new Map();
      for (const name of names) {
        const file = files[name];
        if (file.mode && isSymbolicLink(file.mode) && file.type === "FileFsRef") {
          const symlinkTarget = await (0, import_fs_extra3.readlink)(file.fsPath);
          symlinkTargets.set(name, symlinkTarget);
        }
      }
      const zipFile = new import_yazl.ZipFile();
      const zipBuffer = await new Promise((resolve, reject) => {
        for (const name of names) {
          const file = files[name];
          const opts = { mode: file.mode, mtime };
          const symlinkTarget = symlinkTargets.get(name);
          if (typeof symlinkTarget === "string") {
            zipFile.addBuffer(Buffer.from(symlinkTarget, "utf8"), name, opts);
          } else if (file.mode && isDirectory(file.mode)) {
            zipFile.addEmptyDirectory(name, opts);
          } else {
            const stream = file.toStream();
            stream.on("error", reject);
            zipFile.addReadStream(stream, name, opts);
          }
        }
        zipFile.end();
        streamToBuffer(zipFile.outputStream).then(resolve).catch(reject);
      });
      return zipBuffer;
    }
    async function getLambdaOptionsFromFunction({
      sourceFile,
      config
    }) {
      if (config?.functions) {
        for (const [pattern, fn] of Object.entries(config.functions)) {
          if (sourceFile === pattern || (0, import_minimatch.default)(sourceFile, pattern)) {
            return {
              architecture: fn.architecture,
              memory: fn.memory,
              maxDuration: fn.maxDuration,
              experimentalTriggers: fn.experimentalTriggers,
              supportsCancellation: fn.supportsCancellation
            };
          }
        }
      }
      return {};
    }
    var NodejsLambda = class extends Lambda {
      constructor({
        shouldAddHelpers,
        shouldAddSourcemapSupport,
        awsLambdaHandler,
        useWebApi,
        ...opts
      }) {
        super(opts);
        this.launcherType = "Nodejs";
        this.shouldAddHelpers = shouldAddHelpers;
        this.shouldAddSourcemapSupport = shouldAddSourcemapSupport;
        this.awsLambdaHandler = awsLambdaHandler;
        this.useWebApi = useWebApi;
      }
    };
    var Prerender = class {
      constructor({
        expiration,
        staleExpiration,
        lambda,
        fallback,
        group,
        bypassToken,
        allowQuery,
        allowHeader,
        initialHeaders,
        initialStatus,
        passQuery,
        sourcePath,
        experimentalBypassFor,
        experimentalStreamingLambdaPath,
        chain
      }) {
        this.type = "Prerender";
        this.expiration = expiration;
        this.staleExpiration = staleExpiration;
        this.sourcePath = sourcePath;
        this.lambda = lambda;
        if (this.lambda) {
          this.lambda.operationType = this.lambda.operationType || "ISR";
        }
        if (typeof group !== "undefined" && (group <= 0 || !Number.isInteger(group))) {
          throw new Error(
            "The `group` argument for `Prerender` needs to be a natural number."
          );
        }
        this.group = group;
        if (passQuery === true) {
          this.passQuery = true;
        } else if (typeof passQuery !== "boolean" && typeof passQuery !== "undefined") {
          throw new Error(
            `The \`passQuery\` argument for \`Prerender\` must be a boolean.`
          );
        }
        if (bypassToken == null) {
          this.bypassToken = null;
        } else if (typeof bypassToken === "string") {
          if (bypassToken.length < 32) {
            throw new Error(
              "The `bypassToken` argument for `Prerender` must be 32 characters or more."
            );
          }
          this.bypassToken = bypassToken;
        } else {
          throw new Error(
            "The `bypassToken` argument for `Prerender` must be a `string`."
          );
        }
        if (experimentalBypassFor !== void 0) {
          if (!Array.isArray(experimentalBypassFor) || experimentalBypassFor.some(
            (field) => typeof field !== "object" || typeof field.type !== "string" || field.type === "host" && "key" in field || field.type !== "host" && typeof field.key !== "string" || field.value !== void 0 && typeof field.value !== "string" && (typeof field.value !== "object" || field.value === null || Array.isArray(field.value))
          )) {
            throw new Error(
              "The `experimentalBypassFor` argument for `Prerender` must be Array of objects with fields `type`, `key` and optionally `value`."
            );
          }
          this.experimentalBypassFor = experimentalBypassFor;
        }
        if (typeof fallback === "undefined") {
          throw new Error(
            "The `fallback` argument for `Prerender` needs to be a `FileBlob`, `FileFsRef`, `FileRef`, or null."
          );
        }
        this.fallback = fallback;
        if (initialHeaders !== void 0) {
          if (!initialHeaders || typeof initialHeaders !== "object" || Object.entries(initialHeaders).some(
            ([key, value]) => typeof key !== "string" || typeof value !== "string"
          )) {
            throw new Error(
              `The \`initialHeaders\` argument for \`Prerender\` must be an object with string key/values`
            );
          }
          this.initialHeaders = initialHeaders;
        }
        if (initialStatus !== void 0) {
          if (initialStatus <= 0 || !Number.isInteger(initialStatus)) {
            throw new Error(
              `The \`initialStatus\` argument for \`Prerender\` must be a natural number.`
            );
          }
          this.initialStatus = initialStatus;
        }
        if (allowQuery !== void 0) {
          if (!Array.isArray(allowQuery)) {
            throw new Error(
              "The `allowQuery` argument for `Prerender` must be Array."
            );
          }
          if (!allowQuery.every((q) => typeof q === "string")) {
            throw new Error(
              "The `allowQuery` argument for `Prerender` must be Array of strings."
            );
          }
          this.allowQuery = allowQuery;
        }
        if (allowHeader !== void 0) {
          if (!Array.isArray(allowHeader)) {
            throw new Error(
              "The `allowHeader` argument for `Prerender` must be Array."
            );
          }
          if (!allowHeader.every((q) => typeof q === "string")) {
            throw new Error(
              "The `allowHeader` argument for `Prerender` must be Array of strings."
            );
          }
          this.allowHeader = allowHeader;
        }
        if (experimentalStreamingLambdaPath !== void 0) {
          if (typeof experimentalStreamingLambdaPath !== "string") {
            throw new Error(
              "The `experimentalStreamingLambdaPath` argument for `Prerender` must be a string."
            );
          }
          this.experimentalStreamingLambdaPath = experimentalStreamingLambdaPath;
        }
        if (chain !== void 0) {
          if (typeof chain !== "object") {
            throw new Error(
              "The `chain` argument for `Prerender` must be an object."
            );
          }
          if (!chain.headers || typeof chain.headers !== "object" || Object.entries(chain.headers).some(
            ([key, value]) => typeof key !== "string" || typeof value !== "string"
          )) {
            throw new Error(
              `The \`chain.headers\` argument for \`Prerender\` must be an object with string key/values`
            );
          }
          if (!chain.outputPath || typeof chain.outputPath !== "string") {
            throw new Error(
              "The `chain.outputPath` argument for `Prerender` must be a string."
            );
          }
          this.chain = chain;
        }
      }
    };
    var import_path3 = require("path");
    var import_os = require("os");
    var import_fs_extra4 = __toESM(require_lib());
    async function getWritableDirectory() {
      const name = Math.floor(Math.random() * 2147483647).toString(16);
      const directory = (0, import_path3.join)((0, import_os.tmpdir)(), name);
      await (0, import_fs_extra4.mkdirp)(directory);
      return directory;
    }
    var import_path4 = __toESM(require("path"));
    var import_assert5 = __toESM(require("assert"));
    var import_glob = __toESM(require_glob());
    var import_util = require("util");
    var import_fs_extra5 = __toESM(require_lib());
    var isWin = process.platform === "win32";
    function normalizePath(p) {
      return isWin ? p.replace(/\\/g, "/") : p;
    }
    var vanillaGlob = (0, import_util.promisify)(import_glob.default);
    async function glob(pattern, opts, mountpoint) {
      const options = typeof opts === "string" ? { cwd: opts } : opts;
      if (!options.cwd) {
        throw new Error(
          "Second argument (basePath) must be specified for names of resulting files"
        );
      }
      if (!import_path4.default.isAbsolute(options.cwd)) {
        throw new Error(`basePath/cwd must be an absolute path (${options.cwd})`);
      }
      const results = {};
      const statCache = {};
      const symlinks = {};
      const files = await vanillaGlob(pattern, {
        ...options,
        symlinks,
        statCache,
        stat: true,
        dot: true
      });
      const dirs = /* @__PURE__ */ new Set();
      const dirsWithEntries = /* @__PURE__ */ new Set();
      for (const relativePath of files) {
        const absPath = import_path4.default.join(options.cwd, relativePath);
        const fsPath = normalizePath(absPath);
        let stat = statCache[fsPath];
        (0, import_assert5.default)(
          stat,
          `statCache does not contain value for ${relativePath} (resolved to ${fsPath})`
        );
        const isSymlink = symlinks[fsPath];
        if (options.follow && (isSymlink || (await (0, import_fs_extra5.lstat)(fsPath)).isSymbolicLink())) {
          const target = await (0, import_fs_extra5.readlink)(absPath);
          const absTarget = import_path4.default.resolve(import_path4.default.dirname(absPath), target);
          if (import_path4.default.relative(options.cwd, absTarget).startsWith(`..${import_path4.default.sep}`)) {
            continue;
          }
        }
        if (isSymlink || stat.isFile() || stat.isDirectory()) {
          if (isSymlink) {
            stat = await (0, import_fs_extra5.lstat)(absPath);
          }
          const dirname = import_path4.default.dirname(relativePath);
          dirsWithEntries.add(dirname);
          if (stat.isDirectory()) {
            dirs.add(relativePath);
            continue;
          }
          let finalPath = relativePath;
          if (mountpoint) {
            finalPath = import_path4.default.join(mountpoint, finalPath);
          }
          results[finalPath] = new file_fs_ref_default({ mode: stat.mode, fsPath });
        }
      }
      if (options.includeDirectories) {
        for (const relativePath of dirs) {
          if (dirsWithEntries.has(relativePath))
            continue;
          let finalPath = relativePath;
          if (mountpoint) {
            finalPath = import_path4.default.join(mountpoint, finalPath);
          }
          const fsPath = normalizePath(import_path4.default.join(options.cwd, relativePath));
          const stat = statCache[fsPath];
          results[finalPath] = new file_fs_ref_default({ mode: stat.mode, fsPath });
        }
      }
      return results;
    }
    function rename(files, delegate) {
      const result = {};
      for (const [name, file] of Object.entries(files)) {
        result[delegate(name)] = file;
      }
      return result;
    }
    var import_assert6 = __toESM(require("assert"));
    var import_fs_extra7 = __toESM(require_lib());
    var import_path5 = __toESM(require("path"));
    var import_async_sema4 = __toESM(require_async_sema());
    var import_cross_spawn = __toESM(require_cross_spawn());
    var import_semver2 = __toESM(require_semver2());
    var import_util2 = require("util");
    var import_fs = require("fs");
    var import_semver = __toESM(require_semver2());
    var Version = class {
      constructor(version) {
        this.major = version.major;
        this.minor = version.minor;
        this.range = version.range;
        this.runtime = version.runtime;
        this.discontinueDate = version.discontinueDate;
      }
      get state() {
        if (this.discontinueDate && this.discontinueDate.getTime() <= Date.now()) {
          return "discontinued";
        } else if (this.discontinueDate) {
          return "deprecated";
        }
        return "active";
      }
      get formattedDate() {
        return this.discontinueDate && this.discontinueDate.toISOString().split("T")[0];
      }
    };
    var NodeVersion = class extends Version {
    };
    var BunVersion = class extends Version {
    };
    var NODE_VERSIONS = [
      new NodeVersion({
        major: 22,
        range: "22.x",
        runtime: "nodejs22.x"
      }),
      new NodeVersion({
        major: 20,
        range: "20.x",
        runtime: "nodejs20.x"
      }),
      new NodeVersion({
        major: 18,
        range: "18.x",
        runtime: "nodejs18.x",
        discontinueDate: /* @__PURE__ */ new Date("2025-09-01")
      }),
      new NodeVersion({
        major: 16,
        range: "16.x",
        runtime: "nodejs16.x",
        discontinueDate: /* @__PURE__ */ new Date("2025-02-03")
      }),
      new NodeVersion({
        major: 14,
        range: "14.x",
        runtime: "nodejs14.x",
        discontinueDate: /* @__PURE__ */ new Date("2023-08-15")
      }),
      new NodeVersion({
        major: 12,
        range: "12.x",
        runtime: "nodejs12.x",
        discontinueDate: /* @__PURE__ */ new Date("2022-10-03")
      }),
      new NodeVersion({
        major: 10,
        range: "10.x",
        runtime: "nodejs10.x",
        discontinueDate: /* @__PURE__ */ new Date("2021-04-20")
      }),
      new NodeVersion({
        major: 8,
        range: "8.10.x",
        runtime: "nodejs8.10",
        discontinueDate: /* @__PURE__ */ new Date("2020-01-06")
      })
    ];
    var BUN_VERSIONS = [
      new BunVersion({
        major: 1,
        range: "1.x",
        runtime: "bun1.x"
      })
    ];
    function getOptions() {
      if (process.env.VERCEL_ALLOW_NODEJS_24 === "1") {
        return [
          new NodeVersion({
            major: 24,
            range: "24.x",
            runtime: "nodejs24.x"
          }),
          ...NODE_VERSIONS
        ];
      }
      return NODE_VERSIONS;
    }
    function isNodeVersionAvailable(version) {
      try {
        return (0, import_fs.statSync)(`/node${version.major}`).isDirectory();
      } catch {
      }
      return false;
    }
    function getAvailableNodeVersions() {
      return getOptions().filter(isNodeVersionAvailable).map((n) => n.major);
    }
    function getHint(isAuto = false, availableVersions) {
      const { major, range } = getLatestNodeVersion(availableVersions);
      return isAuto ? `Please set Node.js Version to ${range} in your Project Settings to use Node.js ${major}.` : `Please set "engines": { "node": "${range}" } in your \`package.json\` file to use Node.js ${major}.`;
    }
    function getLatestNodeVersion(availableVersions) {
      const all = getOptions();
      if (availableVersions) {
        for (const version of all) {
          for (const major of availableVersions) {
            if (version.major === major) {
              return version;
            }
          }
        }
      }
      return all[0];
    }
    function getDiscontinuedNodeVersions() {
      return getOptions().filter((version) => {
        return version.state === "discontinued";
      });
    }
    async function getSupportedNodeVersion(engineRange, isAuto = false, availableVersions) {
      let selection;
      if (engineRange) {
        const found = (0, import_semver.validRange)(engineRange) && getOptions().some((o) => {
          selection = o;
          return (0, import_semver.intersects)(o.range, engineRange) && (availableVersions?.length ? availableVersions.includes(o.major) : true);
        });
        if (!found) {
          throw new NowBuildError({
            code: "BUILD_UTILS_NODE_VERSION_INVALID",
            link: "http://vercel.link/node-version",
            message: `Found invalid Node.js Version: "${engineRange}". ${getHint(
              isAuto,
              availableVersions
            )}`
          });
        }
      }
      if (!selection) {
        selection = getLatestNodeVersion(availableVersions);
      }
      if (selection.state === "discontinued") {
        const intro = `Node.js Version "${selection.range}" is discontinued and must be upgraded.`;
        throw new NowBuildError({
          code: "BUILD_UTILS_NODE_VERSION_DISCONTINUED",
          link: "http://vercel.link/node-version",
          message: `${intro} ${getHint(isAuto)}`
        });
      }
      debug(`Selected Node.js ${selection.range}`);
      if (selection.state === "deprecated") {
        const d = selection.formattedDate;
        if (d) {
          console.warn(
            `Error: Node.js version ${selection.range} is deprecated. Deployments created on or after ${d} will fail to build. ${getHint(
              isAuto
            )}`
          );
        } else {
          console.warn(
            `Error: Node.js version ${selection.range} is deprecated. ${getHint(
              isAuto
            )}`
          );
        }
      }
      return selection;
    }
    function getSupportedBunVersion(engineRange) {
      if ((0, import_semver.validRange)(engineRange)) {
        const selected = BUN_VERSIONS.find((version) => {
          return (0, import_semver.intersects)(version.range, engineRange);
        });
        if (selected) {
          return new BunVersion({
            major: selected.major,
            range: selected.range,
            runtime: selected.runtime
          });
        }
      }
      throw new NowBuildError({
        message: `Found invalid Bun Version: "${engineRange}".`,
        code: "BUILD_UTILS_BUN_VERSION_INVALID"
      });
    }
    function isBunVersion(version) {
      return version.runtime.startsWith("bun");
    }
    var import_js_yaml = __toESM(require_js_yaml2());
    var import_toml = __toESM(require_toml());
    var import_fs_extra6 = __toESM(require_lib());
    var import_error_utils = __toESM(require_dist());
    async function readFileOrNull(file) {
      try {
        const data = await (0, import_fs_extra6.readFile)(file);
        return data;
      } catch (error) {
        if (!(0, import_error_utils.isErrnoException)(error)) {
          throw error;
        }
        if (error.code !== "ENOENT") {
          throw error;
        }
      }
      return null;
    }
    async function readConfigFile(files) {
      files = Array.isArray(files) ? files : [files];
      for (const name of files) {
        const data = await readFileOrNull(name);
        if (data) {
          const str = data.toString("utf8");
          try {
            if (name.endsWith(".json")) {
              return JSON.parse(str);
            } else if (name.endsWith(".toml")) {
              return import_toml.default.parse(str);
            } else if (name.endsWith(".yaml") || name.endsWith(".yml")) {
              return import_js_yaml.default.safeLoad(str, { filename: name });
            }
          } catch (error) {
            console.log(`Error while parsing config file: "${name}"`);
          }
        }
      }
      return null;
    }
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function cloneEnv(...envs) {
      return envs.reduce((obj, env) => {
        if (env === void 0 || env === null) {
          return obj;
        }
        obj = Object.assign(obj, env);
        if (hasOwnProperty2.call(env, "Path")) {
          if (obj.Path !== void 0) {
            obj.PATH = obj.Path;
          }
          delete obj.Path;
        }
        return obj;
      }, {});
    }
    var import_json5 = __toESM(require_lib5());
    var import_js_yaml2 = __toESM(require_js_yaml2());
    var NO_OVERRIDE = {
      detectedLockfile: void 0,
      detectedPackageManager: void 0,
      path: void 0
    };
    function spawnAsync(command, args, opts = {}) {
      return new Promise((resolve, reject) => {
        const stderrLogs = [];
        opts = { stdio: "inherit", ...opts };
        const child = (0, import_cross_spawn.default)(command, args, opts);
        if (opts.stdio === "pipe" && child.stderr) {
          child.stderr.on("data", (data) => stderrLogs.push(data));
        }
        child.on("error", reject);
        child.on("close", (code, signal) => {
          if (code === 0 || opts.ignoreNon0Exit) {
            return resolve();
          }
          const cmd = opts.prettyCommand ? `Command "${opts.prettyCommand}"` : "Command";
          reject(
            new NowBuildError({
              code: `BUILD_UTILS_SPAWN_${code || signal}`,
              message: opts.stdio === "inherit" ? `${cmd} exited with ${code || signal}` : stderrLogs.map((line) => line.toString()).join("")
            })
          );
        });
      });
    }
    function spawnCommand(command, options = {}) {
      const opts = { ...options, prettyCommand: command };
      if (process.platform === "win32") {
        return (0, import_cross_spawn.default)("cmd.exe", ["/C", command], opts);
      }
      return (0, import_cross_spawn.default)("sh", ["-c", command], opts);
    }
    async function execCommand(command, options = {}) {
      const opts = { ...options, prettyCommand: command };
      if (process.platform === "win32") {
        await spawnAsync("cmd.exe", ["/C", command], opts);
      } else {
        await spawnAsync("sh", ["-c", command], opts);
      }
      return true;
    }
    function* traverseUpDirectories({
      start,
      base
    }) {
      let current = import_path5.default.normalize(start);
      const normalizedRoot = base ? import_path5.default.normalize(base) : void 0;
      while (current) {
        yield current;
        if (current === normalizedRoot)
          break;
        const next = import_path5.default.join(current, "..");
        current = next === current ? void 0 : next;
      }
    }
    async function readProjectRootInfo({
      start,
      base
    }) {
      let curRootPackageJsonPath;
      for (const dir of traverseUpDirectories({ start, base })) {
        const packageJsonPath = import_path5.default.join(dir, "package.json");
        if (await import_fs_extra7.default.pathExists(packageJsonPath)) {
          curRootPackageJsonPath = packageJsonPath;
        }
      }
      return curRootPackageJsonPath ? {
        packageJson: await import_fs_extra7.default.readJson(curRootPackageJsonPath),
        rootDir: import_path5.default.dirname(curRootPackageJsonPath)
      } : void 0;
    }
    async function getNodeBinPath({
      cwd
    }) {
      const { lockfilePath } = await scanParentDirs(cwd);
      const dir = import_path5.default.dirname(lockfilePath || cwd);
      return import_path5.default.join(dir, "node_modules", ".bin");
    }
    function getNodeBinPaths({
      start,
      base
    }) {
      return Array.from(traverseUpDirectories({ start, base })).map(
        (dir) => import_path5.default.join(dir, "node_modules/.bin")
      );
    }
    async function chmodPlusX(fsPath) {
      const s = await import_fs_extra7.default.stat(fsPath);
      const newMode = s.mode | 64 | 8 | 1;
      if (s.mode === newMode)
        return;
      const base8 = newMode.toString(8).slice(-3);
      await import_fs_extra7.default.chmod(fsPath, base8);
    }
    async function runShellScript(fsPath, args = [], spawnOpts) {
      (0, import_assert6.default)(import_path5.default.isAbsolute(fsPath));
      const destPath = import_path5.default.dirname(fsPath);
      await chmodPlusX(fsPath);
      const command = `./${import_path5.default.basename(fsPath)}`;
      await spawnAsync(command, args, {
        ...spawnOpts,
        cwd: destPath,
        prettyCommand: command
      });
      return true;
    }
    function getSpawnOptions(meta, nodeVersion) {
      const opts = {
        env: cloneEnv(process.env)
      };
      if (isBunVersion(nodeVersion)) {
        return opts;
      }
      if (!meta.isDev) {
        let found = false;
        const oldPath = opts.env.PATH || process.env.PATH || "";
        const pathSegments = oldPath.split(import_path5.default.delimiter).map((segment) => {
          if (/^\/node[0-9]+\/bin/.test(segment)) {
            found = true;
            return `/node${nodeVersion.major}/bin`;
          }
          return segment;
        });
        if (!found) {
          pathSegments.unshift(`/node${nodeVersion.major}/bin`);
        }
        opts.env.PATH = pathSegments.filter(Boolean).join(import_path5.default.delimiter);
      }
      return opts;
    }
    async function getNodeVersion(destPath, fallbackVersion = process.env.VERCEL_PROJECT_SETTINGS_NODE_VERSION, config = {}, meta = {}, availableVersions = getAvailableNodeVersions()) {
      if (config.bunVersion) {
        return getSupportedBunVersion(config.bunVersion);
      }
      const latestVersion = getLatestNodeVersion(availableVersions);
      if (meta.isDev) {
        latestVersion.runtime = "nodejs";
        return latestVersion;
      }
      const { packageJson } = await scanParentDirs(destPath, true);
      const configuredVersion = config.nodeVersion || fallbackVersion;
      const packageJsonVersion = packageJson?.engines?.node;
      const supportedNodeVersion = await getSupportedNodeVersion(
        packageJsonVersion || configuredVersion,
        !packageJsonVersion,
        availableVersions
      );
      if (packageJson?.engines?.node) {
        const { node } = packageJson.engines;
        if (configuredVersion && !(0, import_semver2.intersects)(configuredVersion, supportedNodeVersion.range)) {
          console.warn(
            `Warning: Due to "engines": { "node": "${node}" } in your \`package.json\` file, the Node.js Version defined in your Project Settings ("${configuredVersion}") will not apply, Node.js Version "${supportedNodeVersion.range}" will be used instead. Learn More: http://vercel.link/node-version`
          );
        }
        if ((0, import_semver2.coerce)(node)?.raw === node) {
          console.warn(
            `Warning: Detected "engines": { "node": "${node}" } in your \`package.json\` with major.minor.patch, but only major Node.js Version can be selected. Learn More: http://vercel.link/node-version`
          );
        } else if ((0, import_semver2.validRange)(node) && (0, import_semver2.intersects)(`${latestVersion.major + 1}.x`, node)) {
          console.warn(
            `Warning: Detected "engines": { "node": "${node}" } in your \`package.json\` that will automatically upgrade when a new major Node.js Version is released. Learn More: http://vercel.link/node-version`
          );
        }
      }
      return supportedNodeVersion;
    }
    async function scanParentDirs(destPath, readPackageJson = false, base = "/") {
      (0, import_assert6.default)(import_path5.default.isAbsolute(destPath));
      const pkgJsonPath = await walkParentDirs({
        base,
        start: destPath,
        filename: "package.json"
      });
      let packageJson;
      if (readPackageJson && pkgJsonPath) {
        try {
          packageJson = JSON.parse(await import_fs_extra7.default.readFile(pkgJsonPath, "utf8"));
        } catch (err) {
          throw new Error(
            `Could not read ${pkgJsonPath}: ${err.message}.`
          );
        }
      }
      const {
        paths: [
          yarnLockPath,
          npmLockPath,
          pnpmLockPath,
          bunLockTextPath,
          bunLockBinPath,
          vltLockPath
        ],
        packageJsonPackageManager
      } = await walkParentDirsMulti({
        base,
        start: destPath,
        filenames: [
          "yarn.lock",
          "package-lock.json",
          "pnpm-lock.yaml",
          "bun.lock",
          "bun.lockb",
          "vlt-lock.json"
        ]
      });
      let lockfilePath;
      let lockfileVersion;
      let cliType;
      const bunLockPath = bunLockTextPath ?? bunLockBinPath;
      const [packageLockJson, pnpmLockYaml, bunLock, yarnLock, vltLock] = await Promise.all([
        npmLockPath ? readConfigFile(npmLockPath) : null,
        pnpmLockPath ? readConfigFile(pnpmLockPath) : null,
        bunLockPath ? import_fs_extra7.default.readFile(bunLockPath) : null,
        yarnLockPath ? import_fs_extra7.default.readFile(yarnLockPath, "utf8") : null,
        vltLockPath ? readConfigFile(vltLockPath) : null
      ]);
      const rootProjectInfo = readPackageJson ? await readProjectRootInfo({
        base,
        start: destPath
      }) : void 0;
      const turboVersionRange = rootProjectInfo?.packageJson?.devDependencies?.turbo;
      const turboSupportsCorepackHome = turboVersionRange ? await checkTurboSupportsCorepack(
        turboVersionRange,
        rootProjectInfo?.rootDir
      ) : void 0;
      if (bunLock && yarnLock) {
        cliType = "bun";
        lockfilePath = bunLockPath;
        lockfileVersion = bunLockTextPath ? 1 : 0;
      } else if (yarnLock) {
        cliType = "yarn";
        lockfilePath = yarnLockPath;
        lockfileVersion = parseYarnLockVersion(yarnLock);
      } else if (pnpmLockYaml) {
        cliType = "pnpm";
        lockfilePath = pnpmLockPath;
        lockfileVersion = Number(pnpmLockYaml.lockfileVersion);
      } else if (packageLockJson) {
        cliType = "npm";
        lockfilePath = npmLockPath;
        lockfileVersion = packageLockJson.lockfileVersion;
      } else if (bunLock) {
        cliType = "bun";
        lockfilePath = bunLockPath;
        lockfileVersion = bunLockTextPath ? 1 : 0;
      } else if (vltLock) {
        cliType = "vlt";
        lockfilePath = vltLockPath;
      } else {
        cliType = detectPackageManagerNameWithoutLockfile(
          packageJsonPackageManager,
          turboSupportsCorepackHome
        );
      }
      const packageJsonPath = pkgJsonPath || void 0;
      return {
        cliType,
        packageJson,
        packageJsonPackageManager,
        lockfilePath,
        lockfileVersion,
        packageJsonPath,
        turboSupportsCorepackHome
      };
    }
    function parseYarnLockVersion(yarnLock) {
      if (!yarnLock.includes("__metadata:")) {
        return 1;
      }
      try {
        const metadata = import_js_yaml2.default.load(yarnLock).__metadata;
        return Number(metadata.version);
      } catch {
        return void 0;
      }
    }
    async function checkTurboSupportsCorepack(turboVersionRange, rootDir) {
      if (turboVersionSpecifierSupportsCorepack(turboVersionRange)) {
        return true;
      }
      const turboJsonPath = import_path5.default.join(rootDir, "turbo.json");
      const turboJsoncPath = import_path5.default.join(rootDir, "turbo.jsonc");
      const [turboJsonExists, turboJsoncExists] = await Promise.all([
        import_fs_extra7.default.pathExists(turboJsonPath),
        import_fs_extra7.default.pathExists(turboJsoncPath)
      ]);
      let turboJson = null;
      let turboConfigPath = null;
      if (turboJsonExists) {
        turboConfigPath = turboJsonPath;
      } else if (turboJsoncExists) {
        turboConfigPath = turboJsoncPath;
      }
      if (turboConfigPath) {
        try {
          turboJson = import_json5.default.parse(await import_fs_extra7.default.readFile(turboConfigPath, "utf8"));
        } catch (err) {
          console.warn(
            `WARNING: Failed to parse ${import_path5.default.basename(turboConfigPath)}`
          );
        }
      }
      const turboJsonIncludesCorepackHome = turboJson !== null && typeof turboJson === "object" && "globalPassThroughEnv" in turboJson && Array.isArray(turboJson.globalPassThroughEnv) && turboJson.globalPassThroughEnv.includes("COREPACK_HOME");
      return turboJsonIncludesCorepackHome;
    }
    function turboVersionSpecifierSupportsCorepack(turboVersionSpecifier) {
      if (!(0, import_semver2.validRange)(turboVersionSpecifier)) {
        return false;
      }
      const versionSupportingCorepack = "2.1.3";
      const minTurboBeingUsed = (0, import_semver2.minVersion)(turboVersionSpecifier);
      if (!minTurboBeingUsed) {
        return false;
      }
      return (0, import_semver2.gte)(minTurboBeingUsed, versionSupportingCorepack);
    }
    function detectPackageManagerNameWithoutLockfile(packageJsonPackageManager, turboSupportsCorepackHome) {
      if (usingCorepack(
        process.env,
        packageJsonPackageManager,
        turboSupportsCorepackHome
      )) {
        const corepackPackageManager = validateVersionSpecifier(
          packageJsonPackageManager
        );
        switch (corepackPackageManager?.packageName) {
          case "npm":
          case "pnpm":
          case "yarn":
          case "bun":
            return corepackPackageManager.packageName;
          case void 0:
            return "npm";
          default:
            throw new Error(
              `Unknown package manager "${corepackPackageManager?.packageName}". Change your package.json "packageManager" field to a known package manager: npm, pnpm, yarn, bun.`
            );
        }
      }
      return "npm";
    }
    function usingCorepack(env, packageJsonPackageManager, turboSupportsCorepackHome) {
      if (env.ENABLE_EXPERIMENTAL_COREPACK !== "1" || packageJsonPackageManager === void 0) {
        return false;
      }
      if (turboSupportsCorepackHome === false) {
        console.warn(
          "Warning: Disabling corepack because it may break your project. To use corepack, either upgrade to `turbo@2.1.3+` or include `COREPACK_HOME` in `turbo.json#globalPassThroughEnv`."
        );
        return false;
      }
      return true;
    }
    async function walkParentDirs({
      base,
      start,
      filename
    }) {
      (0, import_assert6.default)(import_path5.default.isAbsolute(base), 'Expected "base" to be absolute path');
      (0, import_assert6.default)(import_path5.default.isAbsolute(start), 'Expected "start" to be absolute path');
      for (const dir of traverseUpDirectories({ start, base })) {
        const fullPath = import_path5.default.join(dir, filename);
        if (await import_fs_extra7.default.pathExists(fullPath)) {
          return fullPath;
        }
      }
      return null;
    }
    async function walkParentDirsMulti({
      base,
      start,
      filenames
    }) {
      let packageManager;
      for (const dir of traverseUpDirectories({ start, base })) {
        const fullPaths = filenames.map((f) => import_path5.default.join(dir, f));
        const existResults = await Promise.all(
          fullPaths.map((f) => import_fs_extra7.default.pathExists(f))
        );
        const foundOneOrMore = existResults.some((b) => b);
        const packageJsonPath = import_path5.default.join(dir, "package.json");
        const packageJson = await import_fs_extra7.default.readJSON(packageJsonPath).catch(() => null);
        if (packageJson?.packageManager) {
          packageManager = packageJson.packageManager;
        }
        if (foundOneOrMore) {
          return {
            paths: fullPaths.map((f, i) => existResults[i] ? f : void 0),
            packageJsonPackageManager: packageManager
          };
        }
      }
      return { paths: [], packageJsonPackageManager: packageManager };
    }
    function isSet(v) {
      return v?.constructor?.name === "Set";
    }
    function getInstallCommandForPackageManager(packageManager, args) {
      switch (packageManager) {
        case "npm":
          return {
            prettyCommand: "npm install",
            commandArguments: args.filter((a) => a !== "--prefer-offline").concat(["install", "--no-audit", "--unsafe-perm"])
          };
        case "pnpm":
          return {
            prettyCommand: "pnpm install",
            // PNPM's install command is similar to NPM's but without the audit nonsense
            // @see options https://pnpm.io/cli/install
            commandArguments: args.filter((a) => a !== "--prefer-offline").concat(["install", "--unsafe-perm"])
          };
        case "bun":
          return {
            prettyCommand: "bun install",
            // @see options https://bun.sh/docs/cli/install
            commandArguments: ["install", ...args]
          };
        case "yarn":
          return {
            prettyCommand: "yarn install",
            commandArguments: ["install", ...args]
          };
        case "vlt":
          return {
            prettyCommand: "vlt install",
            commandArguments: ["install", ...args]
          };
      }
    }
    async function runInstallCommand({
      packageManager,
      args,
      opts
    }) {
      const { commandArguments, prettyCommand } = getInstallCommandForPackageManager(packageManager, args);
      opts.prettyCommand = prettyCommand;
      if (process.env.NPM_ONLY_PRODUCTION) {
        commandArguments.push("--production");
      }
      await spawnAsync(packageManager, commandArguments, opts);
    }
    function initializeSet(set) {
      if (!isSet(set)) {
        return /* @__PURE__ */ new Set();
      }
      return set;
    }
    function checkIfAlreadyInstalled(runNpmInstallSet, packageJsonPath) {
      const initializedRunNpmInstallSet = initializeSet(runNpmInstallSet);
      const alreadyInstalled = initializedRunNpmInstallSet.has(packageJsonPath);
      initializedRunNpmInstallSet.add(packageJsonPath);
      return { alreadyInstalled, runNpmInstallSet: initializedRunNpmInstallSet };
    }
    var runNpmInstallSema = new import_async_sema4.default(1);
    async function runNpmInstall(destPath, args = [], spawnOpts, meta, projectCreatedAt) {
      if (meta?.isDev) {
        debug("Skipping dependency installation because dev mode is enabled");
        return false;
      }
      (0, import_assert6.default)(import_path5.default.isAbsolute(destPath));
      try {
        await runNpmInstallSema.acquire();
        const {
          cliType,
          packageJsonPath,
          packageJson,
          lockfileVersion,
          packageJsonPackageManager,
          turboSupportsCorepackHome
        } = await scanParentDirs(destPath, true);
        if (!packageJsonPath) {
          debug(
            `Skipping dependency installation because no package.json was found for ${destPath}`
          );
          return false;
        }
        const defaultInstall = args.length === 0;
        if (meta && packageJsonPath && defaultInstall) {
          const { alreadyInstalled, runNpmInstallSet } = checkIfAlreadyInstalled(
            meta.runNpmInstallSet,
            packageJsonPath
          );
          if (alreadyInstalled) {
            return false;
          }
          meta.runNpmInstallSet = runNpmInstallSet;
        }
        if (cliType === "yarn") {
          const yarnVersion = detectYarnVersion(lockfileVersion);
          if (["yarn@3.x", "yarn@4.x"].includes(yarnVersion)) {
            await spawnAsync(
              "yarn",
              ["config", "set", "enableGlobalCache", "false"],
              { cwd: destPath }
            );
          }
        }
        const installTime = Date.now();
        console.log("Installing dependencies...");
        debug(`Installing to ${destPath}`);
        const opts = { cwd: destPath, ...spawnOpts };
        const env = cloneEnv(opts.env || process.env);
        delete env.NODE_ENV;
        opts.env = getEnvForPackageManager({
          cliType,
          lockfileVersion,
          packageJsonPackageManager,
          env,
          packageJsonEngines: packageJson?.engines,
          turboSupportsCorepackHome,
          projectCreatedAt
        });
        const maySeeDynamicRequireYarnBug = process.env?.ENABLE_EXPERIMENTAL_COREPACK && packageJson?.packageManager?.startsWith("yarn") && packageJson?.type === "module";
        if (maySeeDynamicRequireYarnBug) {
          console.warn(
            `Warning: This project may see "Error: Dynamic require of "util" is not supported". To avoid this error, remove \`"type": "module"\` from your package.json file, or use \`yarnPath\` instead of Corepack. Learn more: https://vercel.com/docs/errors/error-list#yarn-dynamic-require-of-util-is-not-supported`
          );
        }
        await runInstallCommand({
          packageManager: cliType,
          args,
          opts
        });
        debug(`Install complete [${Date.now() - installTime}ms]`);
        return true;
      } finally {
        runNpmInstallSema.release();
      }
    }
    function getEnvForPackageManager({
      cliType,
      lockfileVersion,
      packageJsonPackageManager,
      env,
      packageJsonEngines,
      turboSupportsCorepackHome,
      projectCreatedAt
    }) {
      const corepackEnabled = usingCorepack(
        env,
        packageJsonPackageManager,
        turboSupportsCorepackHome
      );
      const {
        detectedLockfile,
        detectedPackageManager,
        path: newPath
      } = getPathOverrideForPackageManager({
        cliType,
        lockfileVersion,
        corepackPackageManager: packageJsonPackageManager,
        corepackEnabled,
        packageJsonEngines,
        projectCreatedAt
      });
      if (corepackEnabled) {
        debug(
          `Detected corepack use for "${packageJsonPackageManager}". Not overriding package manager version.`
        );
      } else {
        debug(
          `Detected ${detectedPackageManager}. Added "${newPath}" to path. Based on assumed package manager "${cliType}", lockfile "${detectedLockfile}", and lockfileVersion "${lockfileVersion}"`
        );
      }
      const newEnv = {
        ...env
      };
      const alreadyInPath = (newPath2) => {
        const oldPath = env.PATH ?? "";
        return oldPath.split(import_path5.default.delimiter).includes(newPath2);
      };
      if (newPath && !alreadyInPath(newPath)) {
        const oldPath = env.PATH + "";
        newEnv.PATH = `${newPath}${import_path5.default.delimiter}${oldPath}`;
        if (detectedLockfile && detectedPackageManager) {
          const detectedV9PnpmLockfile = detectedLockfile === "pnpm-lock.yaml" && lockfileVersion === 9;
          const pnpm10UsingPackageJsonPackageManager = detectedPackageManager === "pnpm@10.x" && packageJsonPackageManager;
          if (pnpm10UsingPackageJsonPackageManager) {
            const versionString = cliType === "pnpm" ? `version ${lockfileVersion} ` : "";
            console.log(
              `Detected \`${detectedLockfile}\` ${versionString}generated by ${detectedPackageManager} with package.json#packageManager ${packageJsonPackageManager}`
            );
          } else if (detectedV9PnpmLockfile) {
            const otherVersion = detectedPackageManager === "pnpm@10.x" ? `pnpm@9.x` : `pnpm@10.x`;
            console.log(
              `Detected \`${detectedLockfile}\` ${lockfileVersion} which may be generated by pnpm@9.x or pnpm@10.x
Using ${detectedPackageManager} based on project creation date
To use ${otherVersion}, manually opt in using corepack (https://vercel.com/docs/deployments/configure-a-build#corepack)`
            );
          } else {
            const versionString = cliType === "pnpm" ? `version ${lockfileVersion} ` : "";
            console.log(
              `Detected \`${detectedLockfile}\` ${versionString}generated by ${detectedPackageManager}`
            );
          }
          if (cliType === "bun") {
            console.warn(
              "Warning: Bun is used as a package manager at build time only, not at runtime with Functions"
            );
          }
        }
      }
      if (cliType === "yarn" && !env.YARN_NODE_LINKER) {
        newEnv.YARN_NODE_LINKER = "node-modules";
      }
      return newEnv;
    }
    var PNPM_10_PREFERRED_AT = /* @__PURE__ */ new Date("2025-02-27T20:00:00Z");
    function detectPnpmVersion(lockfileVersion, projectCreatedAt) {
      switch (true) {
        case lockfileVersion === void 0:
          return "not found";
        case lockfileVersion === 5.3:
          return "pnpm 6";
        case lockfileVersion === 5.4:
          return "pnpm 7";
        case (lockfileVersion === 6 || lockfileVersion === 6.1):
          return "pnpm 8";
        case lockfileVersion === 7:
          return "pnpm 9";
        case lockfileVersion === 9: {
          const projectPrefersPnpm10 = projectCreatedAt && projectCreatedAt >= PNPM_10_PREFERRED_AT.getTime();
          return projectPrefersPnpm10 ? "pnpm 10" : "pnpm 9";
        }
        default:
          return "not found";
      }
    }
    function detectYarnVersion(lockfileVersion) {
      if (lockfileVersion) {
        if ([1].includes(lockfileVersion)) {
          return "yarn@1.x";
        } else if ([4, 5].includes(lockfileVersion)) {
          return "yarn@2.x";
        } else if ([6, 7].includes(lockfileVersion)) {
          return "yarn@3.x";
        } else if ([8].includes(lockfileVersion)) {
          return "yarn@4.x";
        }
      }
      return "unknown yarn";
    }
    function validLockfileForPackageManager(cliType, lockfileVersion, packageManagerVersion) {
      const packageManagerMajorVersion = packageManagerVersion.major;
      switch (cliType) {
        case "npm":
        case "bun":
        case "yarn":
        case "vlt":
          return true;
        case "pnpm":
          switch (packageManagerMajorVersion) {
            case 10:
              return lockfileVersion === 9;
            case 9:
              if ("9.0.0" === packageManagerVersion.version && lockfileVersion === 6) {
                return false;
              }
              return [6, 7, 9].includes(lockfileVersion);
            case 8:
              return [6, 6.1].includes(lockfileVersion);
            case 7:
              return [5.3, 5.4].includes(lockfileVersion);
            case 6:
              return [5.3, 5.4].includes(lockfileVersion);
            default:
              return true;
          }
      }
    }
    function getPathOverrideForPackageManager({
      cliType,
      lockfileVersion,
      corepackPackageManager,
      corepackEnabled = true,
      packageJsonEngines,
      projectCreatedAt
    }) {
      const detectedPackageManger = detectPackageManager(
        cliType,
        lockfileVersion,
        projectCreatedAt
      );
      const usingCorepack2 = corepackPackageManager && corepackEnabled;
      if (usingCorepack2) {
        validateCorepackPackageManager(
          cliType,
          lockfileVersion,
          corepackPackageManager,
          packageJsonEngines?.pnpm
        );
        return NO_OVERRIDE;
      }
      if (cliType === "pnpm" && packageJsonEngines?.pnpm) {
        const usingDetected = detectedPackageManger?.pnpmVersionRange !== "10.x" || !corepackPackageManager;
        if (usingDetected) {
          checkEnginesPnpmAgainstDetected(
            packageJsonEngines.pnpm,
            detectedPackageManger
          );
        }
      }
      return detectedPackageManger ?? NO_OVERRIDE;
    }
    function checkEnginesPnpmAgainstDetected(enginesPnpm, detectedPackageManger) {
      if (detectedPackageManger?.pnpmVersionRange && (0, import_semver2.validRange)(detectedPackageManger.pnpmVersionRange) && (0, import_semver2.validRange)(enginesPnpm)) {
        if (!(0, import_semver2.intersects)(detectedPackageManger.pnpmVersionRange, enginesPnpm)) {
          throw new Error(
            `Detected pnpm "${detectedPackageManger.pnpmVersionRange}" is not compatible with the engines.pnpm "${enginesPnpm}" in your package.json. Either enable corepack with a valid package.json#packageManager value (https://vercel.com/docs/deployments/configure-a-build#corepack) or remove your package.json#engines.pnpm.`
          );
        }
      }
      console.warn(
        `Using package.json#engines.pnpm without corepack and package.json#packageManager could lead to failed builds with ERR_PNPM_UNSUPPORTED_ENGINE. Learn more: https://vercel.com/docs/errors/error-list#pnpm-engine-unsupported`
      );
    }
    function validateCorepackPackageManager(cliType, lockfileVersion, corepackPackageManager, enginesPnpmVersionRange) {
      const validatedCorepackPackageManager = validateVersionSpecifier(
        corepackPackageManager
      );
      if (!validatedCorepackPackageManager) {
        throw new Error(
          `Intended corepack defined package manager "${corepackPackageManager}" is not a valid semver value.`
        );
      }
      if (cliType !== validatedCorepackPackageManager.packageName) {
        throw new Error(
          `Detected package manager "${cliType}" does not match intended corepack defined package manager "${validatedCorepackPackageManager.packageName}". Change your lockfile or "package.json#packageManager" value to match.`
        );
      }
      if (cliType === "pnpm" && enginesPnpmVersionRange) {
        const pnpmWithinEngineRange = (0, import_semver2.satisfies)(
          validatedCorepackPackageManager.packageVersion,
          enginesPnpmVersionRange
        );
        if (!pnpmWithinEngineRange) {
          throw new Error(
            `The version of pnpm specified in package.json#packageManager (${validatedCorepackPackageManager.packageVersion}) must satisfy the version range in package.json#engines.pnpm (${enginesPnpmVersionRange}).`
          );
        }
      }
      if (lockfileVersion) {
        const lockfileValid = validLockfileForPackageManager(
          cliType,
          lockfileVersion,
          validatedCorepackPackageManager.packageVersion
        );
        if (!lockfileValid) {
          throw new Error(
            `Detected lockfile "${lockfileVersion}" which is not compatible with the intended corepack package manager "${corepackPackageManager}". Update your lockfile or change to a compatible corepack version.`
          );
        }
      }
    }
    function validateVersionSpecifier(version) {
      if (!version) {
        return void 0;
      }
      const [before, after, ...extra] = version.split("@");
      if (extra.length) {
        return void 0;
      }
      if (!before) {
        return void 0;
      }
      if (!after) {
        return void 0;
      }
      const packageVersion = (0, import_semver2.parse)(after);
      if (!packageVersion) {
        return void 0;
      }
      return {
        packageName: before,
        packageVersion
      };
    }
    function detectPackageManager(cliType, lockfileVersion, projectCreatedAt) {
      switch (cliType) {
        case "npm":
          return void 0;
        case "pnpm":
          switch (detectPnpmVersion(lockfileVersion, projectCreatedAt)) {
            case "pnpm 7":
              return {
                path: "/pnpm7/node_modules/.bin",
                detectedLockfile: "pnpm-lock.yaml",
                detectedPackageManager: "pnpm@7.x",
                pnpmVersionRange: "7.x"
              };
            case "pnpm 8":
              return {
                path: "/pnpm8/node_modules/.bin",
                detectedLockfile: "pnpm-lock.yaml",
                detectedPackageManager: "pnpm@8.x",
                pnpmVersionRange: "8.x"
              };
            case "pnpm 9":
              return {
                path: "/pnpm9/node_modules/.bin",
                detectedLockfile: "pnpm-lock.yaml",
                detectedPackageManager: "pnpm@9.x",
                pnpmVersionRange: "9.x"
              };
            case "pnpm 10":
              return {
                path: "/pnpm10/node_modules/.bin",
                detectedLockfile: "pnpm-lock.yaml",
                detectedPackageManager: "pnpm@10.x",
                pnpmVersionRange: "10.x"
              };
            case "pnpm 6":
              return {
                path: "/pnpm6/node_modules/.bin",
                detectedLockfile: "pnpm-lock.yaml",
                detectedPackageManager: "pnpm@6.x",
                pnpmVersionRange: "6.x"
              };
            default:
              return void 0;
          }
        case "bun":
          return {
            path: "/bun1",
            detectedLockfile: lockfileVersion === 0 ? "bun.lockb" : "bun.lock",
            detectedPackageManager: "bun@1.x"
          };
        case "yarn":
          return {
            path: void 0,
            detectedLockfile: "yarn.lock",
            detectedPackageManager: detectYarnVersion(lockfileVersion)
          };
        case "vlt":
          return {
            path: void 0,
            detectedLockfile: "vlt-lock.json",
            detectedPackageManager: "vlt@0.x"
          };
      }
    }
    function getPathForPackageManager({
      cliType,
      lockfileVersion,
      env
    }) {
      const corepackEnabled = env.ENABLE_EXPERIMENTAL_COREPACK === "1";
      let overrides = getPathOverrideForPackageManager({
        cliType,
        lockfileVersion,
        corepackPackageManager: void 0
      });
      if (corepackEnabled) {
        overrides = NO_OVERRIDE;
      }
      const alreadyInPath = (newPath) => {
        const oldPath = env.PATH ?? "";
        return oldPath.split(import_path5.default.delimiter).includes(newPath);
      };
      switch (true) {
        case (cliType === "yarn" && !env.YARN_NODE_LINKER):
          return { ...overrides, yarnNodeLinker: "node-modules" };
        case alreadyInPath(overrides.path ?? ""):
          return {
            detectedLockfile: void 0,
            detectedPackageManager: void 0,
            path: void 0,
            yarnNodeLinker: void 0
          };
        default:
          return { ...overrides, yarnNodeLinker: void 0 };
      }
    }
    async function runCustomInstallCommand({
      destPath,
      installCommand,
      spawnOpts,
      projectCreatedAt
    }) {
      console.log(`Running "install" command: \`${installCommand}\`...`);
      const {
        cliType,
        lockfileVersion,
        packageJson,
        packageJsonPackageManager,
        turboSupportsCorepackHome
      } = await scanParentDirs(destPath, true);
      const env = getEnvForPackageManager({
        cliType,
        lockfileVersion,
        packageJsonPackageManager,
        env: spawnOpts?.env || {},
        packageJsonEngines: packageJson?.engines,
        turboSupportsCorepackHome,
        projectCreatedAt
      });
      debug(`Running with $PATH:`, env?.PATH || "");
      await execCommand(installCommand, {
        ...spawnOpts,
        env,
        cwd: destPath
      });
    }
    async function runPackageJsonScript(destPath, scriptNames, spawnOpts, projectCreatedAt) {
      (0, import_assert6.default)(import_path5.default.isAbsolute(destPath));
      const {
        packageJson,
        cliType,
        lockfileVersion,
        packageJsonPackageManager,
        turboSupportsCorepackHome
      } = await scanParentDirs(destPath, true);
      const scriptName = getScriptName(
        packageJson,
        typeof scriptNames === "string" ? [scriptNames] : scriptNames
      );
      if (!scriptName)
        return false;
      debug("Running user script...");
      const runScriptTime = Date.now();
      const opts = {
        cwd: destPath,
        ...spawnOpts,
        env: getEnvForPackageManager({
          cliType,
          lockfileVersion,
          packageJsonPackageManager,
          env: cloneEnv(process.env, spawnOpts?.env),
          packageJsonEngines: packageJson?.engines,
          turboSupportsCorepackHome,
          projectCreatedAt
        })
      };
      if (cliType === "npm") {
        opts.prettyCommand = `npm run ${scriptName}`;
      } else if (cliType === "pnpm") {
        opts.prettyCommand = `pnpm run ${scriptName}`;
      } else if (cliType === "bun") {
        opts.prettyCommand = `bun run ${scriptName}`;
      } else if (cliType === "vlt") {
        opts.prettyCommand = `vlt run ${scriptName}`;
      } else {
        opts.prettyCommand = `yarn run ${scriptName}`;
      }
      console.log(`Running "${opts.prettyCommand}"`);
      await spawnAsync(cliType, ["run", scriptName], opts);
      debug(`Script complete [${Date.now() - runScriptTime}ms]`);
      return true;
    }
    async function runBundleInstall(destPath, args = [], spawnOpts, meta) {
      if (meta && meta.isDev) {
        debug("Skipping dependency installation because dev mode is enabled");
        return;
      }
      (0, import_assert6.default)(import_path5.default.isAbsolute(destPath));
      const opts = { ...spawnOpts, cwd: destPath, prettyCommand: "bundle install" };
      await spawnAsync("bundle", args.concat(["install"]), opts);
    }
    async function runPipInstall(destPath, args = [], spawnOpts, meta) {
      if (meta && meta.isDev) {
        debug("Skipping dependency installation because dev mode is enabled");
        return;
      }
      (0, import_assert6.default)(import_path5.default.isAbsolute(destPath));
      const opts = { ...spawnOpts, cwd: destPath, prettyCommand: "pip3 install" };
      await spawnAsync(
        "pip3",
        ["install", "--disable-pip-version-check", ...args],
        opts
      );
    }
    function getScriptName(pkg, possibleNames) {
      if (pkg?.scripts) {
        for (const name of possibleNames) {
          if (name in pkg.scripts) {
            return name;
          }
        }
      }
      return void 0;
    }
    var installDependencies = (0, import_util2.deprecate)(
      runNpmInstall,
      "installDependencies() is deprecated. Please use runNpmInstall() instead."
    );
    var import_path6 = __toESM(require("path"));
    var import_fs_extra8 = __toESM(require_lib());
    var import_ignore = __toESM(require_ignore());
    function isCodedError(error) {
      return error !== null && error !== void 0 && error.code !== void 0;
    }
    function clearRelative(s) {
      return s.replace(/(\n|^)\.\//g, "$1");
    }
    async function get_ignore_filter_default(downloadPath, rootDirectory) {
      const readFile4 = async (p) => {
        try {
          return await import_fs_extra8.default.readFile(p, "utf8");
        } catch (error) {
          if (error.code === "ENOENT" || error instanceof Error && error.message.includes("ENOENT")) {
            return void 0;
          }
          throw error;
        }
      };
      const vercelIgnorePath = import_path6.default.join(
        downloadPath,
        rootDirectory || "",
        ".vercelignore"
      );
      const nowIgnorePath = import_path6.default.join(
        downloadPath,
        rootDirectory || "",
        ".nowignore"
      );
      const ignoreContents = [];
      try {
        ignoreContents.push(
          ...(await Promise.all([readFile4(vercelIgnorePath), readFile4(nowIgnorePath)])).filter(Boolean)
        );
      } catch (error) {
        if (isCodedError(error) && error.code === "ENOTDIR") {
          console.log(`Warning: Cannot read ignore file from ${vercelIgnorePath}`);
        } else {
          throw error;
        }
      }
      if (ignoreContents.length === 2) {
        throw new Error(
          "Cannot use both a `.vercelignore` and `.nowignore` file. Please delete the `.nowignore` file."
        );
      }
      if (ignoreContents.length === 0) {
        return () => false;
      }
      const ignoreFilter = (0, import_ignore.default)().add(clearRelative(ignoreContents[0]));
      return function(p) {
        if (p === "now.json" || p === "vercel.json")
          return false;
        return ignoreFilter.test(p).ignored;
      };
    }
    function getPrefixedEnvVars({
      envPrefix,
      envs
    }) {
      const vercelSystemEnvPrefix = "VERCEL_";
      const allowed = [
        "VERCEL_URL",
        "VERCEL_ENV",
        "VERCEL_TARGET_ENV",
        "VERCEL_REGION",
        "VERCEL_BRANCH_URL",
        "VERCEL_PROJECT_PRODUCTION_URL",
        "VERCEL_DEPLOYMENT_ID",
        "VERCEL_PROJECT_ID"
      ];
      const newEnvs = {};
      if (envPrefix && envs.VERCEL_URL) {
        Object.keys(envs).filter((key) => allowed.includes(key) || key.startsWith("VERCEL_GIT_")).forEach((key) => {
          const newKey = `${envPrefix}${key}`;
          if (!(newKey in envs)) {
            newEnvs[newKey] = envs[key];
          }
        });
        newEnvs.TURBO_CI_VENDOR_ENV_KEY = `${envPrefix}${vercelSystemEnvPrefix}`;
      }
      return newEnvs;
    }
    var import_path7 = __toESM(require("path"));
    var import_fs2 = require("fs");
    async function hardLinkDir(src, destDirs) {
      if (destDirs.length === 0)
        return;
      destDirs = destDirs.filter((destDir) => import_path7.default.relative(destDir, src) !== "");
      const files = await import_fs2.promises.readdir(src);
      await Promise.all(
        files.map(async (file) => {
          if (file === "node_modules")
            return;
          const srcFile = import_path7.default.join(src, file);
          if ((await import_fs2.promises.lstat(srcFile)).isDirectory()) {
            const destSubdirs = await Promise.all(
              destDirs.map(async (destDir) => {
                const destSubdir = import_path7.default.join(destDir, file);
                try {
                  await import_fs2.promises.mkdir(destSubdir, { recursive: true });
                } catch (err) {
                  if (err.code !== "EEXIST")
                    throw err;
                }
                return destSubdir;
              })
            );
            await hardLinkDir(srcFile, destSubdirs);
            return;
          }
          await Promise.all(
            destDirs.map(async (destDir) => {
              const destFile = import_path7.default.join(destDir, file);
              try {
                await linkOrCopyFile(srcFile, destFile);
              } catch (err) {
                if (err.code === "ENOENT") {
                  return;
                }
                throw err;
              }
            })
          );
        })
      );
    }
    async function linkOrCopyFile(srcFile, destFile) {
      try {
        await linkOrCopy(srcFile, destFile);
      } catch (err) {
        if (err.code === "ENOENT") {
          await import_fs2.promises.mkdir(import_path7.default.dirname(destFile), { recursive: true });
          await linkOrCopy(srcFile, destFile);
          return;
        }
        if (err.code !== "EEXIST") {
          throw err;
        }
      }
    }
    async function linkOrCopy(srcFile, destFile) {
      try {
        await import_fs2.promises.link(srcFile, destFile);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        await import_fs2.promises.copyFile(srcFile, destFile);
      }
    }
    var import_path8 = require("path");
    var import_promises = require("fs/promises");
    async function validateNpmrc(cwd) {
      const npmrc = await (0, import_promises.readFile)((0, import_path8.join)(cwd, ".npmrc"), "utf-8").catch((err) => {
        if (err.code !== "ENOENT")
          throw err;
      });
      const nodeRegExp = /(?<!#.*)use-node-version/;
      if (npmrc?.match(nodeRegExp)) {
        throw new Error(
          'Detected unsupported "use-node-version" in your ".npmrc". Please use "engines" in your "package.json" instead.'
        );
      }
    }
    var EdgeFunction = class {
      constructor(params) {
        this.type = "EdgeFunction";
        this.name = params.name;
        this.deploymentTarget = params.deploymentTarget;
        this.entrypoint = params.entrypoint;
        this.files = params.files;
        this.assets = params.assets;
        this.regions = params.regions;
        this.framework = params.framework;
        this.environment = params.environment;
      }
    };
    var import_fs_extra9 = __toESM(require_lib());
    var import_error_utils2 = __toESM(require_dist());
    async function getOsRelease() {
      try {
        const data = await (0, import_fs_extra9.readFile)("/etc/os-release", "utf8");
        return await parseOsRelease(data);
      } catch (err) {
        if ((0, import_error_utils2.isErrnoException)(err) && err.code === "ENOENT") {
          return null;
        }
        throw err;
      }
    }
    async function parseOsRelease(data) {
      const obj = {};
      for (const line of data.trim().split("\n")) {
        const m = /(?<key>.*)="(?<value>.*)"/.exec(line);
        if (!m?.groups) {
          continue;
        }
        obj[m.groups.key] = m.groups.value;
      }
      return obj;
    }
    async function getProvidedRuntime() {
      const os = await getOsRelease();
      if (!os) {
        return "provided.al2023";
      }
      return os.PRETTY_NAME === "Amazon Linux 2" ? "provided.al2" : "provided.al2023";
    }
    var import_path9 = require("path");
    var shouldServe = ({
      entrypoint,
      files,
      requestPath
    }) => {
      requestPath = requestPath.replace(/\/$/, "");
      entrypoint = entrypoint.replace(/\\/, "/");
      if (entrypoint === requestPath && hasProp(files, entrypoint)) {
        return true;
      }
      const { dir, name } = (0, import_path9.parse)(entrypoint);
      if (name === "index" && dir === requestPath && hasProp(files, entrypoint)) {
        return true;
      }
      return false;
    };
    function hasProp(obj, key) {
      return Object.hasOwnProperty.call(obj, key);
    }
    var triggerEventSchema = {
      type: "object",
      properties: {
        type: {
          type: "string",
          const: "queue/v1beta"
        },
        topic: {
          type: "string",
          minLength: 1
        },
        consumer: {
          type: "string",
          minLength: 1
        },
        maxDeliveries: {
          type: "number",
          minimum: 1
        },
        retryAfterSeconds: {
          type: "number",
          exclusiveMinimum: 0
        },
        initialDelaySeconds: {
          type: "number",
          minimum: 0
        }
      },
      required: ["type", "topic", "consumer"],
      additionalProperties: false
    };
    var functionsSchema = {
      type: "object",
      minProperties: 1,
      maxProperties: 50,
      additionalProperties: false,
      patternProperties: {
        "^.{1,256}$": {
          type: "object",
          additionalProperties: false,
          properties: {
            architecture: {
              type: "string",
              enum: ["x86_64", "arm64"]
            },
            runtime: {
              type: "string",
              maxLength: 256
            },
            memory: {
              minimum: 128,
              maximum: 10240
            },
            maxDuration: {
              type: "number",
              minimum: 1,
              maximum: 900
            },
            includeFiles: {
              type: "string",
              maxLength: 256
            },
            excludeFiles: {
              type: "string",
              maxLength: 256
            },
            experimentalTriggers: {
              type: "array",
              items: triggerEventSchema
            },
            supportsCancellation: {
              type: "boolean"
            }
          }
        }
      }
    };
    var buildsSchema = {
      type: "array",
      minItems: 0,
      maxItems: 128,
      items: {
        type: "object",
        additionalProperties: false,
        required: ["use"],
        properties: {
          src: {
            type: "string",
            minLength: 1,
            maxLength: 4096
          },
          use: {
            type: "string",
            minLength: 3,
            maxLength: 256
          },
          config: { type: "object" }
        }
      }
    };
    var import_node_crypto = require("crypto");
    var NUM_OF_MICROSEC_IN_NANOSEC = BigInt("1000");
    function mapUndefinedAttributes(attrs) {
      return Object.fromEntries(
        Object.entries(attrs ?? {}).filter(
          (attr) => !!attr[1]
        )
      );
    }
    var Span = class _Span {
      constructor({
        name,
        parentId,
        attrs,
        reporter
      }) {
        this.name = name;
        this.parentId = parentId;
        this.attrs = mapUndefinedAttributes(attrs);
        this.status = "started";
        this.id = (0, import_node_crypto.randomUUID)();
        this._reporter = reporter;
        this.now = Date.now();
        this._start = process.hrtime.bigint();
      }
      stop() {
        if (this.status === "stopped") {
          throw new Error(`Cannot stop a span which is already stopped`);
        }
        this.status = "stopped";
        const end = process.hrtime.bigint();
        const duration = Number((end - this._start) / NUM_OF_MICROSEC_IN_NANOSEC);
        const timestamp = Number(this._start / NUM_OF_MICROSEC_IN_NANOSEC);
        const traceEvent = {
          name: this.name,
          duration,
          timestamp,
          id: this.id,
          parentId: this.parentId,
          tags: this.attrs,
          startTime: this.now
        };
        if (this._reporter) {
          this._reporter.report(traceEvent);
        }
      }
      setAttributes(attrs) {
        Object.assign(this.attrs, mapUndefinedAttributes(attrs));
      }
      child(name, attrs) {
        return new _Span({
          name,
          parentId: this.id,
          attrs,
          reporter: this._reporter
        });
      }
      async trace(fn) {
        try {
          return await fn(this);
        } finally {
          this.stop();
        }
      }
    };
    var BUILDER_INSTALLER_STEP = "vc.builder.install";
    var BUILDER_COMPILE_STEP = "vc.builder.build";
    async function getInstalledPackageVersion(packageName, path7) {
      try {
        const resolved = require.resolve(`${packageName}/package.json`, {
          paths: path7 ? Array.isArray(path7) ? path7 : [path7] : [process.cwd()]
        });
        const version = require(resolved).version;
        return version;
      } catch (err) {
        debug(
          `Could not resolve package "${packageName}". Package is not installed.`,
          err
        );
        return void 0;
      }
    }
    var defaultCachePathGlob = "**/{node_modules,.yarn/cache}/**";
    var import_node_path = require("path");
    var import_node_fs = __toESM(require("fs"));
    var import_node_module = require("module");
    function generateNodeBuilderFunctions(frameworkName, regex, validFilenames, validExtensions, nodeBuild) {
      const entrypointsForMessage = validFilenames.map((filename) => `- ${filename}.{${validExtensions.join(",")}}`).join("\n");
      const require_ = (0, import_node_module.createRequire)(__filename);
      const build = async (args) => {
        process.env.EXPERIMENTAL_NODE_TYPESCRIPT_ERRORS = "1";
        const includeFiles = ["views/**/*"];
        const includeFilesFromConfig = args.config.includeFiles;
        if (includeFilesFromConfig) {
          includeFiles.push(...includeFilesFromConfig);
        }
        const res = await nodeBuild({
          ...args,
          config: {
            ...args.config,
            includeFiles
          },
          // this is package.json, but we'll replace it with the return value of the entrypointCallback
          // after install and build scripts have had a chance to run
          entrypoint: "package.json",
          considerBuildCommand: true,
          entrypointCallback: async () => {
            return entrypointCallback(args);
          }
        });
        let version = void 0;
        try {
          const resolved = require_.resolve(`${frameworkName}/package.json`, {
            paths: [args.workPath]
          });
          const frameworkVersion = require_(resolved).version;
          if (frameworkVersion) {
            version = frameworkVersion;
          }
        } catch (e) {
        }
        res.output.framework = {
          slug: frameworkName,
          version
        };
        return res;
      };
      const entrypointCallback = async (args) => {
        const mainPackageEntrypoint = findMainPackageEntrypoint(args.files);
        const entrypointGlob = `{${validFilenames.map((entrypoint) => `${entrypoint}`).join(",")}}.{${validExtensions.join(",")}}`;
        const dir = args.config.projectSettings?.outputDirectory?.replace(
          /^\/+|\/+$/g,
          ""
        );
        if (dir) {
          const {
            entrypoint: entrypointFromOutputDir,
            entrypointsNotMatchingRegex: entrypointsNotMatchingRegex2
          } = findEntrypoint(await glob(entrypointGlob, (0, import_node_path.join)(args.workPath, dir)));
          if (entrypointFromOutputDir) {
            return (0, import_node_path.join)(dir, entrypointFromOutputDir);
          }
          if (entrypointsNotMatchingRegex2.length > 0) {
            throw new Error(
              `No entrypoint found which imports ${frameworkName}. Found possible ${pluralize("entrypoint", entrypointsNotMatchingRegex2.length)}: ${entrypointsNotMatchingRegex2.join(", ")}`
            );
          }
          throw new Error(
            `No entrypoint found in output directory: "${dir}". Searched for: 
${entrypointsForMessage}`
          );
        }
        const files = await glob(entrypointGlob, args.workPath);
        const { entrypoint: entrypointFromRoot, entrypointsNotMatchingRegex } = findEntrypoint(files);
        if (entrypointFromRoot) {
          return entrypointFromRoot;
        }
        if (mainPackageEntrypoint) {
          const entrypointFromPackageJson = await glob(
            mainPackageEntrypoint,
            args.workPath
          );
          if (entrypointFromPackageJson[mainPackageEntrypoint]) {
            if (checkMatchesRegex(entrypointFromPackageJson[mainPackageEntrypoint])) {
              return mainPackageEntrypoint;
            }
          }
        }
        if (entrypointsNotMatchingRegex.length > 0) {
          throw new Error(
            `No entrypoint found which imports ${frameworkName}. Found possible ${pluralize("entrypoint", entrypointsNotMatchingRegex.length)}: ${entrypointsNotMatchingRegex.join(", ")}`
          );
        }
        throw new Error(
          `No entrypoint found. Searched for:
${entrypointsForMessage}`
        );
      };
      function pluralize(word, count) {
        return count === 1 ? word : `${word}s`;
      }
      const findEntrypoint = (files) => {
        const allEntrypoints = validFilenames.flatMap(
          (filename) => validExtensions.map((extension) => `${filename}.${extension}`)
        );
        const possibleEntrypointsInFiles = allEntrypoints.filter((entrypoint2) => {
          return files[entrypoint2] !== void 0;
        });
        const entrypointsMatchingRegex = possibleEntrypointsInFiles.filter(
          (entrypoint2) => {
            const file = files[entrypoint2];
            return checkMatchesRegex(file);
          }
        );
        const entrypointsNotMatchingRegex = possibleEntrypointsInFiles.filter(
          (entrypoint2) => {
            const file = files[entrypoint2];
            return !checkMatchesRegex(file);
          }
        );
        const entrypoint = entrypointsMatchingRegex[0];
        if (entrypointsMatchingRegex.length > 1) {
          console.warn(
            `Multiple entrypoints found: ${entrypointsMatchingRegex.join(", ")}. Using ${entrypoint}.`
          );
        }
        return {
          entrypoint,
          entrypointsNotMatchingRegex
        };
      };
      const checkMatchesRegex = (file) => {
        const content = import_node_fs.default.readFileSync(file.fsPath, "utf-8");
        const matchesContent = content.match(regex);
        return matchesContent !== null;
      };
      const findMainPackageEntrypoint = (files) => {
        const packageJson = files["package.json"];
        if (packageJson) {
          if (packageJson.type === "FileFsRef") {
            const packageJsonContent = import_node_fs.default.readFileSync(packageJson.fsPath, "utf-8");
            let packageJsonJson;
            try {
              packageJsonJson = JSON.parse(packageJsonContent);
            } catch (_e) {
              packageJsonJson = {};
            }
            if ("main" in packageJsonJson && typeof packageJsonJson.main === "string") {
              return packageJsonJson.main;
            }
          }
        }
        return null;
      };
      return {
        require_,
        findEntrypoint,
        build,
        entrypointCallback
      };
    }
    var BACKEND_FRAMEWORKS = [
      "express",
      "hono",
      "h3",
      "nestjs",
      "fastify"
    ];
    function isBackendFramework(framework) {
      if (!framework)
        return false;
      return BACKEND_FRAMEWORKS.includes(framework);
    }
    function isExperimentalBackendsEnabled() {
      return process.env.VERCEL_EXPERIMENTAL_BACKENDS === "1" || // Previously used for experimental express and hono builds
      process.env.VERCEL_EXPERIMENTAL_EXPRESS_BUILD === "1" || process.env.VERCEL_EXPERIMENTAL_HONO_BUILD === "1";
    }
    function shouldUseExperimentalBackends(framework) {
      return isExperimentalBackendsEnabled() && isBackendFramework(framework);
    }
  }
});

// ../../node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/cjs/_interop_require_default.cjs
var require_interop_require_default = __commonJS2({
  "../../node_modules/.pnpm/@swc+helpers@0.5.15/node_modules/@swc/helpers/cjs/_interop_require_default.cjs"(exports2) {
    "use strict";
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2._ = _interop_require_default;
  }
});

// ../../node_modules/.pnpm/next@16.0.1_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/shared/lib/modern-browserslist-target.js
var require_modern_browserslist_target = __commonJS2({
  "../../node_modules/.pnpm/next@16.0.1_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/shared/lib/modern-browserslist-target.js"(exports2, module2) {
    "use strict";
    var MODERN_BROWSERSLIST_TARGET = [
      "chrome 111",
      "edge 111",
      "firefox 111",
      "safari 16.4"
    ];
    module2.exports = MODERN_BROWSERSLIST_TARGET;
  }
});

// ../../node_modules/.pnpm/next@16.0.1_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/shared/lib/entry-constants.js
var require_entry_constants = __commonJS2({
  "../../node_modules/.pnpm/next@16.0.1_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/shared/lib/entry-constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports2, {
      UNDERSCORE_GLOBAL_ERROR_ROUTE: function() {
        return UNDERSCORE_GLOBAL_ERROR_ROUTE;
      },
      UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY: function() {
        return UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY;
      },
      UNDERSCORE_NOT_FOUND_ROUTE: function() {
        return UNDERSCORE_NOT_FOUND_ROUTE;
      },
      UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: function() {
        return UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;
      }
    });
    var UNDERSCORE_NOT_FOUND_ROUTE = "/_not-found";
    var UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = `${UNDERSCORE_NOT_FOUND_ROUTE}/page`;
    var UNDERSCORE_GLOBAL_ERROR_ROUTE = "/_global-error";
    var UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY = `${UNDERSCORE_GLOBAL_ERROR_ROUTE}/page`;
  }
});

// ../../node_modules/.pnpm/next@16.0.1_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/shared/lib/constants.js
var require_constants2 = __commonJS2({
  "../../node_modules/.pnpm/next@16.0.1_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/shared/lib/constants.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports2, {
      APP_CLIENT_INTERNALS: function() {
        return APP_CLIENT_INTERNALS;
      },
      APP_PATHS_MANIFEST: function() {
        return APP_PATHS_MANIFEST;
      },
      APP_PATH_ROUTES_MANIFEST: function() {
        return APP_PATH_ROUTES_MANIFEST;
      },
      AdapterOutputType: function() {
        return AdapterOutputType2;
      },
      BARREL_OPTIMIZATION_PREFIX: function() {
        return BARREL_OPTIMIZATION_PREFIX;
      },
      BLOCKED_PAGES: function() {
        return BLOCKED_PAGES;
      },
      BUILD_ID_FILE: function() {
        return BUILD_ID_FILE;
      },
      BUILD_MANIFEST: function() {
        return BUILD_MANIFEST;
      },
      CLIENT_PUBLIC_FILES_PATH: function() {
        return CLIENT_PUBLIC_FILES_PATH;
      },
      CLIENT_REFERENCE_MANIFEST: function() {
        return CLIENT_REFERENCE_MANIFEST;
      },
      CLIENT_STATIC_FILES_PATH: function() {
        return CLIENT_STATIC_FILES_PATH;
      },
      CLIENT_STATIC_FILES_RUNTIME_MAIN: function() {
        return CLIENT_STATIC_FILES_RUNTIME_MAIN;
      },
      CLIENT_STATIC_FILES_RUNTIME_MAIN_APP: function() {
        return CLIENT_STATIC_FILES_RUNTIME_MAIN_APP;
      },
      CLIENT_STATIC_FILES_RUNTIME_POLYFILLS: function() {
        return CLIENT_STATIC_FILES_RUNTIME_POLYFILLS;
      },
      CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL: function() {
        return CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL;
      },
      CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH: function() {
        return CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH;
      },
      CLIENT_STATIC_FILES_RUNTIME_WEBPACK: function() {
        return CLIENT_STATIC_FILES_RUNTIME_WEBPACK;
      },
      COMPILER_INDEXES: function() {
        return COMPILER_INDEXES;
      },
      COMPILER_NAMES: function() {
        return COMPILER_NAMES;
      },
      CONFIG_FILES: function() {
        return CONFIG_FILES;
      },
      DEFAULT_RUNTIME_WEBPACK: function() {
        return DEFAULT_RUNTIME_WEBPACK;
      },
      DEFAULT_SANS_SERIF_FONT: function() {
        return DEFAULT_SANS_SERIF_FONT;
      },
      DEFAULT_SERIF_FONT: function() {
        return DEFAULT_SERIF_FONT;
      },
      DEV_CLIENT_MIDDLEWARE_MANIFEST: function() {
        return DEV_CLIENT_MIDDLEWARE_MANIFEST;
      },
      DEV_CLIENT_PAGES_MANIFEST: function() {
        return DEV_CLIENT_PAGES_MANIFEST;
      },
      DYNAMIC_CSS_MANIFEST: function() {
        return DYNAMIC_CSS_MANIFEST;
      },
      EDGE_RUNTIME_WEBPACK: function() {
        return EDGE_RUNTIME_WEBPACK;
      },
      EDGE_UNSUPPORTED_NODE_APIS: function() {
        return EDGE_UNSUPPORTED_NODE_APIS;
      },
      EXPORT_DETAIL: function() {
        return EXPORT_DETAIL;
      },
      EXPORT_MARKER: function() {
        return EXPORT_MARKER;
      },
      FUNCTIONS_CONFIG_MANIFEST: function() {
        return FUNCTIONS_CONFIG_MANIFEST;
      },
      IMAGES_MANIFEST: function() {
        return IMAGES_MANIFEST;
      },
      INTERCEPTION_ROUTE_REWRITE_MANIFEST: function() {
        return INTERCEPTION_ROUTE_REWRITE_MANIFEST;
      },
      MIDDLEWARE_BUILD_MANIFEST: function() {
        return MIDDLEWARE_BUILD_MANIFEST;
      },
      MIDDLEWARE_MANIFEST: function() {
        return MIDDLEWARE_MANIFEST;
      },
      MIDDLEWARE_REACT_LOADABLE_MANIFEST: function() {
        return MIDDLEWARE_REACT_LOADABLE_MANIFEST;
      },
      MODERN_BROWSERSLIST_TARGET: function() {
        return _modernbrowserslisttarget.default;
      },
      NEXT_BUILTIN_DOCUMENT: function() {
        return NEXT_BUILTIN_DOCUMENT;
      },
      NEXT_FONT_MANIFEST: function() {
        return NEXT_FONT_MANIFEST;
      },
      PAGES_MANIFEST: function() {
        return PAGES_MANIFEST;
      },
      PHASE_DEVELOPMENT_SERVER: function() {
        return PHASE_DEVELOPMENT_SERVER;
      },
      PHASE_EXPORT: function() {
        return PHASE_EXPORT;
      },
      PHASE_INFO: function() {
        return PHASE_INFO;
      },
      PHASE_PRODUCTION_BUILD: function() {
        return PHASE_PRODUCTION_BUILD;
      },
      PHASE_PRODUCTION_SERVER: function() {
        return PHASE_PRODUCTION_SERVER;
      },
      PHASE_TEST: function() {
        return PHASE_TEST;
      },
      PRERENDER_MANIFEST: function() {
        return PRERENDER_MANIFEST;
      },
      REACT_LOADABLE_MANIFEST: function() {
        return REACT_LOADABLE_MANIFEST;
      },
      ROUTES_MANIFEST: function() {
        return ROUTES_MANIFEST;
      },
      RSC_MODULE_TYPES: function() {
        return RSC_MODULE_TYPES;
      },
      SERVER_DIRECTORY: function() {
        return SERVER_DIRECTORY;
      },
      SERVER_FILES_MANIFEST: function() {
        return SERVER_FILES_MANIFEST;
      },
      SERVER_PROPS_ID: function() {
        return SERVER_PROPS_ID;
      },
      SERVER_REFERENCE_MANIFEST: function() {
        return SERVER_REFERENCE_MANIFEST;
      },
      STATIC_PROPS_ID: function() {
        return STATIC_PROPS_ID;
      },
      STATIC_STATUS_PAGES: function() {
        return STATIC_STATUS_PAGES;
      },
      STRING_LITERAL_DROP_BUNDLE: function() {
        return STRING_LITERAL_DROP_BUNDLE;
      },
      SUBRESOURCE_INTEGRITY_MANIFEST: function() {
        return SUBRESOURCE_INTEGRITY_MANIFEST;
      },
      SYSTEM_ENTRYPOINTS: function() {
        return SYSTEM_ENTRYPOINTS;
      },
      TRACE_OUTPUT_VERSION: function() {
        return TRACE_OUTPUT_VERSION;
      },
      TURBOPACK_CLIENT_BUILD_MANIFEST: function() {
        return TURBOPACK_CLIENT_BUILD_MANIFEST;
      },
      TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST: function() {
        return TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST;
      },
      TURBO_TRACE_DEFAULT_MEMORY_LIMIT: function() {
        return TURBO_TRACE_DEFAULT_MEMORY_LIMIT;
      },
      UNDERSCORE_GLOBAL_ERROR_ROUTE: function() {
        return _entryconstants.UNDERSCORE_GLOBAL_ERROR_ROUTE;
      },
      UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY: function() {
        return _entryconstants.UNDERSCORE_GLOBAL_ERROR_ROUTE_ENTRY;
      },
      UNDERSCORE_NOT_FOUND_ROUTE: function() {
        return _entryconstants.UNDERSCORE_NOT_FOUND_ROUTE;
      },
      UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: function() {
        return _entryconstants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;
      },
      WEBPACK_STATS: function() {
        return WEBPACK_STATS;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _modernbrowserslisttarget = /* @__PURE__ */ _interop_require_default._(require_modern_browserslist_target());
    var _entryconstants = require_entry_constants();
    var COMPILER_NAMES = {
      client: "client",
      server: "server",
      edgeServer: "edge-server"
    };
    var COMPILER_INDEXES = {
      [COMPILER_NAMES.client]: 0,
      [COMPILER_NAMES.server]: 1,
      [COMPILER_NAMES.edgeServer]: 2
    };
    var AdapterOutputType2 = /* @__PURE__ */ (function(AdapterOutputType3) {
      AdapterOutputType3["PAGES"] = "PAGES";
      AdapterOutputType3["PAGES_API"] = "PAGES_API";
      AdapterOutputType3["APP_PAGE"] = "APP_PAGE";
      AdapterOutputType3["APP_ROUTE"] = "APP_ROUTE";
      AdapterOutputType3["PRERENDER"] = "PRERENDER";
      AdapterOutputType3["STATIC_FILE"] = "STATIC_FILE";
      AdapterOutputType3["MIDDLEWARE"] = "MIDDLEWARE";
      return AdapterOutputType3;
    })({});
    var PHASE_EXPORT = "phase-export";
    var PHASE_PRODUCTION_BUILD = "phase-production-build";
    var PHASE_PRODUCTION_SERVER = "phase-production-server";
    var PHASE_DEVELOPMENT_SERVER = "phase-development-server";
    var PHASE_TEST = "phase-test";
    var PHASE_INFO = "phase-info";
    var PAGES_MANIFEST = "pages-manifest.json";
    var WEBPACK_STATS = "webpack-stats.json";
    var APP_PATHS_MANIFEST = "app-paths-manifest.json";
    var APP_PATH_ROUTES_MANIFEST = "app-path-routes-manifest.json";
    var BUILD_MANIFEST = "build-manifest.json";
    var FUNCTIONS_CONFIG_MANIFEST = "functions-config-manifest.json";
    var SUBRESOURCE_INTEGRITY_MANIFEST = "subresource-integrity-manifest";
    var NEXT_FONT_MANIFEST = "next-font-manifest";
    var EXPORT_MARKER = "export-marker.json";
    var EXPORT_DETAIL = "export-detail.json";
    var PRERENDER_MANIFEST = "prerender-manifest.json";
    var ROUTES_MANIFEST = "routes-manifest.json";
    var IMAGES_MANIFEST = "images-manifest.json";
    var SERVER_FILES_MANIFEST = "required-server-files.json";
    var DEV_CLIENT_PAGES_MANIFEST = "_devPagesManifest.json";
    var MIDDLEWARE_MANIFEST = "middleware-manifest.json";
    var TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST = "_clientMiddlewareManifest.json";
    var TURBOPACK_CLIENT_BUILD_MANIFEST = "client-build-manifest.json";
    var DEV_CLIENT_MIDDLEWARE_MANIFEST = "_devMiddlewareManifest.json";
    var REACT_LOADABLE_MANIFEST = "react-loadable-manifest.json";
    var SERVER_DIRECTORY = "server";
    var CONFIG_FILES = [
      "next.config.js",
      "next.config.mjs",
      "next.config.ts",
      // process.features can be undefined on Edge runtime
      // TODO: Remove `as any` once we bump @types/node to v22.10.0+
      ...process?.features?.typescript ? [
        "next.config.mts"
      ] : []
    ];
    var BUILD_ID_FILE = "BUILD_ID";
    var BLOCKED_PAGES = [
      "/_document",
      "/_app",
      "/_error"
    ];
    var CLIENT_PUBLIC_FILES_PATH = "public";
    var CLIENT_STATIC_FILES_PATH = "static";
    var STRING_LITERAL_DROP_BUNDLE = "__NEXT_DROP_CLIENT_FILE__";
    var NEXT_BUILTIN_DOCUMENT = "__NEXT_BUILTIN_DOCUMENT__";
    var BARREL_OPTIMIZATION_PREFIX = "__barrel_optimize__";
    var CLIENT_REFERENCE_MANIFEST = "client-reference-manifest";
    var SERVER_REFERENCE_MANIFEST = "server-reference-manifest";
    var MIDDLEWARE_BUILD_MANIFEST = "middleware-build-manifest";
    var MIDDLEWARE_REACT_LOADABLE_MANIFEST = "middleware-react-loadable-manifest";
    var INTERCEPTION_ROUTE_REWRITE_MANIFEST = "interception-route-rewrite-manifest";
    var DYNAMIC_CSS_MANIFEST = "dynamic-css-manifest";
    var CLIENT_STATIC_FILES_RUNTIME_MAIN = `main`;
    var CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = `${CLIENT_STATIC_FILES_RUNTIME_MAIN}-app`;
    var APP_CLIENT_INTERNALS = "app-pages-internals";
    var CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = `react-refresh`;
    var CLIENT_STATIC_FILES_RUNTIME_WEBPACK = `webpack`;
    var CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = "polyfills";
    var CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(CLIENT_STATIC_FILES_RUNTIME_POLYFILLS);
    var DEFAULT_RUNTIME_WEBPACK = "webpack-runtime";
    var EDGE_RUNTIME_WEBPACK = "edge-runtime-webpack";
    var STATIC_PROPS_ID = "__N_SSG";
    var SERVER_PROPS_ID = "__N_SSP";
    var DEFAULT_SERIF_FONT = {
      name: "Times New Roman",
      xAvgCharWidth: 821,
      azAvgWidth: 854.3953488372093,
      unitsPerEm: 2048
    };
    var DEFAULT_SANS_SERIF_FONT = {
      name: "Arial",
      xAvgCharWidth: 904,
      azAvgWidth: 934.5116279069767,
      unitsPerEm: 2048
    };
    var STATIC_STATUS_PAGES = [
      "/500"
    ];
    var TRACE_OUTPUT_VERSION = 1;
    var TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6e3;
    var RSC_MODULE_TYPES = {
      client: "client",
      server: "server"
    };
    var EDGE_UNSUPPORTED_NODE_APIS = [
      "clearImmediate",
      "setImmediate",
      "BroadcastChannel",
      "ByteLengthQueuingStrategy",
      "CompressionStream",
      "CountQueuingStrategy",
      "DecompressionStream",
      "DomException",
      "MessageChannel",
      "MessageEvent",
      "MessagePort",
      "ReadableByteStreamController",
      "ReadableStreamBYOBRequest",
      "ReadableStreamDefaultController",
      "TransformStreamDefaultController",
      "WritableStreamDefaultController"
    ];
    var SYSTEM_ENTRYPOINTS = /* @__PURE__ */ new Set([
      CLIENT_STATIC_FILES_RUNTIME_MAIN,
      CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,
      CLIENT_STATIC_FILES_RUNTIME_MAIN_APP
    ]);
    if ((typeof exports2.default === "function" || typeof exports2.default === "object" && exports2.default !== null) && typeof exports2.default.__esModule === "undefined") {
      Object.defineProperty(exports2.default, "__esModule", { value: true });
      Object.assign(exports2.default, exports2);
      module2.exports = exports2.default;
    }
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/Source.js
var require_Source = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/Source.js"(exports2, module2) {
    "use strict";
    var Source = class {
      source() {
        throw new Error("Abstract");
      }
      buffer() {
        const source = this.source();
        if (Buffer.isBuffer(source)) return source;
        return Buffer.from(source, "utf-8");
      }
      size() {
        return this.buffer().length;
      }
      map(options) {
        return null;
      }
      sourceAndMap(options) {
        return {
          source: this.source(),
          map: this.map(options)
        };
      }
      updateHash(hash) {
        throw new Error("Abstract");
      }
    };
    module2.exports = Source;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js
var require_getGeneratedSourceInfo = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js"(exports2, module2) {
    "use strict";
    var CHAR_CODE_NEW_LINE = "\n".charCodeAt(0);
    var getGeneratedSourceInfo = (source) => {
      if (source === void 0) {
        return {};
      }
      const lastLineStart = source.lastIndexOf("\n");
      if (lastLineStart === -1) {
        return {
          generatedLine: 1,
          generatedColumn: source.length,
          source
        };
      }
      let generatedLine = 2;
      for (let i = 0; i < lastLineStart; i++) {
        if (source.charCodeAt(i) === CHAR_CODE_NEW_LINE) generatedLine++;
      }
      return {
        generatedLine,
        generatedColumn: source.length - lastLineStart - 1,
        source
      };
    };
    module2.exports = getGeneratedSourceInfo;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoLines.js
var require_splitIntoLines = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoLines.js"(exports2, module2) {
    var splitIntoLines = (str) => {
      const results = [];
      const len = str.length;
      let i = 0;
      for (; i < len; ) {
        const cc = str.charCodeAt(i);
        if (cc === 10) {
          results.push("\n");
          i++;
        } else {
          let j = i + 1;
          while (j < len && str.charCodeAt(j) !== 10) j++;
          results.push(str.slice(i, j + 1));
          i = j + 1;
        }
      }
      return results;
    };
    module2.exports = splitIntoLines;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js
var require_streamChunksOfRawSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js"(exports2, module2) {
    "use strict";
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfRawSource = (source, onChunk, onSource, onName) => {
      let line = 1;
      const matches = splitIntoLines(source);
      let match;
      for (match of matches) {
        onChunk(match, line, 0, -1, -1, -1, -1);
        line++;
      }
      return matches.length === 0 || match.endsWith("\n") ? {
        generatedLine: matches.length + 1,
        generatedColumn: 0
      } : {
        generatedLine: matches.length,
        generatedColumn: match.length
      };
    };
    module2.exports = (source, onChunk, onSource, onName, finalSource) => {
      return finalSource ? getGeneratedSourceInfo(source) : streamChunksOfRawSource(source, onChunk, onSource, onName);
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/RawSource.js
var require_RawSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/RawSource.js"(exports2, module2) {
    "use strict";
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var Source = require_Source();
    var RawSource = class extends Source {
      constructor(value, convertToString = false) {
        super();
        const isBuffer = Buffer.isBuffer(value);
        if (!isBuffer && typeof value !== "string") {
          throw new TypeError("argument 'value' must be either string of Buffer");
        }
        this._valueIsBuffer = !convertToString && isBuffer;
        this._value = convertToString && isBuffer ? void 0 : value;
        this._valueAsBuffer = isBuffer ? value : void 0;
        this._valueAsString = isBuffer ? void 0 : value;
      }
      isBuffer() {
        return this._valueIsBuffer;
      }
      source() {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        return this._value;
      }
      buffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        return this._valueAsBuffer;
      }
      map(options) {
        return null;
      }
      /**
       * @param {object} options options
       * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
       * @param {function(number, string, string)} onSource called for each source
       * @param {function(number, string)} onName called for each name
       * @returns {void}
       */
      streamChunks(options, onChunk, onSource, onName) {
        if (this._value === void 0) {
          this._value = Buffer.from(this._valueAsBuffer, "utf-8");
        }
        if (this._valueAsString === void 0) {
          this._valueAsString = typeof this._value === "string" ? this._value : this._value.toString("utf-8");
        }
        return streamChunksOfRawSource(
          this._valueAsString,
          onChunk,
          onSource,
          onName,
          !!(options && options.finalSource)
        );
      }
      updateHash(hash) {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        hash.update("RawSource");
        hash.update(this._valueAsBuffer);
      }
    };
    module2.exports = RawSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js
var require_createMappingsSerializer = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js"(exports2, module2) {
    "use strict";
    var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      ""
    );
    var CONTINUATION_BIT = 32;
    var createMappingsSerializer = (options) => {
      const linesOnly = options && options.columns === false;
      return linesOnly ? createLinesOnlyMappingsSerializer() : createFullMappingsSerializer();
    };
    var createFullMappingsSerializer = () => {
      let currentLine = 1;
      let currentColumn = 0;
      let currentSourceIndex = 0;
      let currentOriginalLine = 1;
      let currentOriginalColumn = 0;
      let currentNameIndex = 0;
      let activeMapping = false;
      let activeName = false;
      let initial = true;
      return (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (activeMapping && currentLine === generatedLine) {
          if (sourceIndex === currentSourceIndex && originalLine === currentOriginalLine && originalColumn === currentOriginalColumn && !activeName && nameIndex < 0) {
            return "";
          }
        } else {
          if (sourceIndex < 0) {
            return "";
          }
        }
        let str;
        if (currentLine < generatedLine) {
          str = ";".repeat(generatedLine - currentLine);
          currentLine = generatedLine;
          currentColumn = 0;
          initial = false;
        } else if (initial) {
          str = "";
          initial = false;
        } else {
          str = ",";
        }
        const writeValue = (value) => {
          const sign = value >>> 31 & 1;
          const mask = value >> 31;
          const absValue = value + mask ^ mask;
          let data = absValue << 1 | sign;
          for (; ; ) {
            const sextet = data & 31;
            data >>= 5;
            if (data === 0) {
              str += ALPHABET[sextet];
              break;
            } else {
              str += ALPHABET[sextet | CONTINUATION_BIT];
            }
          }
        };
        writeValue(generatedColumn - currentColumn);
        currentColumn = generatedColumn;
        if (sourceIndex >= 0) {
          activeMapping = true;
          if (sourceIndex === currentSourceIndex) {
            str += "A";
          } else {
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
          }
          writeValue(originalLine - currentOriginalLine);
          currentOriginalLine = originalLine;
          if (originalColumn === currentOriginalColumn) {
            str += "A";
          } else {
            writeValue(originalColumn - currentOriginalColumn);
            currentOriginalColumn = originalColumn;
          }
          if (nameIndex >= 0) {
            writeValue(nameIndex - currentNameIndex);
            currentNameIndex = nameIndex;
            activeName = true;
          } else {
            activeName = false;
          }
        } else {
          activeMapping = false;
        }
        return str;
      };
    };
    var createLinesOnlyMappingsSerializer = () => {
      let lastWrittenLine = 0;
      let currentLine = 1;
      let currentSourceIndex = 0;
      let currentOriginalLine = 1;
      return (generatedLine, _generatedColumn, sourceIndex, originalLine, _originalColumn, _nameIndex) => {
        if (sourceIndex < 0) {
          return "";
        }
        if (lastWrittenLine === generatedLine) {
          return "";
        }
        let str;
        const writeValue = (value) => {
          const sign = value >>> 31 & 1;
          const mask = value >> 31;
          const absValue = value + mask ^ mask;
          let data = absValue << 1 | sign;
          for (; ; ) {
            const sextet = data & 31;
            data >>= 5;
            if (data === 0) {
              str += ALPHABET[sextet];
              break;
            } else {
              str += ALPHABET[sextet | CONTINUATION_BIT];
            }
          }
        };
        lastWrittenLine = generatedLine;
        if (generatedLine === currentLine + 1) {
          currentLine = generatedLine;
          if (sourceIndex === currentSourceIndex) {
            currentSourceIndex = sourceIndex;
            if (originalLine === currentOriginalLine + 1) {
              currentOriginalLine = originalLine;
              return ";AACA";
            } else {
              str = ";AA";
              writeValue(originalLine - currentOriginalLine);
              currentOriginalLine = originalLine;
              return str + "A";
            }
          } else {
            str = ";A";
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
            writeValue(originalLine - currentOriginalLine);
            currentOriginalLine = originalLine;
            return str + "A";
          }
        } else {
          str = ";".repeat(generatedLine - currentLine);
          currentLine = generatedLine;
          if (sourceIndex === currentSourceIndex) {
            currentSourceIndex = sourceIndex;
            if (originalLine === currentOriginalLine + 1) {
              currentOriginalLine = originalLine;
              return str + "AACA";
            } else {
              str += "AA";
              writeValue(originalLine - currentOriginalLine);
              currentOriginalLine = originalLine;
              return str + "A";
            }
          } else {
            str += "A";
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
            writeValue(originalLine - currentOriginalLine);
            currentOriginalLine = originalLine;
            return str + "A";
          }
        }
      };
    };
    module2.exports = createMappingsSerializer;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js
var require_getFromStreamChunks = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js"(exports2) {
    "use strict";
    var createMappingsSerializer = require_createMappingsSerializer();
    exports2.getSourceAndMap = (inputSource, options) => {
      let code = "";
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(options);
      const { source } = inputSource.streamChunks(
        Object.assign({}, options, { finalSource: true }),
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (chunk !== void 0) code += chunk;
          mappings += addMapping(
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
        }
      );
      return {
        source: source !== void 0 ? source : code,
        map: mappings.length > 0 ? {
          version: 3,
          file: "x",
          mappings,
          sources,
          sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
          names
        } : null
      };
    };
    exports2.getMap = (source, options) => {
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(options);
      source.streamChunks(
        Object.assign({}, options, { source: false, finalSource: true }),
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          mappings += addMapping(
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
        }
      );
      return mappings.length > 0 ? {
        version: 3,
        file: "x",
        mappings,
        sources,
        sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
        names
      } : null;
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js
var require_splitIntoPotentialTokens = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js"(exports2, module2) {
    var splitIntoPotentialTokens = (str) => {
      const len = str.length;
      if (len === 0) return null;
      const results = [];
      let i = 0;
      for (; i < len; ) {
        const s = i;
        block: {
          let cc = str.charCodeAt(i);
          while (cc !== 10 && cc !== 59 && cc !== 123 && cc !== 125) {
            if (++i >= len) break block;
            cc = str.charCodeAt(i);
          }
          while (cc === 59 || cc === 32 || cc === 123 || cc === 125 || cc === 13 || cc === 9) {
            if (++i >= len) break block;
            cc = str.charCodeAt(i);
          }
          if (cc === 10) {
            i++;
          }
        }
        results.push(str.slice(s, i));
      }
      return results;
    };
    module2.exports = splitIntoPotentialTokens;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/OriginalSource.js
var require_OriginalSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/OriginalSource.js"(exports2, module2) {
    "use strict";
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var splitIntoLines = require_splitIntoLines();
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var Source = require_Source();
    var splitIntoPotentialTokens = require_splitIntoPotentialTokens();
    var OriginalSource2 = class extends Source {
      constructor(value, name) {
        super();
        const isBuffer = Buffer.isBuffer(value);
        this._value = isBuffer ? void 0 : value;
        this._valueAsBuffer = isBuffer ? value : void 0;
        this._name = name;
      }
      getName() {
        return this._name;
      }
      source() {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        return this._value;
      }
      buffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        return this._valueAsBuffer;
      }
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      /**
       * @param {object} options options
       * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
       * @param {function(number, string, string)} onSource called for each source
       * @param {function(number, string)} onName called for each name
       * @returns {void}
       */
      streamChunks(options, onChunk, onSource, onName) {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        onSource(0, this._name, this._value);
        const finalSource = !!(options && options.finalSource);
        if (!options || options.columns !== false) {
          const matches = splitIntoPotentialTokens(this._value);
          let line = 1;
          let column = 0;
          if (matches !== null) {
            for (const match of matches) {
              const isEndOfLine = match.endsWith("\n");
              if (isEndOfLine && match.length === 1) {
                if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);
              } else {
                const chunk = finalSource ? void 0 : match;
                onChunk(chunk, line, column, 0, line, column, -1);
              }
              if (isEndOfLine) {
                line++;
                column = 0;
              } else {
                column += match.length;
              }
            }
          }
          return {
            generatedLine: line,
            generatedColumn: column,
            source: finalSource ? this._value : void 0
          };
        } else if (finalSource) {
          const result = getGeneratedSourceInfo(this._value);
          const { generatedLine, generatedColumn } = result;
          if (generatedColumn === 0) {
            for (let line = 1; line < generatedLine; line++)
              onChunk(void 0, line, 0, 0, line, 0, -1);
          } else {
            for (let line = 1; line <= generatedLine; line++)
              onChunk(void 0, line, 0, 0, line, 0, -1);
          }
          return result;
        } else {
          let line = 1;
          const matches = splitIntoLines(this._value);
          let match;
          for (match of matches) {
            onChunk(finalSource ? void 0 : match, line, 0, 0, line, 0, -1);
            line++;
          }
          return matches.length === 0 || match.endsWith("\n") ? {
            generatedLine: matches.length + 1,
            generatedColumn: 0,
            source: finalSource ? this._value : void 0
          } : {
            generatedLine: matches.length,
            generatedColumn: match.length,
            source: finalSource ? this._value : void 0
          };
        }
      }
      updateHash(hash) {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        hash.update("OriginalSource");
        hash.update(this._valueAsBuffer);
        hash.update(this._name || "");
      }
    };
    module2.exports = OriginalSource2;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getSource.js
var require_getSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getSource.js"(exports2, module2) {
    "use strict";
    var getSource = (sourceMap, index) => {
      if (index < 0) return null;
      const { sourceRoot, sources } = sourceMap;
      const source = sources[index];
      if (!sourceRoot) return source;
      if (sourceRoot.endsWith("/")) return sourceRoot + source;
      return sourceRoot + "/" + source;
    };
    module2.exports = getSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/readMappings.js
var require_readMappings = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/readMappings.js"(exports2, module2) {
    "use strict";
    var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var CONTINUATION_BIT = 32;
    var END_SEGMENT_BIT = 64;
    var NEXT_LINE = END_SEGMENT_BIT | 1;
    var INVALID = END_SEGMENT_BIT | 2;
    var DATA_MASK = 31;
    var ccToValue = new Uint8Array("z".charCodeAt(0) + 1);
    {
      ccToValue.fill(INVALID);
      for (let i = 0; i < ALPHABET.length; i++) {
        ccToValue[ALPHABET.charCodeAt(i)] = i;
      }
      ccToValue[",".charCodeAt(0)] = END_SEGMENT_BIT;
      ccToValue[";".charCodeAt(0)] = NEXT_LINE;
    }
    var ccMax = ccToValue.length - 1;
    var readMappings = (mappings, onMapping) => {
      const currentData = new Uint32Array([0, 0, 1, 0, 0]);
      let currentDataPos = 0;
      let currentValue = 0;
      let currentValuePos = 0;
      let generatedLine = 1;
      let generatedColumn = -1;
      for (let i = 0; i < mappings.length; i++) {
        const cc = mappings.charCodeAt(i);
        if (cc > ccMax) continue;
        const value = ccToValue[cc];
        if ((value & END_SEGMENT_BIT) !== 0) {
          if (currentData[0] > generatedColumn) {
            if (currentDataPos === 1) {
              onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
            } else if (currentDataPos === 4) {
              onMapping(
                generatedLine,
                currentData[0],
                currentData[1],
                currentData[2],
                currentData[3],
                -1
              );
            } else if (currentDataPos === 5) {
              onMapping(
                generatedLine,
                currentData[0],
                currentData[1],
                currentData[2],
                currentData[3],
                currentData[4]
              );
            }
            generatedColumn = currentData[0];
          }
          currentDataPos = 0;
          if (value === NEXT_LINE) {
            generatedLine++;
            currentData[0] = 0;
            generatedColumn = -1;
          }
        } else if ((value & CONTINUATION_BIT) === 0) {
          currentValue |= value << currentValuePos;
          const finalValue = currentValue & 1 ? -(currentValue >> 1) : currentValue >> 1;
          currentData[currentDataPos++] += finalValue;
          currentValuePos = 0;
          currentValue = 0;
        } else {
          currentValue |= (value & DATA_MASK) << currentValuePos;
          currentValuePos += 5;
        }
      }
      if (currentDataPos === 1) {
        onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
      } else if (currentDataPos === 4) {
        onMapping(
          generatedLine,
          currentData[0],
          currentData[1],
          currentData[2],
          currentData[3],
          -1
        );
      } else if (currentDataPos === 5) {
        onMapping(
          generatedLine,
          currentData[0],
          currentData[1],
          currentData[2],
          currentData[3],
          currentData[4]
        );
      }
    };
    module2.exports = readMappings;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js
var require_streamChunksOfSourceMap = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"(exports2, module2) {
    "use strict";
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var getSource = require_getSource();
    var readMappings = require_readMappings();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfSourceMapFull = (source, sourceMap, onChunk, onSource, onName) => {
      const lines = splitIntoLines(source);
      if (lines.length === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, names, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      if (names) {
        for (let i = 0; i < names.length; i++) {
          onName(i, names[i]);
        }
      }
      const lastLine = lines[lines.length - 1];
      const lastNewLine = lastLine.endsWith("\n");
      const finalLine = lastNewLine ? lines.length + 1 : lines.length;
      const finalColumn = lastNewLine ? 0 : lastLine.length;
      let currentGeneratedLine = 1;
      let currentGeneratedColumn = 0;
      let mappingActive = false;
      let activeMappingSourceIndex = -1;
      let activeMappingOriginalLine = -1;
      let activeMappingOriginalColumn = -1;
      let activeMappingNameIndex = -1;
      const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (mappingActive && currentGeneratedLine <= lines.length) {
          let chunk;
          const mappingLine = currentGeneratedLine;
          const mappingColumn = currentGeneratedColumn;
          const line = lines[currentGeneratedLine - 1];
          if (generatedLine !== currentGeneratedLine) {
            chunk = line.slice(currentGeneratedColumn);
            currentGeneratedLine++;
            currentGeneratedColumn = 0;
          } else {
            chunk = line.slice(currentGeneratedColumn, generatedColumn);
            currentGeneratedColumn = generatedColumn;
          }
          if (chunk) {
            onChunk(
              chunk,
              mappingLine,
              mappingColumn,
              activeMappingSourceIndex,
              activeMappingOriginalLine,
              activeMappingOriginalColumn,
              activeMappingNameIndex
            );
          }
          mappingActive = false;
        }
        if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {
          if (currentGeneratedLine <= lines.length) {
            const chunk = lines[currentGeneratedLine - 1].slice(
              currentGeneratedColumn
            );
            onChunk(
              chunk,
              currentGeneratedLine,
              currentGeneratedColumn,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
          currentGeneratedColumn = 0;
        }
        while (generatedLine > currentGeneratedLine) {
          if (currentGeneratedLine <= lines.length) {
            onChunk(
              lines[currentGeneratedLine - 1],
              currentGeneratedLine,
              0,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
        }
        if (generatedColumn > currentGeneratedColumn) {
          if (currentGeneratedLine <= lines.length) {
            const chunk = lines[currentGeneratedLine - 1].slice(
              currentGeneratedColumn,
              generatedColumn
            );
            onChunk(
              chunk,
              currentGeneratedLine,
              currentGeneratedColumn,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedColumn = generatedColumn;
        }
        if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {
          mappingActive = true;
          activeMappingSourceIndex = sourceIndex;
          activeMappingOriginalLine = originalLine;
          activeMappingOriginalColumn = originalColumn;
          activeMappingNameIndex = nameIndex;
        }
      };
      readMappings(mappings, onMapping);
      onMapping(finalLine, finalColumn, -1, -1, -1, -1);
      return {
        generatedLine: finalLine,
        generatedColumn: finalColumn
      };
    };
    var streamChunksOfSourceMapLinesFull = (source, sourceMap, onChunk, onSource, _onName) => {
      const lines = splitIntoLines(source);
      if (lines.length === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      let currentGeneratedLine = 1;
      const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
        if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {
          return;
        }
        while (generatedLine > currentGeneratedLine) {
          if (currentGeneratedLine <= lines.length) {
            onChunk(
              lines[currentGeneratedLine - 1],
              currentGeneratedLine,
              0,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
        }
        if (generatedLine <= lines.length) {
          onChunk(
            lines[generatedLine - 1],
            generatedLine,
            0,
            sourceIndex,
            originalLine,
            originalColumn,
            -1
          );
          currentGeneratedLine++;
        }
      };
      readMappings(mappings, onMapping);
      for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {
        onChunk(
          lines[currentGeneratedLine - 1],
          currentGeneratedLine,
          0,
          -1,
          -1,
          -1,
          -1
        );
      }
      const lastLine = lines[lines.length - 1];
      const lastNewLine = lastLine.endsWith("\n");
      const finalLine = lastNewLine ? lines.length + 1 : lines.length;
      const finalColumn = lastNewLine ? 0 : lastLine.length;
      return {
        generatedLine: finalLine,
        generatedColumn: finalColumn
      };
    };
    var streamChunksOfSourceMapFinal = (source, sourceMap, onChunk, onSource, onName) => {
      const result = getGeneratedSourceInfo(source);
      const { generatedLine: finalLine, generatedColumn: finalColumn } = result;
      if (finalLine === 1 && finalColumn === 0) return result;
      const { sources, sourcesContent, names, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      if (names) {
        for (let i = 0; i < names.length; i++) {
          onName(i, names[i]);
        }
      }
      let mappingActiveLine = 0;
      const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {
          return;
        }
        if (sourceIndex >= 0) {
          onChunk(
            void 0,
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
          mappingActiveLine = generatedLine;
        } else if (mappingActiveLine === generatedLine) {
          onChunk(void 0, generatedLine, generatedColumn, -1, -1, -1, -1);
          mappingActiveLine = 0;
        }
      };
      readMappings(mappings, onMapping);
      return result;
    };
    var streamChunksOfSourceMapLinesFinal = (source, sourceMap, onChunk, onSource, _onName) => {
      const result = getGeneratedSourceInfo(source);
      const { generatedLine, generatedColumn } = result;
      if (generatedLine === 1 && generatedColumn === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;
      let currentGeneratedLine = 1;
      const onMapping = (generatedLine2, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
        if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine2 && generatedLine2 <= finalLine) {
          onChunk(
            void 0,
            generatedLine2,
            0,
            sourceIndex,
            originalLine,
            originalColumn,
            -1
          );
          currentGeneratedLine = generatedLine2 + 1;
        }
      };
      readMappings(mappings, onMapping);
      return result;
    };
    module2.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => {
      if (columns) {
        return finalSource ? streamChunksOfSourceMapFinal(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        ) : streamChunksOfSourceMapFull(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        );
      } else {
        return finalSource ? streamChunksOfSourceMapLinesFinal(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        ) : streamChunksOfSourceMapLinesFull(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js
var require_streamChunksOfCombinedSourceMap = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js"(exports2, module2) {
    "use strict";
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfCombinedSourceMap = (source, sourceMap, innerSourceName, innerSource, innerSourceMap, removeInnerSource, onChunk, onSource, onName, finalSource, columns) => {
      let sourceMapping = /* @__PURE__ */ new Map();
      let nameMapping = /* @__PURE__ */ new Map();
      const sourceIndexMapping = [];
      const nameIndexMapping = [];
      const nameIndexValueMapping = [];
      let innerSourceIndex = -2;
      const innerSourceIndexMapping = [];
      const innerSourceIndexValueMapping = [];
      const innerSourceContents = [];
      const innerSourceContentLines = [];
      const innerNameIndexMapping = [];
      const innerNameIndexValueMapping = [];
      const innerSourceMapLineData = [];
      const findInnerMapping = (line, column) => {
        if (line > innerSourceMapLineData.length) return -1;
        const { mappingsData } = innerSourceMapLineData[line - 1];
        let l = 0;
        let r = mappingsData.length / 5;
        while (l < r) {
          let m = l + r >> 1;
          if (mappingsData[m * 5] <= column) {
            l = m + 1;
          } else {
            r = m;
          }
        }
        if (l === 0) return -1;
        return l - 1;
      };
      return streamChunksOfSourceMap(
        source,
        sourceMap,
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (sourceIndex === innerSourceIndex) {
            const idx = findInnerMapping(originalLine, originalColumn);
            if (idx !== -1) {
              const { chunks, mappingsData } = innerSourceMapLineData[originalLine - 1];
              const mi = idx * 5;
              const innerSourceIndex2 = mappingsData[mi + 1];
              const innerOriginalLine = mappingsData[mi + 2];
              let innerOriginalColumn = mappingsData[mi + 3];
              let innerNameIndex = mappingsData[mi + 4];
              if (innerSourceIndex2 >= 0) {
                const innerChunk = chunks[idx];
                const innerGeneratedColumn = mappingsData[mi];
                const locationInChunk = originalColumn - innerGeneratedColumn;
                if (locationInChunk > 0) {
                  let originalSourceLines = innerSourceIndex2 < innerSourceContentLines.length ? innerSourceContentLines[innerSourceIndex2] : null;
                  if (originalSourceLines === void 0) {
                    const originalSource = innerSourceContents[innerSourceIndex2];
                    originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;
                    innerSourceContentLines[innerSourceIndex2] = originalSourceLines;
                  }
                  if (originalSourceLines !== null) {
                    const originalChunk = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(
                      innerOriginalColumn,
                      innerOriginalColumn + locationInChunk
                    ) : "";
                    if (innerChunk.slice(0, locationInChunk) === originalChunk) {
                      innerOriginalColumn += locationInChunk;
                      innerNameIndex = -1;
                    }
                  }
                }
                let sourceIndex2 = innerSourceIndex2 < innerSourceIndexMapping.length ? innerSourceIndexMapping[innerSourceIndex2] : -2;
                if (sourceIndex2 === -2) {
                  const [source2, sourceContent] = innerSourceIndex2 < innerSourceIndexValueMapping.length ? innerSourceIndexValueMapping[innerSourceIndex2] : [null, void 0];
                  let globalIndex = sourceMapping.get(source2);
                  if (globalIndex === void 0) {
                    sourceMapping.set(source2, globalIndex = sourceMapping.size);
                    onSource(globalIndex, source2, sourceContent);
                  }
                  sourceIndex2 = globalIndex;
                  innerSourceIndexMapping[innerSourceIndex2] = sourceIndex2;
                }
                let finalNameIndex = -1;
                if (innerNameIndex >= 0) {
                  finalNameIndex = innerNameIndex < innerNameIndexMapping.length ? innerNameIndexMapping[innerNameIndex] : -2;
                  if (finalNameIndex === -2) {
                    const name = innerNameIndex < innerNameIndexValueMapping.length ? innerNameIndexValueMapping[innerNameIndex] : void 0;
                    if (name) {
                      let globalIndex = nameMapping.get(name);
                      if (globalIndex === void 0) {
                        nameMapping.set(name, globalIndex = nameMapping.size);
                        onName(globalIndex, name);
                      }
                      finalNameIndex = globalIndex;
                    } else {
                      finalNameIndex = -1;
                    }
                    innerNameIndexMapping[innerNameIndex] = finalNameIndex;
                  }
                } else if (nameIndex >= 0) {
                  let originalSourceLines = innerSourceContentLines[innerSourceIndex2];
                  if (originalSourceLines === void 0) {
                    const originalSource = innerSourceContents[innerSourceIndex2];
                    originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;
                    innerSourceContentLines[innerSourceIndex2] = originalSourceLines;
                  }
                  if (originalSourceLines !== null) {
                    const name = nameIndexValueMapping[nameIndex];
                    const originalName = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(
                      innerOriginalColumn,
                      innerOriginalColumn + name.length
                    ) : "";
                    if (name === originalName) {
                      finalNameIndex = nameIndex < nameIndexMapping.length ? nameIndexMapping[nameIndex] : -2;
                      if (finalNameIndex === -2) {
                        const name2 = nameIndexValueMapping[nameIndex];
                        if (name2) {
                          let globalIndex = nameMapping.get(name2);
                          if (globalIndex === void 0) {
                            nameMapping.set(name2, globalIndex = nameMapping.size);
                            onName(globalIndex, name2);
                          }
                          finalNameIndex = globalIndex;
                        } else {
                          finalNameIndex = -1;
                        }
                        nameIndexMapping[nameIndex] = finalNameIndex;
                      }
                    }
                  }
                }
                onChunk(
                  chunk,
                  generatedLine,
                  generatedColumn,
                  sourceIndex2,
                  innerOriginalLine,
                  innerOriginalColumn,
                  finalNameIndex
                );
                return;
              }
            }
            if (removeInnerSource) {
              onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
              return;
            } else {
              if (sourceIndexMapping[sourceIndex] === -2) {
                let globalIndex = sourceMapping.get(innerSourceName);
                if (globalIndex === void 0) {
                  sourceMapping.set(source, globalIndex = sourceMapping.size);
                  onSource(globalIndex, innerSourceName, innerSource);
                }
                sourceIndexMapping[sourceIndex] = globalIndex;
              }
            }
          }
          const finalSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
          if (finalSourceIndex < 0) {
            onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
          } else {
            let finalNameIndex = -1;
            if (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {
              finalNameIndex = nameIndexMapping[nameIndex];
              if (finalNameIndex === -2) {
                const name = nameIndexValueMapping[nameIndex];
                let globalIndex = nameMapping.get(name);
                if (globalIndex === void 0) {
                  nameMapping.set(name, globalIndex = nameMapping.size);
                  onName(globalIndex, name);
                }
                finalNameIndex = globalIndex;
                nameIndexMapping[nameIndex] = finalNameIndex;
              }
            }
            onChunk(
              chunk,
              generatedLine,
              generatedColumn,
              finalSourceIndex,
              originalLine,
              originalColumn,
              finalNameIndex
            );
          }
        },
        (i, source2, sourceContent) => {
          if (source2 === innerSourceName) {
            innerSourceIndex = i;
            if (innerSource !== void 0) sourceContent = innerSource;
            else innerSource = sourceContent;
            sourceIndexMapping[i] = -2;
            streamChunksOfSourceMap(
              sourceContent,
              innerSourceMap,
              (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
                while (innerSourceMapLineData.length < generatedLine) {
                  innerSourceMapLineData.push({
                    mappingsData: [],
                    chunks: []
                  });
                }
                const data = innerSourceMapLineData[generatedLine - 1];
                data.mappingsData.push(
                  generatedColumn,
                  sourceIndex,
                  originalLine,
                  originalColumn,
                  nameIndex
                );
                data.chunks.push(chunk);
              },
              (i2, source3, sourceContent2) => {
                innerSourceContents[i2] = sourceContent2;
                innerSourceContentLines[i2] = void 0;
                innerSourceIndexMapping[i2] = -2;
                innerSourceIndexValueMapping[i2] = [source3, sourceContent2];
              },
              (i2, name) => {
                innerNameIndexMapping[i2] = -2;
                innerNameIndexValueMapping[i2] = name;
              },
              false,
              columns
            );
          } else {
            let globalIndex = sourceMapping.get(source2);
            if (globalIndex === void 0) {
              sourceMapping.set(source2, globalIndex = sourceMapping.size);
              onSource(globalIndex, source2, sourceContent);
            }
            sourceIndexMapping[i] = globalIndex;
          }
        },
        (i, name) => {
          nameIndexMapping[i] = -2;
          nameIndexValueMapping[i] = name;
        },
        finalSource,
        columns
      );
    };
    module2.exports = streamChunksOfCombinedSourceMap;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SourceMapSource.js
var require_SourceMapSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SourceMapSource.js"(exports2, module2) {
    "use strict";
    var Source = require_Source();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var streamChunksOfCombinedSourceMap = require_streamChunksOfCombinedSourceMap();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var SourceMapSource2 = class extends Source {
      constructor(value, name, sourceMap, originalSource, innerSourceMap, removeOriginalSource) {
        super();
        const valueIsBuffer = Buffer.isBuffer(value);
        this._valueAsString = valueIsBuffer ? void 0 : value;
        this._valueAsBuffer = valueIsBuffer ? value : void 0;
        this._name = name;
        this._hasSourceMap = !!sourceMap;
        const sourceMapIsBuffer = Buffer.isBuffer(sourceMap);
        const sourceMapIsString = typeof sourceMap === "string";
        this._sourceMapAsObject = sourceMapIsBuffer || sourceMapIsString ? void 0 : sourceMap;
        this._sourceMapAsString = sourceMapIsString ? sourceMap : void 0;
        this._sourceMapAsBuffer = sourceMapIsBuffer ? sourceMap : void 0;
        this._hasOriginalSource = !!originalSource;
        const originalSourceIsBuffer = Buffer.isBuffer(originalSource);
        this._originalSourceAsString = originalSourceIsBuffer ? void 0 : originalSource;
        this._originalSourceAsBuffer = originalSourceIsBuffer ? originalSource : void 0;
        this._hasInnerSourceMap = !!innerSourceMap;
        const innerSourceMapIsBuffer = Buffer.isBuffer(innerSourceMap);
        const innerSourceMapIsString = typeof innerSourceMap === "string";
        this._innerSourceMapAsObject = innerSourceMapIsBuffer || innerSourceMapIsString ? void 0 : innerSourceMap;
        this._innerSourceMapAsString = innerSourceMapIsString ? innerSourceMap : void 0;
        this._innerSourceMapAsBuffer = innerSourceMapIsBuffer ? innerSourceMap : void 0;
        this._removeOriginalSource = removeOriginalSource;
      }
      _ensureValueBuffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._valueAsString, "utf-8");
        }
      }
      _ensureValueString() {
        if (this._valueAsString === void 0) {
          this._valueAsString = this._valueAsBuffer.toString("utf-8");
        }
      }
      _ensureOriginalSourceBuffer() {
        if (this._originalSourceAsBuffer === void 0 && this._hasOriginalSource) {
          this._originalSourceAsBuffer = Buffer.from(
            this._originalSourceAsString,
            "utf-8"
          );
        }
      }
      _ensureOriginalSourceString() {
        if (this._originalSourceAsString === void 0 && this._hasOriginalSource) {
          this._originalSourceAsString = this._originalSourceAsBuffer.toString(
            "utf-8"
          );
        }
      }
      _ensureInnerSourceMapObject() {
        if (this._innerSourceMapAsObject === void 0 && this._hasInnerSourceMap) {
          this._ensureInnerSourceMapString();
          this._innerSourceMapAsObject = JSON.parse(this._innerSourceMapAsString);
        }
      }
      _ensureInnerSourceMapBuffer() {
        if (this._innerSourceMapAsBuffer === void 0 && this._hasInnerSourceMap) {
          this._ensureInnerSourceMapString();
          this._innerSourceMapAsBuffer = Buffer.from(
            this._innerSourceMapAsString,
            "utf-8"
          );
        }
      }
      _ensureInnerSourceMapString() {
        if (this._innerSourceMapAsString === void 0 && this._hasInnerSourceMap) {
          if (this._innerSourceMapAsBuffer !== void 0) {
            this._innerSourceMapAsString = this._innerSourceMapAsBuffer.toString(
              "utf-8"
            );
          } else {
            this._innerSourceMapAsString = JSON.stringify(
              this._innerSourceMapAsObject
            );
          }
        }
      }
      _ensureSourceMapObject() {
        if (this._sourceMapAsObject === void 0) {
          this._ensureSourceMapString();
          this._sourceMapAsObject = JSON.parse(this._sourceMapAsString);
        }
      }
      _ensureSourceMapBuffer() {
        if (this._sourceMapAsBuffer === void 0) {
          this._ensureSourceMapString();
          this._sourceMapAsBuffer = Buffer.from(this._sourceMapAsString, "utf-8");
        }
      }
      _ensureSourceMapString() {
        if (this._sourceMapAsString === void 0) {
          if (this._sourceMapAsBuffer !== void 0) {
            this._sourceMapAsString = this._sourceMapAsBuffer.toString("utf-8");
          } else {
            this._sourceMapAsString = JSON.stringify(this._sourceMapAsObject);
          }
        }
      }
      getArgsAsBuffers() {
        this._ensureValueBuffer();
        this._ensureSourceMapBuffer();
        this._ensureOriginalSourceBuffer();
        this._ensureInnerSourceMapBuffer();
        return [
          this._valueAsBuffer,
          this._name,
          this._sourceMapAsBuffer,
          this._originalSourceAsBuffer,
          this._innerSourceMapAsBuffer,
          this._removeOriginalSource
        ];
      }
      buffer() {
        this._ensureValueBuffer();
        return this._valueAsBuffer;
      }
      source() {
        this._ensureValueString();
        return this._valueAsString;
      }
      map(options) {
        if (!this._hasInnerSourceMap) {
          this._ensureSourceMapObject();
          return this._sourceMapAsObject;
        }
        return getMap(this, options);
      }
      sourceAndMap(options) {
        if (!this._hasInnerSourceMap) {
          this._ensureValueString();
          this._ensureSourceMapObject();
          return {
            source: this._valueAsString,
            map: this._sourceMapAsObject
          };
        }
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        this._ensureValueString();
        this._ensureSourceMapObject();
        this._ensureOriginalSourceString();
        if (this._hasInnerSourceMap) {
          this._ensureInnerSourceMapObject();
          return streamChunksOfCombinedSourceMap(
            this._valueAsString,
            this._sourceMapAsObject,
            this._name,
            this._originalSourceAsString,
            this._innerSourceMapAsObject,
            this._removeOriginalSource,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        } else {
          return streamChunksOfSourceMap(
            this._valueAsString,
            this._sourceMapAsObject,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        }
      }
      updateHash(hash) {
        this._ensureValueBuffer();
        this._ensureSourceMapBuffer();
        this._ensureOriginalSourceBuffer();
        this._ensureInnerSourceMapBuffer();
        hash.update("SourceMapSource");
        hash.update(this._valueAsBuffer);
        hash.update(this._sourceMapAsBuffer);
        if (this._hasOriginalSource) {
          hash.update(this._originalSourceAsBuffer);
        }
        if (this._hasInnerSourceMap) {
          hash.update(this._innerSourceMapAsBuffer);
        }
        hash.update(this._removeOriginalSource ? "true" : "false");
      }
    };
    module2.exports = SourceMapSource2;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunks.js
var require_streamChunks = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunks.js"(exports2, module2) {
    "use strict";
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    module2.exports = (source, options, onChunk, onSource, onName) => {
      if (typeof source.streamChunks === "function") {
        return source.streamChunks(options, onChunk, onSource, onName);
      } else {
        const sourceAndMap = source.sourceAndMap(options);
        if (sourceAndMap.map) {
          return streamChunksOfSourceMap(
            sourceAndMap.source,
            sourceAndMap.map,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        } else {
          return streamChunksOfRawSource(
            sourceAndMap.source,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource)
          );
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js
var require_streamAndGetSourceAndMap = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js"(exports2, module2) {
    "use strict";
    var createMappingsSerializer = require_createMappingsSerializer();
    var streamChunks = require_streamChunks();
    var streamAndGetSourceAndMap = (inputSource, options, onChunk, onSource, onName) => {
      let code = "";
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(
        Object.assign({}, options, { columns: true })
      );
      const finalSource = !!(options && options.finalSource);
      const { generatedLine, generatedColumn, source } = streamChunks(
        inputSource,
        options,
        (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (chunk !== void 0) code += chunk;
          mappings += addMapping(
            generatedLine2,
            generatedColumn2,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
          return onChunk(
            finalSource ? void 0 : chunk,
            generatedLine2,
            generatedColumn2,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
          return onSource(sourceIndex, source2, sourceContent);
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
          return onName(nameIndex, name);
        }
      );
      const resultSource = source !== void 0 ? source : code;
      return {
        result: {
          generatedLine,
          generatedColumn,
          source: finalSource ? resultSource : void 0
        },
        source: resultSource,
        map: mappings.length > 0 ? {
          version: 3,
          file: "x",
          mappings,
          sources,
          sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
          names
        } : null
      };
    };
    module2.exports = streamAndGetSourceAndMap;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CachedSource.js
var require_CachedSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CachedSource.js"(exports2, module2) {
    "use strict";
    var Source = require_Source();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var streamAndGetSourceAndMap = require_streamAndGetSourceAndMap();
    var mapToBufferedMap = (map) => {
      if (typeof map !== "object" || !map) return map;
      const bufferedMap = Object.assign({}, map);
      if (map.mappings) {
        bufferedMap.mappings = Buffer.from(map.mappings, "utf-8");
      }
      if (map.sourcesContent) {
        bufferedMap.sourcesContent = map.sourcesContent.map(
          (str) => str && Buffer.from(str, "utf-8")
        );
      }
      return bufferedMap;
    };
    var bufferedMapToMap = (bufferedMap) => {
      if (typeof bufferedMap !== "object" || !bufferedMap) return bufferedMap;
      const map = Object.assign({}, bufferedMap);
      if (bufferedMap.mappings) {
        map.mappings = bufferedMap.mappings.toString("utf-8");
      }
      if (bufferedMap.sourcesContent) {
        map.sourcesContent = bufferedMap.sourcesContent.map(
          (buffer) => buffer && buffer.toString("utf-8")
        );
      }
      return map;
    };
    var CachedSource = class extends Source {
      constructor(source, cachedData) {
        super();
        this._source = source;
        this._cachedSourceType = cachedData ? cachedData.source : void 0;
        this._cachedSource = void 0;
        this._cachedBuffer = cachedData ? cachedData.buffer : void 0;
        this._cachedSize = cachedData ? cachedData.size : void 0;
        this._cachedMaps = cachedData ? cachedData.maps : /* @__PURE__ */ new Map();
        this._cachedHashUpdate = cachedData ? cachedData.hash : void 0;
      }
      getCachedData() {
        const bufferedMaps = /* @__PURE__ */ new Map();
        for (const pair of this._cachedMaps) {
          let cacheEntry = pair[1];
          if (cacheEntry.bufferedMap === void 0) {
            cacheEntry.bufferedMap = mapToBufferedMap(
              this._getMapFromCacheEntry(cacheEntry)
            );
          }
          bufferedMaps.set(pair[0], {
            map: void 0,
            bufferedMap: cacheEntry.bufferedMap
          });
        }
        if (this._cachedSource) {
          this.buffer();
        }
        return {
          buffer: this._cachedBuffer,
          source: this._cachedSourceType !== void 0 ? this._cachedSourceType : typeof this._cachedSource === "string" ? true : Buffer.isBuffer(this._cachedSource) ? false : void 0,
          size: this._cachedSize,
          maps: bufferedMaps,
          hash: this._cachedHashUpdate
        };
      }
      originalLazy() {
        return this._source;
      }
      original() {
        if (typeof this._source === "function") this._source = this._source();
        return this._source;
      }
      source() {
        const source = this._getCachedSource();
        if (source !== void 0) return source;
        return this._cachedSource = this.original().source();
      }
      _getMapFromCacheEntry(cacheEntry) {
        if (cacheEntry.map !== void 0) {
          return cacheEntry.map;
        } else if (cacheEntry.bufferedMap !== void 0) {
          return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);
        }
      }
      _getCachedSource() {
        if (this._cachedSource !== void 0) return this._cachedSource;
        if (this._cachedBuffer && this._cachedSourceType !== void 0) {
          return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString("utf-8") : this._cachedBuffer;
        }
      }
      buffer() {
        if (this._cachedBuffer !== void 0) return this._cachedBuffer;
        if (this._cachedSource !== void 0) {
          if (Buffer.isBuffer(this._cachedSource)) {
            return this._cachedBuffer = this._cachedSource;
          }
          return this._cachedBuffer = Buffer.from(this._cachedSource, "utf-8");
        }
        if (typeof this.original().buffer === "function") {
          return this._cachedBuffer = this.original().buffer();
        }
        const bufferOrString = this.source();
        if (Buffer.isBuffer(bufferOrString)) {
          return this._cachedBuffer = bufferOrString;
        }
        return this._cachedBuffer = Buffer.from(bufferOrString, "utf-8");
      }
      size() {
        if (this._cachedSize !== void 0) return this._cachedSize;
        if (this._cachedBuffer !== void 0) {
          return this._cachedSize = this._cachedBuffer.length;
        }
        const source = this._getCachedSource();
        if (source !== void 0) {
          return this._cachedSize = Buffer.byteLength(source);
        }
        return this._cachedSize = this.original().size();
      }
      sourceAndMap(options) {
        const key = options ? JSON.stringify(options) : "{}";
        const cacheEntry = this._cachedMaps.get(key);
        if (cacheEntry !== void 0) {
          const map2 = this._getMapFromCacheEntry(cacheEntry);
          return { source: this.source(), map: map2 };
        }
        let source = this._getCachedSource();
        let map;
        if (source !== void 0) {
          map = this.original().map(options);
        } else {
          const sourceAndMap = this.original().sourceAndMap(options);
          source = sourceAndMap.source;
          map = sourceAndMap.map;
          this._cachedSource = source;
        }
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return { source, map };
      }
      streamChunks(options, onChunk, onSource, onName) {
        const key = options ? JSON.stringify(options) : "{}";
        if (this._cachedMaps.has(key) && (this._cachedBuffer !== void 0 || this._cachedSource !== void 0)) {
          const { source: source2, map: map2 } = this.sourceAndMap(options);
          if (map2) {
            return streamChunksOfSourceMap(
              source2,
              map2,
              onChunk,
              onSource,
              onName,
              !!(options && options.finalSource),
              true
            );
          } else {
            return streamChunksOfRawSource(
              source2,
              onChunk,
              onSource,
              onName,
              !!(options && options.finalSource)
            );
          }
        }
        const { result, source, map } = streamAndGetSourceAndMap(
          this.original(),
          options,
          onChunk,
          onSource,
          onName
        );
        this._cachedSource = source;
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return result;
      }
      map(options) {
        const key = options ? JSON.stringify(options) : "{}";
        const cacheEntry = this._cachedMaps.get(key);
        if (cacheEntry !== void 0) {
          return this._getMapFromCacheEntry(cacheEntry);
        }
        const map = this.original().map(options);
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return map;
      }
      updateHash(hash) {
        if (this._cachedHashUpdate !== void 0) {
          for (const item of this._cachedHashUpdate) hash.update(item);
          return;
        }
        const update = [];
        let currentString = void 0;
        const tracker = {
          update: (item) => {
            if (typeof item === "string" && item.length < 10240) {
              if (currentString === void 0) {
                currentString = item;
              } else {
                currentString += item;
                if (currentString.length > 102400) {
                  update.push(Buffer.from(currentString));
                  currentString = void 0;
                }
              }
            } else {
              if (currentString !== void 0) {
                update.push(Buffer.from(currentString));
                currentString = void 0;
              }
              update.push(item);
            }
          }
        };
        this.original().updateHash(tracker);
        if (currentString !== void 0) {
          update.push(Buffer.from(currentString));
        }
        for (const item of update) hash.update(item);
        this._cachedHashUpdate = update;
      }
    };
    module2.exports = CachedSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ConcatSource.js
var require_ConcatSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ConcatSource.js"(exports2, module2) {
    "use strict";
    var Source = require_Source();
    var RawSource = require_RawSource();
    var streamChunks = require_streamChunks();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var stringsAsRawSources = /* @__PURE__ */ new WeakSet();
    var ConcatSource3 = class _ConcatSource extends Source {
      constructor() {
        super();
        this._children = [];
        for (let i = 0; i < arguments.length; i++) {
          const item = arguments[i];
          if (item instanceof _ConcatSource) {
            for (const child of item._children) {
              this._children.push(child);
            }
          } else {
            this._children.push(item);
          }
        }
        this._isOptimized = arguments.length === 0;
      }
      getChildren() {
        if (!this._isOptimized) this._optimize();
        return this._children;
      }
      add(item) {
        if (item instanceof _ConcatSource) {
          for (const child of item._children) {
            this._children.push(child);
          }
        } else {
          this._children.push(item);
        }
        this._isOptimized = false;
      }
      addAllSkipOptimizing(items) {
        for (const item of items) {
          this._children.push(item);
        }
      }
      buffer() {
        if (!this._isOptimized) this._optimize();
        const buffers = [];
        for (const child of this._children) {
          if (typeof child.buffer === "function") {
            buffers.push(child.buffer());
          } else {
            const bufferOrString = child.source();
            if (Buffer.isBuffer(bufferOrString)) {
              buffers.push(bufferOrString);
            } else {
              buffers.push(Buffer.from(bufferOrString, "utf-8"));
            }
          }
        }
        return Buffer.concat(buffers);
      }
      source() {
        if (!this._isOptimized) this._optimize();
        let source = "";
        for (const child of this._children) {
          source += child.source();
        }
        return source;
      }
      size() {
        if (!this._isOptimized) this._optimize();
        let size = 0;
        for (const child of this._children) {
          size += child.size();
        }
        return size;
      }
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        if (!this._isOptimized) this._optimize();
        if (this._children.length === 1)
          return this._children[0].streamChunks(options, onChunk, onSource, onName);
        let currentLineOffset = 0;
        let currentColumnOffset = 0;
        let sourceMapping = /* @__PURE__ */ new Map();
        let nameMapping = /* @__PURE__ */ new Map();
        const finalSource = !!(options && options.finalSource);
        let code = "";
        let needToCloseMapping = false;
        for (const item of this._children) {
          const sourceIndexMapping = [];
          const nameIndexMapping = [];
          let lastMappingLine = 0;
          const { generatedLine, generatedColumn, source } = streamChunks(
            item,
            options,
            // eslint-disable-next-line no-loop-func
            (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
              const line = generatedLine2 + currentLineOffset;
              const column = generatedLine2 === 1 ? generatedColumn2 + currentColumnOffset : generatedColumn2;
              if (needToCloseMapping) {
                if (generatedLine2 !== 1 || generatedColumn2 !== 0) {
                  onChunk(
                    void 0,
                    currentLineOffset + 1,
                    currentColumnOffset,
                    -1,
                    -1,
                    -1,
                    -1
                  );
                }
                needToCloseMapping = false;
              }
              const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
              const resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];
              lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine2;
              if (finalSource) {
                if (chunk !== void 0) code += chunk;
                if (resultSourceIndex >= 0) {
                  onChunk(
                    void 0,
                    line,
                    column,
                    resultSourceIndex,
                    originalLine,
                    originalColumn,
                    resultNameIndex
                  );
                }
              } else {
                if (resultSourceIndex < 0) {
                  onChunk(chunk, line, column, -1, -1, -1, -1);
                } else {
                  onChunk(
                    chunk,
                    line,
                    column,
                    resultSourceIndex,
                    originalLine,
                    originalColumn,
                    resultNameIndex
                  );
                }
              }
            },
            (i, source2, sourceContent) => {
              let globalIndex = sourceMapping.get(source2);
              if (globalIndex === void 0) {
                sourceMapping.set(source2, globalIndex = sourceMapping.size);
                onSource(globalIndex, source2, sourceContent);
              }
              sourceIndexMapping[i] = globalIndex;
            },
            (i, name) => {
              let globalIndex = nameMapping.get(name);
              if (globalIndex === void 0) {
                nameMapping.set(name, globalIndex = nameMapping.size);
                onName(globalIndex, name);
              }
              nameIndexMapping[i] = globalIndex;
            }
          );
          if (source !== void 0) code += source;
          if (needToCloseMapping) {
            if (generatedLine !== 1 || generatedColumn !== 0) {
              onChunk(
                void 0,
                currentLineOffset + 1,
                currentColumnOffset,
                -1,
                -1,
                -1,
                -1
              );
              needToCloseMapping = false;
            }
          }
          if (generatedLine > 1) {
            currentColumnOffset = generatedColumn;
          } else {
            currentColumnOffset += generatedColumn;
          }
          needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;
          currentLineOffset += generatedLine - 1;
        }
        return {
          generatedLine: currentLineOffset + 1,
          generatedColumn: currentColumnOffset,
          source: finalSource ? code : void 0
        };
      }
      updateHash(hash) {
        if (!this._isOptimized) this._optimize();
        hash.update("ConcatSource");
        for (const item of this._children) {
          item.updateHash(hash);
        }
      }
      _optimize() {
        const newChildren = [];
        let currentString = void 0;
        let currentRawSources = void 0;
        const addStringToRawSources = (string) => {
          if (currentRawSources === void 0) {
            currentRawSources = string;
          } else if (Array.isArray(currentRawSources)) {
            currentRawSources.push(string);
          } else {
            currentRawSources = [
              typeof currentRawSources === "string" ? currentRawSources : currentRawSources.source(),
              string
            ];
          }
        };
        const addSourceToRawSources = (source) => {
          if (currentRawSources === void 0) {
            currentRawSources = source;
          } else if (Array.isArray(currentRawSources)) {
            currentRawSources.push(source.source());
          } else {
            currentRawSources = [
              typeof currentRawSources === "string" ? currentRawSources : currentRawSources.source(),
              source.source()
            ];
          }
        };
        const mergeRawSources = () => {
          if (Array.isArray(currentRawSources)) {
            const rawSource = new RawSource(currentRawSources.join(""));
            stringsAsRawSources.add(rawSource);
            newChildren.push(rawSource);
          } else if (typeof currentRawSources === "string") {
            const rawSource = new RawSource(currentRawSources);
            stringsAsRawSources.add(rawSource);
            newChildren.push(rawSource);
          } else {
            newChildren.push(currentRawSources);
          }
        };
        for (const child of this._children) {
          if (typeof child === "string") {
            if (currentString === void 0) {
              currentString = child;
            } else {
              currentString += child;
            }
          } else {
            if (currentString !== void 0) {
              addStringToRawSources(currentString);
              currentString = void 0;
            }
            if (stringsAsRawSources.has(child)) {
              addSourceToRawSources(child);
            } else {
              if (currentRawSources !== void 0) {
                mergeRawSources();
                currentRawSources = void 0;
              }
              newChildren.push(child);
            }
          }
        }
        if (currentString !== void 0) {
          addStringToRawSources(currentString);
        }
        if (currentRawSources !== void 0) {
          mergeRawSources();
        }
        this._children = newChildren;
        this._isOptimized = true;
      }
    };
    module2.exports = ConcatSource3;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ReplaceSource.js
var require_ReplaceSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ReplaceSource.js"(exports2, module2) {
    "use strict";
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var streamChunks = require_streamChunks();
    var Source = require_Source();
    var splitIntoLines = require_splitIntoLines();
    var hasStableSort = typeof process === "object" && process.versions && typeof process.versions.v8 === "string" && !/^[0-6]\./.test(process.versions.v8);
    var MAX_SOURCE_POSITION = 536870912;
    var Replacement = class {
      constructor(start, end, content, name) {
        this.start = start;
        this.end = end;
        this.content = content;
        this.name = name;
        if (!hasStableSort) {
          this.index = -1;
        }
      }
    };
    var ReplaceSource = class extends Source {
      constructor(source, name) {
        super();
        this._source = source;
        this._name = name;
        this._replacements = [];
        this._isSorted = true;
      }
      getName() {
        return this._name;
      }
      getReplacements() {
        this._sortReplacements();
        return this._replacements;
      }
      replace(start, end, newValue, name) {
        if (typeof newValue !== "string")
          throw new Error(
            "insertion must be a string, but is a " + typeof newValue
          );
        this._replacements.push(new Replacement(start, end, newValue, name));
        this._isSorted = false;
      }
      insert(pos, newValue, name) {
        if (typeof newValue !== "string")
          throw new Error(
            "insertion must be a string, but is a " + typeof newValue + ": " + newValue
          );
        this._replacements.push(new Replacement(pos, pos - 1, newValue, name));
        this._isSorted = false;
      }
      source() {
        if (this._replacements.length === 0) {
          return this._source.source();
        }
        let current = this._source.source();
        let pos = 0;
        const result = [];
        this._sortReplacements();
        for (const replacement of this._replacements) {
          const start = Math.floor(replacement.start);
          const end = Math.floor(replacement.end + 1);
          if (pos < start) {
            const offset = start - pos;
            result.push(current.slice(0, offset));
            current = current.slice(offset);
            pos = start;
          }
          result.push(replacement.content);
          if (pos < end) {
            const offset = end - pos;
            current = current.slice(offset);
            pos = end;
          }
        }
        result.push(current);
        return result.join("");
      }
      map(options) {
        if (this._replacements.length === 0) {
          return this._source.map(options);
        }
        return getMap(this, options);
      }
      sourceAndMap(options) {
        if (this._replacements.length === 0) {
          return this._source.sourceAndMap(options);
        }
        return getSourceAndMap(this, options);
      }
      original() {
        return this._source;
      }
      _sortReplacements() {
        if (this._isSorted) return;
        if (hasStableSort) {
          this._replacements.sort(function(a, b) {
            const diff1 = a.start - b.start;
            if (diff1 !== 0) return diff1;
            const diff2 = a.end - b.end;
            if (diff2 !== 0) return diff2;
            return 0;
          });
        } else {
          this._replacements.forEach((repl, i) => repl.index = i);
          this._replacements.sort(function(a, b) {
            const diff1 = a.start - b.start;
            if (diff1 !== 0) return diff1;
            const diff2 = a.end - b.end;
            if (diff2 !== 0) return diff2;
            return a.index - b.index;
          });
        }
        this._isSorted = true;
      }
      streamChunks(options, onChunk, onSource, onName) {
        this._sortReplacements();
        const repls = this._replacements;
        let pos = 0;
        let i = 0;
        let replacmentEnd = -1;
        let nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
        let generatedLineOffset = 0;
        let generatedColumnOffset = 0;
        let generatedColumnOffsetLine = 0;
        const sourceContents = [];
        const nameMapping = /* @__PURE__ */ new Map();
        const nameIndexMapping = [];
        const checkOriginalContent = (sourceIndex, line2, column, expectedChunk) => {
          let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : void 0;
          if (content === void 0) return false;
          if (typeof content === "string") {
            content = splitIntoLines(content);
            sourceContents[sourceIndex] = content;
          }
          const contentLine = line2 <= content.length ? content[line2 - 1] : null;
          if (contentLine === null) return false;
          return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;
        };
        let { generatedLine, generatedColumn } = streamChunks(
          this._source,
          Object.assign({}, options, { finalSource: false }),
          (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
            let chunkPos = 0;
            let endPos = pos + chunk.length;
            if (replacmentEnd > pos) {
              if (replacmentEnd >= endPos) {
                const line3 = generatedLine2 + generatedLineOffset;
                if (chunk.endsWith("\n")) {
                  generatedLineOffset--;
                  if (generatedColumnOffsetLine === line3) {
                    generatedColumnOffset += generatedColumn2;
                  }
                } else if (generatedColumnOffsetLine === line3) {
                  generatedColumnOffset -= chunk.length;
                } else {
                  generatedColumnOffset = -chunk.length;
                  generatedColumnOffsetLine = line3;
                }
                pos = endPos;
                return;
              }
              chunkPos = replacmentEnd - pos;
              if (checkOriginalContent(
                sourceIndex,
                originalLine,
                originalColumn,
                chunk.slice(0, chunkPos)
              )) {
                originalColumn += chunkPos;
              }
              pos += chunkPos;
              const line2 = generatedLine2 + generatedLineOffset;
              if (generatedColumnOffsetLine === line2) {
                generatedColumnOffset -= chunkPos;
              } else {
                generatedColumnOffset = -chunkPos;
                generatedColumnOffsetLine = line2;
              }
              generatedColumn2 += chunkPos;
            }
            if (nextReplacement < endPos) {
              do {
                let line2 = generatedLine2 + generatedLineOffset;
                if (nextReplacement > pos) {
                  const offset2 = nextReplacement - pos;
                  const chunkSlice = chunk.slice(chunkPos, chunkPos + offset2);
                  onChunk(
                    chunkSlice,
                    line2,
                    generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]
                  );
                  generatedColumn2 += offset2;
                  chunkPos += offset2;
                  pos = nextReplacement;
                  if (checkOriginalContent(
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    chunkSlice
                  )) {
                    originalColumn += chunkSlice.length;
                  }
                }
                const { content, name } = repls[i];
                let matches2 = splitIntoLines(content);
                let replacementNameIndex = nameIndex;
                if (sourceIndex >= 0 && name) {
                  let globalIndex = nameMapping.get(name);
                  if (globalIndex === void 0) {
                    globalIndex = nameMapping.size;
                    nameMapping.set(name, globalIndex);
                    onName(globalIndex, name);
                  }
                  replacementNameIndex = globalIndex;
                }
                for (let m = 0; m < matches2.length; m++) {
                  const contentLine = matches2[m];
                  onChunk(
                    contentLine,
                    line2,
                    generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    replacementNameIndex
                  );
                  replacementNameIndex = -1;
                  if (m === matches2.length - 1 && !contentLine.endsWith("\n")) {
                    if (generatedColumnOffsetLine === line2) {
                      generatedColumnOffset += contentLine.length;
                    } else {
                      generatedColumnOffset = contentLine.length;
                      generatedColumnOffsetLine = line2;
                    }
                  } else {
                    generatedLineOffset++;
                    line2++;
                    generatedColumnOffset = -generatedColumn2;
                    generatedColumnOffsetLine = line2;
                  }
                }
                replacmentEnd = Math.max(
                  replacmentEnd,
                  Math.floor(repls[i].end + 1)
                );
                i++;
                nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
                const offset = chunk.length - endPos + replacmentEnd - chunkPos;
                if (offset > 0) {
                  if (replacmentEnd >= endPos) {
                    let line4 = generatedLine2 + generatedLineOffset;
                    if (chunk.endsWith("\n")) {
                      generatedLineOffset--;
                      if (generatedColumnOffsetLine === line4) {
                        generatedColumnOffset += generatedColumn2;
                      }
                    } else if (generatedColumnOffsetLine === line4) {
                      generatedColumnOffset -= chunk.length - chunkPos;
                    } else {
                      generatedColumnOffset = chunkPos - chunk.length;
                      generatedColumnOffsetLine = line4;
                    }
                    pos = endPos;
                    return;
                  }
                  const line3 = generatedLine2 + generatedLineOffset;
                  if (checkOriginalContent(
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    chunk.slice(chunkPos, chunkPos + offset)
                  )) {
                    originalColumn += offset;
                  }
                  chunkPos += offset;
                  pos += offset;
                  if (generatedColumnOffsetLine === line3) {
                    generatedColumnOffset -= offset;
                  } else {
                    generatedColumnOffset = -offset;
                    generatedColumnOffsetLine = line3;
                  }
                  generatedColumn2 += offset;
                }
              } while (nextReplacement < endPos);
            }
            if (chunkPos < chunk.length) {
              const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);
              const line2 = generatedLine2 + generatedLineOffset;
              onChunk(
                chunkSlice,
                line2,
                generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                sourceIndex,
                originalLine,
                originalColumn,
                nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]
              );
            }
            pos = endPos;
          },
          (sourceIndex, source, sourceContent) => {
            while (sourceContents.length < sourceIndex)
              sourceContents.push(void 0);
            sourceContents[sourceIndex] = sourceContent;
            onSource(sourceIndex, source, sourceContent);
          },
          (nameIndex, name) => {
            let globalIndex = nameMapping.get(name);
            if (globalIndex === void 0) {
              globalIndex = nameMapping.size;
              nameMapping.set(name, globalIndex);
              onName(globalIndex, name);
            }
            nameIndexMapping[nameIndex] = globalIndex;
          }
        );
        let remainer = "";
        for (; i < repls.length; i++) {
          remainer += repls[i].content;
        }
        let line = generatedLine + generatedLineOffset;
        let matches = splitIntoLines(remainer);
        for (let m = 0; m < matches.length; m++) {
          const contentLine = matches[m];
          onChunk(
            contentLine,
            line,
            generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0),
            -1,
            -1,
            -1,
            -1
          );
          if (m === matches.length - 1 && !contentLine.endsWith("\n")) {
            if (generatedColumnOffsetLine === line) {
              generatedColumnOffset += contentLine.length;
            } else {
              generatedColumnOffset = contentLine.length;
              generatedColumnOffsetLine = line;
            }
          } else {
            generatedLineOffset++;
            line++;
            generatedColumnOffset = -generatedColumn;
            generatedColumnOffsetLine = line;
          }
        }
        return {
          generatedLine: line,
          generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)
        };
      }
      updateHash(hash) {
        this._sortReplacements();
        hash.update("ReplaceSource");
        this._source.updateHash(hash);
        hash.update(this._name || "");
        for (const repl of this._replacements) {
          hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);
        }
      }
    };
    module2.exports = ReplaceSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/PrefixSource.js
var require_PrefixSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/PrefixSource.js"(exports2, module2) {
    "use strict";
    var Source = require_Source();
    var RawSource = require_RawSource();
    var streamChunks = require_streamChunks();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var REPLACE_REGEX = /\n(?=.|\s)/g;
    var PrefixSource = class extends Source {
      constructor(prefix, source) {
        super();
        this._source = typeof source === "string" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;
        this._prefix = prefix;
      }
      getPrefix() {
        return this._prefix;
      }
      original() {
        return this._source;
      }
      source() {
        const node = this._source.source();
        const prefix = this._prefix;
        return prefix + node.replace(REPLACE_REGEX, "\n" + prefix);
      }
      // TODO efficient buffer() implementation
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        const prefix = this._prefix;
        const prefixOffset = prefix.length;
        const linesOnly = !!(options && options.columns === false);
        const { generatedLine, generatedColumn, source } = streamChunks(
          this._source,
          options,
          (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
            if (generatedColumn2 !== 0) {
              generatedColumn2 += prefixOffset;
            } else if (chunk !== void 0) {
              if (linesOnly || sourceIndex < 0) {
                chunk = prefix + chunk;
              } else if (prefixOffset > 0) {
                onChunk(prefix, generatedLine2, generatedColumn2, -1, -1, -1, -1);
                generatedColumn2 += prefixOffset;
              }
            } else if (!linesOnly) {
              generatedColumn2 += prefixOffset;
            }
            onChunk(
              chunk,
              generatedLine2,
              generatedColumn2,
              sourceIndex,
              originalLine,
              originalColumn,
              nameIndex
            );
          },
          onSource,
          onName
        );
        return {
          generatedLine,
          generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,
          source: source !== void 0 ? prefix + source.replace(REPLACE_REGEX, "\n" + prefix) : void 0
        };
      }
      updateHash(hash) {
        hash.update("PrefixSource");
        this._source.updateHash(hash);
        hash.update(this._prefix);
      }
    };
    module2.exports = PrefixSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SizeOnlySource.js
var require_SizeOnlySource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SizeOnlySource.js"(exports2, module2) {
    "use strict";
    var Source = require_Source();
    var SizeOnlySource = class extends Source {
      constructor(size) {
        super();
        this._size = size;
      }
      _error() {
        return new Error(
          "Content and Map of this Source is not available (only size() is supported)"
        );
      }
      size() {
        return this._size;
      }
      source() {
        throw this._error();
      }
      buffer() {
        throw this._error();
      }
      map(options) {
        throw this._error();
      }
      updateHash() {
        throw this._error();
      }
    };
    module2.exports = SizeOnlySource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CompatSource.js
var require_CompatSource = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CompatSource.js"(exports2, module2) {
    "use strict";
    var Source = require_Source();
    var CompatSource = class _CompatSource extends Source {
      static from(sourceLike) {
        return sourceLike instanceof Source ? sourceLike : new _CompatSource(sourceLike);
      }
      constructor(sourceLike) {
        super();
        this._sourceLike = sourceLike;
      }
      source() {
        return this._sourceLike.source();
      }
      buffer() {
        if (typeof this._sourceLike.buffer === "function") {
          return this._sourceLike.buffer();
        }
        return super.buffer();
      }
      size() {
        if (typeof this._sourceLike.size === "function") {
          return this._sourceLike.size();
        }
        return super.size();
      }
      map(options) {
        if (typeof this._sourceLike.map === "function") {
          return this._sourceLike.map(options);
        }
        return super.map(options);
      }
      sourceAndMap(options) {
        if (typeof this._sourceLike.sourceAndMap === "function") {
          return this._sourceLike.sourceAndMap(options);
        }
        return super.sourceAndMap(options);
      }
      updateHash(hash) {
        if (typeof this._sourceLike.updateHash === "function") {
          return this._sourceLike.updateHash(hash);
        }
        if (typeof this._sourceLike.map === "function") {
          throw new Error(
            "A Source-like object with a 'map' method must also provide an 'updateHash' method"
          );
        }
        hash.update(this.buffer());
      }
    };
    module2.exports = CompatSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/index.js
var require_lib8 = __commonJS2({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/index.js"(exports2) {
    var defineExport = (name, fn) => {
      let value;
      Object.defineProperty(exports2, name, {
        get: () => {
          if (fn !== void 0) {
            value = fn();
            fn = void 0;
          }
          return value;
        },
        configurable: true
      });
    };
    defineExport("Source", () => require_Source());
    defineExport("RawSource", () => require_RawSource());
    defineExport("OriginalSource", () => require_OriginalSource());
    defineExport("SourceMapSource", () => require_SourceMapSource());
    defineExport("CachedSource", () => require_CachedSource());
    defineExport("ConcatSource", () => require_ConcatSource());
    defineExport("ReplaceSource", () => require_ReplaceSource());
    defineExport("PrefixSource", () => require_PrefixSource());
    defineExport("SizeOnlySource", () => require_SizeOnlySource());
    defineExport("CompatSource", () => require_CompatSource());
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      let encoded = "";
      let digit;
      let vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/util.js
var require_util3 = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      }
      throw new Error('"' + aName + '" is a required argument.');
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      const match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      let url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      const cache = [];
      return function(input) {
        for (let i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            const temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        const result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      let path3 = aPath;
      const url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path3 = url.path;
      }
      const isAbsolute = exports2.isAbsolute(path3);
      const parts = [];
      let start = 0;
      let i = 0;
      while (true) {
        start = i;
        i = path3.indexOf("/", start);
        if (i === -1) {
          parts.push(path3.slice(start));
          break;
        } else {
          parts.push(path3.slice(start, i));
          while (i < path3.length && path3[i] === "/") {
            i++;
          }
        }
      }
      let up = 0;
      for (i = parts.length - 1; i >= 0; i--) {
        const part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path3 = parts.join("/");
      if (path3 === "") {
        path3 = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path3;
        return urlGenerate(url);
      }
      return path3;
    });
    exports2.normalize = normalize;
    function join2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      const aPathUrl = urlParse(aPath);
      const aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      const joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join2;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      let level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        const index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = (function() {
      const obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      const length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (let i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      let cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      let cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        const parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          const index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/array-set.js"(exports2) {
    var ArraySet = class _ArraySet {
      constructor() {
        this._array = [];
        this._set = /* @__PURE__ */ new Map();
      }
      /**
       * Static method for creating ArraySet instances from an existing array.
       */
      static fromArray(aArray, aAllowDuplicates) {
        const set = new _ArraySet();
        for (let i = 0, len = aArray.length; i < len; i++) {
          set.add(aArray[i], aAllowDuplicates);
        }
        return set;
      }
      /**
       * Return how many unique items are in this ArraySet. If duplicates have been
       * added, than those do not count towards the size.
       *
       * @returns Number
       */
      size() {
        return this._set.size;
      }
      /**
       * Add the given string to this set.
       *
       * @param String aStr
       */
      add(aStr, aAllowDuplicates) {
        const isDuplicate = this.has(aStr);
        const idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          this._set.set(aStr, idx);
        }
      }
      /**
       * Is the given string a member of this set?
       *
       * @param String aStr
       */
      has(aStr) {
        return this._set.has(aStr);
      }
      /**
       * What is the index of the given string in the array?
       *
       * @param String aStr
       */
      indexOf(aStr) {
        const idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
        throw new Error('"' + aStr + '" is not in the set.');
      }
      /**
       * What is the element at the given index?
       *
       * @param Number aIdx
       */
      at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      }
      /**
       * Returns the array representation of this set (which has the proper indices
       * indicated by indexOf). Note that this is a copy of the internal array used
       * for storing the members so that no one can mess with internal state.
       */
      toArray() {
        return this._array.slice();
      }
    };
    exports2.ArraySet = ArraySet;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util3();
    function generatedPositionAfter(mappingA, mappingB) {
      const lineA = mappingA.generatedLine;
      const lineB = mappingB.generatedLine;
      const columnA = mappingA.generatedColumn;
      const columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    var MappingList = class {
      constructor() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      /**
       * Iterate through internal items. This method takes the same arguments that
       * `Array.prototype.forEach` takes.
       *
       * NOTE: The order of the mappings is NOT guaranteed.
       */
      unsortedForEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      }
      /**
       * Add the given source mapping.
       *
       * @param Object aMapping
       */
      add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      }
      /**
       * Returns the flat, sorted array of mappings. The mappings are sorted by
       * generated position.
       *
       * WARNING: This method returns internal data without copying, for
       * performance. The return value must NOT be mutated, and should be treated as
       * an immutable borrow. If you want to take ownership, you must make your own
       * copy.
       */
      toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      }
    };
    exports2.MappingList = MappingList;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util3();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    var SourceMapGenerator2 = class _SourceMapGenerator {
      constructor(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      /**
       * Creates a new SourceMapGenerator based on a SourceMapConsumer
       *
       * @param aSourceMapConsumer The SourceMap.
       */
      static fromSourceMap(aSourceMapConsumer) {
        const sourceRoot = aSourceMapConsumer.sourceRoot;
        const generator = new _SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          const newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          let sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      }
      /**
       * Add a single mapping from original source line and column to the generated
       * source's line and column for this source map being created. The mapping
       * object should have the following properties:
       *
       *   - generated: An object with the generated line and column positions.
       *   - original: An object with the original line and column positions.
       *   - source: The original source file (relative to the sourceRoot).
       *   - name: An optional original token name for this mapping.
       */
      addMapping(aArgs) {
        const generated = util.getArg(aArgs, "generated");
        const original = util.getArg(aArgs, "original", null);
        let source = util.getArg(aArgs, "source", null);
        let name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      }
      /**
       * Set the source content for a source file.
       */
      setSourceContent(aSourceFile, aSourceContent) {
        let source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      }
      /**
       * Applies the mappings of a sub-source-map for a specific source file to the
       * source map being generated. Each mapping to the supplied source file is
       * rewritten using the supplied source map. Note: The resolution for the
       * resulting mappings is the minimium of this map and the supplied map.
       *
       * @param aSourceMapConsumer The source map to be applied.
       * @param aSourceFile Optional. The filename of the source file.
       *        If omitted, SourceMapConsumer's file property will be used.
       * @param aSourceMapPath Optional. The dirname of the path to the source map
       *        to be applied. If relative, it is relative to the SourceMapConsumer.
       *        This parameter is needed when the two source maps aren't in the same
       *        directory, and the source map to be applied contains relative source
       *        paths. If so, those relative source paths need to be rewritten
       *        relative to the SourceMapGenerator.
       */
      applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        let sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        const sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        const newSources = this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;
        const newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            const original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          const source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          const name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(srcFile) {
          const content = aSourceMapConsumer.sourceContentFor(srcFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              srcFile = util.join(aSourceMapPath, srcFile);
            }
            if (sourceRoot != null) {
              srcFile = util.relative(sourceRoot, srcFile);
            }
            this.setSourceContent(srcFile, content);
          }
        }, this);
      }
      /**
       * A mapping can have one of the three levels of data:
       *
       *   1. Just the generated position.
       *   2. The Generated position, original position, and original source.
       *   3. Generated and original position, original source, as well as a name
       *      token.
       *
       * To maintain consistency, we validate that any new mapping being added falls
       * in to one of these categories.
       */
      _validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      }
      /**
       * Serialize the accumulated mappings in to the stream of base 64 VLQs
       * specified by the source map format.
       */
      _serializeMappings() {
        let previousGeneratedColumn = 0;
        let previousGeneratedLine = 1;
        let previousOriginalColumn = 0;
        let previousOriginalLine = 0;
        let previousName = 0;
        let previousSource = 0;
        let result = "";
        let next;
        let mapping;
        let nameIdx;
        let sourceIdx;
        const mappings = this._mappings.toArray();
        for (let i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      }
      _generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          const key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      }
      /**
       * Externalize the source map.
       */
      toJSON() {
        const map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
        return map;
      }
      /**
       * Render the source map being generated to a string.
       */
      toString() {
        return JSON.stringify(this.toJSON());
      }
    };
    SourceMapGenerator2.prototype._version = 3;
    exports2.SourceMapGenerator = SourceMapGenerator2;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      const mid = Math.floor((aHigh - aLow) / 2) + aLow;
      const cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        }
        return mid;
      }
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports2.LEAST_UPPER_BOUND) {
        return mid;
      }
      return aLow < 0 ? -1 : aLow;
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      let index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/read-wasm.js
var require_read_wasm = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/read-wasm.js"(exports2, module2) {
    var isBrowserEnvironment = (function() {
      return typeof window !== "undefined" && this === window;
    }).call();
    if (isBrowserEnvironment) {
      let mappingsWasm = null;
      module2.exports = function readWasm() {
        if (typeof mappingsWasm === "string") {
          return fetch(mappingsWasm).then((response) => response.arrayBuffer());
        }
        if (mappingsWasm instanceof ArrayBuffer) {
          return Promise.resolve(mappingsWasm);
        }
        throw new Error("You must provide the string URL or ArrayBuffer contents of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
      };
      module2.exports.initialize = (input) => mappingsWasm = input;
    } else {
      const fs4 = require("fs");
      const path3 = require("path");
      module2.exports = function readWasm() {
        return new Promise((resolve, reject) => {
          const wasmPath = path3.join(__dirname, "mappings.wasm");
          fs4.readFile(wasmPath, null, (error, data) => {
            if (error) {
              reject(error);
              return;
            }
            resolve(data.buffer);
          });
        });
      };
      module2.exports.initialize = (_) => {
        console.debug("SourceMapConsumer.initialize is a no-op when running in node.js");
      };
    }
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/wasm.js
var require_wasm = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/wasm.js"(exports2, module2) {
    var readWasm = require_read_wasm();
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.lastGeneratedColumn = null;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var cachedWasm = null;
    module2.exports = function wasm() {
      if (cachedWasm) {
        return cachedWasm;
      }
      const callbackStack = [];
      cachedWasm = readWasm().then((buffer) => {
        return WebAssembly.instantiate(buffer, {
          env: {
            mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {
              const mapping = new Mapping();
              mapping.generatedLine = generatedLine + 1;
              mapping.generatedColumn = generatedColumn;
              if (hasLastGeneratedColumn) {
                mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
              }
              if (hasOriginal) {
                mapping.source = source;
                mapping.originalLine = originalLine + 1;
                mapping.originalColumn = originalColumn;
                if (hasName) {
                  mapping.name = name;
                }
              }
              callbackStack[callbackStack.length - 1](mapping);
            },
            start_all_generated_locations_for() {
              console.time("all_generated_locations_for");
            },
            end_all_generated_locations_for() {
              console.timeEnd("all_generated_locations_for");
            },
            start_compute_column_spans() {
              console.time("compute_column_spans");
            },
            end_compute_column_spans() {
              console.timeEnd("compute_column_spans");
            },
            start_generated_location_for() {
              console.time("generated_location_for");
            },
            end_generated_location_for() {
              console.timeEnd("generated_location_for");
            },
            start_original_location_for() {
              console.time("original_location_for");
            },
            end_original_location_for() {
              console.timeEnd("original_location_for");
            },
            start_parse_mappings() {
              console.time("parse_mappings");
            },
            end_parse_mappings() {
              console.timeEnd("parse_mappings");
            },
            start_sort_by_generated_location() {
              console.time("sort_by_generated_location");
            },
            end_sort_by_generated_location() {
              console.timeEnd("sort_by_generated_location");
            },
            start_sort_by_original_location() {
              console.time("sort_by_original_location");
            },
            end_sort_by_original_location() {
              console.timeEnd("sort_by_original_location");
            }
          }
        });
      }).then((Wasm) => {
        return {
          exports: Wasm.instance.exports,
          withMappingCallback: (mappingCallback, f) => {
            callbackStack.push(mappingCallback);
            try {
              f();
            } finally {
              callbackStack.pop();
            }
          }
        };
      }).then(null, (e) => {
        cachedWasm = null;
        throw e;
      });
      return cachedWasm;
    };
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-map-consumer.js"(exports2) {
    var util = require_util3();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var readWasm = require_read_wasm();
    var wasm = require_wasm();
    var INTERNAL = Symbol("smcInternal");
    var SourceMapConsumer2 = class _SourceMapConsumer {
      constructor(aSourceMap, aSourceMapURL) {
        if (aSourceMap == INTERNAL) {
          return Promise.resolve(this);
        }
        return _factory(aSourceMap, aSourceMapURL);
      }
      static initialize(opts) {
        readWasm.initialize(opts["lib/mappings.wasm"]);
      }
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return _factoryBSM(aSourceMap, aSourceMapURL);
      }
      /**
       * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`
       * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async
       * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait
       * for `f` to complete, call `destroy` on the consumer, and return `f`'s return
       * value.
       *
       * You must not use the consumer after `f` completes!
       *
       * By using `with`, you do not have to remember to manually call `destroy` on
       * the consumer, since it will be called automatically once `f` completes.
       *
       * ```js
       * const xSquared = await SourceMapConsumer.with(
       *   myRawSourceMap,
       *   null,
       *   async function (consumer) {
       *     // Use `consumer` inside here and don't worry about remembering
       *     // to call `destroy`.
       *
       *     const x = await whatever(consumer);
       *     return x * x;
       *   }
       * );
       *
       * // You may not use that `consumer` anymore out here; it has
       * // been destroyed. But you can use `xSquared`.
       * console.log(xSquared);
       * ```
       */
      static async with(rawSourceMap, sourceMapUrl, f) {
        const consumer = await new _SourceMapConsumer(rawSourceMap, sourceMapUrl);
        try {
          return await f(consumer);
        } finally {
          consumer.destroy();
        }
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      }
      /**
       * Iterate over each mapping between an original source/line/column and a
       * generated line/column in this source map.
       *
       * @param Function aCallback
       *        The function that is called with each mapping.
       * @param Object aContext
       *        Optional. If specified, this object will be the value of `this` every
       *        time that `aCallback` is called.
       * @param aOrder
       *        Either `SourceMapConsumer.GENERATED_ORDER` or
       *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
       *        iterate over the mappings sorted by the generated file's line/column
       *        order or the original's source/line/column order, respectively. Defaults to
       *        `SourceMapConsumer.GENERATED_ORDER`.
       */
      eachMapping(aCallback, aContext, aOrder) {
        throw new Error("Subclasses must implement eachMapping");
      }
      /**
       * Returns all generated line and column information for the original source,
       * line, and column provided. If no column is provided, returns all mappings
       * corresponding to a either the line we are searching for or the next
       * closest line that has any mappings. Otherwise, returns all mappings
       * corresponding to the given line and either the column we are searching for
       * or the next closest column that has any offsets.
       *
       * The only argument is an object with the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number is 1-based.
       *   - column: Optional. the column number in the original source.
       *    The column number is 0-based.
       *
       * and an array of objects is returned, each with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *    line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *    The column number is 0-based.
       */
      allGeneratedPositionsFor(aArgs) {
        throw new Error("Subclasses must implement allGeneratedPositionsFor");
      }
      destroy() {
        throw new Error("Subclasses must implement destroy");
      }
    };
    SourceMapConsumer2.prototype._version = 3;
    SourceMapConsumer2.GENERATED_ORDER = 1;
    SourceMapConsumer2.ORIGINAL_ORDER = 2;
    SourceMapConsumer2.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer2.LEAST_UPPER_BOUND = 2;
    exports2.SourceMapConsumer = SourceMapConsumer2;
    var BasicSourceMapConsumer = class _BasicSourceMapConsumer extends SourceMapConsumer2 {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version = util.getArg(sourceMap, "version");
          let sources = util.getArg(sourceMap, "sources");
          const names = util.getArg(sourceMap, "names", []);
          let sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
          const sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
          const mappings = util.getArg(sourceMap, "mappings");
          const file = util.getArg(sourceMap, "file", null);
          if (version != that._version) {
            throw new Error("Unsupported version: " + version);
          }
          if (sourceRoot) {
            sourceRoot = util.normalize(sourceRoot);
          }
          sources = sources.map(String).map(util.normalize).map(function(source) {
            return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
          });
          that._names = ArraySet.fromArray(names.map(String), true);
          that._sources = ArraySet.fromArray(sources, true);
          that._absoluteSources = that._sources.toArray().map(function(s) {
            return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
          });
          that.sourceRoot = sourceRoot;
          that.sourcesContent = sourcesContent;
          that._mappings = mappings;
          that._sourceMapURL = aSourceMapURL;
          that.file = file;
          that._computedColumnSpans = false;
          that._mappingsPtr = 0;
          that._wasm = null;
          return wasm().then((w) => {
            that._wasm = w;
            return that;
          });
        });
      }
      /**
       * Utility function to find the index of a source.  Returns -1 if not
       * found.
       */
      _findSourceIndex(aSource) {
        let relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        for (let i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      }
      /**
       * Create a BasicSourceMapConsumer from a SourceMapGenerator.
       *
       * @param SourceMapGenerator aSourceMap
       *        The source map that will be consumed.
       * @param String aSourceMapURL
       *        The URL at which the source map can be found (optional)
       * @returns BasicSourceMapConsumer
       */
      static fromSourceMap(aSourceMap, aSourceMapURL) {
        return new _BasicSourceMapConsumer(aSourceMap.toString());
      }
      get sources() {
        return this._absoluteSources.slice();
      }
      _getMappingsPtr() {
        if (this._mappingsPtr === 0) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this._mappingsPtr;
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings(aStr, aSourceRoot) {
        const size = aStr.length;
        const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);
        const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);
        for (let i = 0; i < size; i++) {
          mappingsBuf[i] = aStr.charCodeAt(i);
        }
        const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);
        if (!mappingsPtr) {
          const error = this._wasm.exports.get_last_error();
          let msg = `Error parsing mappings (code ${error}): `;
          switch (error) {
            case 1:
              msg += "the mappings contained a negative line, column, source index, or name index";
              break;
            case 2:
              msg += "the mappings contained a number larger than 2**32";
              break;
            case 3:
              msg += "reached EOF while in the middle of parsing a VLQ";
              break;
            case 4:
              msg += "invalid base 64 character while parsing a VLQ";
              break;
            default:
              msg += "unknown error code";
              break;
          }
          throw new Error(msg);
        }
        this._mappingsPtr = mappingsPtr;
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context = aContext || null;
        const order = aOrder || SourceMapConsumer2.GENERATED_ORDER;
        const sourceRoot = this.sourceRoot;
        this._wasm.withMappingCallback(
          (mapping) => {
            if (mapping.source !== null) {
              mapping.source = this._sources.at(mapping.source);
              mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);
              if (mapping.name !== null) {
                mapping.name = this._names.at(mapping.name);
              }
            }
            aCallback.call(context, mapping);
          },
          () => {
            switch (order) {
              case SourceMapConsumer2.GENERATED_ORDER:
                this._wasm.exports.by_generated_location(this._getMappingsPtr());
                break;
              case SourceMapConsumer2.ORIGINAL_ORDER:
                this._wasm.exports.by_original_location(this._getMappingsPtr());
                break;
              default:
                throw new Error("Unknown order of iteration.");
            }
          }
        );
      }
      allGeneratedPositionsFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        const originalLine = util.getArg(aArgs, "line");
        const originalColumn = aArgs.column || 0;
        source = this._findSourceIndex(source);
        if (source < 0) {
          return [];
        }
        if (originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        this._wasm.withMappingCallback(
          (m) => {
            let lastColumn = m.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            mappings.push({
              line: m.generatedLine,
              column: m.generatedColumn,
              lastColumn
            });
          },
          () => {
            this._wasm.exports.all_generated_locations_for(
              this._getMappingsPtr(),
              source,
              originalLine - 1,
              "column" in aArgs,
              originalColumn
            );
          }
        );
        return mappings;
      }
      destroy() {
        if (this._mappingsPtr !== 0) {
          this._wasm.exports.free_mappings(this._mappingsPtr);
          this._mappingsPtr = 0;
        }
      }
      /**
       * Compute the last column for each generated mapping. The last column is
       * inclusive.
       */
      computeColumnSpans() {
        if (this._computedColumnSpans) {
          return;
        }
        this._wasm.exports.compute_column_spans(this._getMappingsPtr());
        this._computedColumnSpans = true;
      }
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        if (needle.generatedLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.generatedColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer2.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer2.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.original_location_for(
            this._getMappingsPtr(),
            needle.generatedLine - 1,
            needle.generatedColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.generatedLine === needle.generatedLine) {
            let source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            let name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      }
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        const index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        let relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        let url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          const fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
       *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
       *     closest element that is smaller than or greater than the one we are
       *     searching for, respectively, if the exact element cannot be found.
       *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      generatedPositionFor(aArgs) {
        let source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        const needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        let bias = util.getArg(aArgs, "bias", SourceMapConsumer2.GREATEST_LOWER_BOUND);
        if (bias == null) {
          bias = SourceMapConsumer2.GREATEST_LOWER_BOUND;
        }
        let mapping;
        this._wasm.withMappingCallback((m) => mapping = m, () => {
          this._wasm.exports.generated_location_for(
            this._getMappingsPtr(),
            needle.source,
            needle.originalLine - 1,
            needle.originalColumn,
            bias
          );
        });
        if (mapping) {
          if (mapping.source === needle.source) {
            let lastColumn = mapping.lastGeneratedColumn;
            if (this._computedColumnSpans && lastColumn === null) {
              lastColumn = Infinity;
            }
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
    };
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer2;
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    var IndexedSourceMapConsumer = class extends SourceMapConsumer2 {
      constructor(aSourceMap, aSourceMapURL) {
        return super(INTERNAL).then((that) => {
          let sourceMap = aSourceMap;
          if (typeof aSourceMap === "string") {
            sourceMap = util.parseSourceMapInput(aSourceMap);
          }
          const version = util.getArg(sourceMap, "version");
          const sections = util.getArg(sourceMap, "sections");
          if (version != that._version) {
            throw new Error("Unsupported version: " + version);
          }
          that._sources = new ArraySet();
          that._names = new ArraySet();
          that.__generatedMappings = null;
          that.__originalMappings = null;
          that.__generatedMappingsUnsorted = null;
          that.__originalMappingsUnsorted = null;
          let lastOffset = {
            line: -1,
            column: 0
          };
          return Promise.all(sections.map((s) => {
            if (s.url) {
              throw new Error("Support for url field in sections not implemented.");
            }
            const offset = util.getArg(s, "offset");
            const offsetLine = util.getArg(offset, "line");
            const offsetColumn = util.getArg(offset, "column");
            if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
              throw new Error("Section offsets must be ordered and non-overlapping.");
            }
            lastOffset = offset;
            const cons = new SourceMapConsumer2(util.getArg(s, "map"), aSourceMapURL);
            return cons.then((consumer) => {
              return {
                generatedOffset: {
                  // The offset fields are 0-based, but we use 1-based indices when
                  // encoding/decoding from VLQ.
                  generatedLine: offsetLine + 1,
                  generatedColumn: offsetColumn + 1
                },
                consumer
              };
            });
          })).then((s) => {
            that._sections = s;
            return that;
          });
        });
      }
      // `__generatedMappings` and `__originalMappings` are arrays that hold the
      // parsed mapping coordinates from the source map's "mappings" attribute. They
      // are lazily instantiated, accessed via the `_generatedMappings` and
      // `_originalMappings` getters respectively, and we only parse the mappings
      // and create these arrays once queried for a source location. We jump through
      // these hoops because there can be many thousands of mappings, and parsing
      // them is expensive, so we only want to do it if we must.
      //
      // Each object in the arrays is of the form:
      //
      //     {
      //       generatedLine: The line number in the generated code,
      //       generatedColumn: The column number in the generated code,
      //       source: The path to the original source file that generated this
      //               chunk of code,
      //       originalLine: The line number in the original source that
      //                     corresponds to this chunk of generated code,
      //       originalColumn: The column number in the original source that
      //                       corresponds to this chunk of generated code,
      //       name: The name of the original symbol which generated this chunk of
      //             code.
      //     }
      //
      // All properties except for `generatedLine` and `generatedColumn` can be
      // `null`.
      //
      // `_generatedMappings` is ordered by the generated positions.
      //
      // `_originalMappings` is ordered by the original positions.
      get _generatedMappings() {
        if (!this.__generatedMappings) {
          this._sortGeneratedMappings();
        }
        return this.__generatedMappings;
      }
      get _originalMappings() {
        if (!this.__originalMappings) {
          this._sortOriginalMappings();
        }
        return this.__originalMappings;
      }
      get _generatedMappingsUnsorted() {
        if (!this.__generatedMappingsUnsorted) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappingsUnsorted;
      }
      get _originalMappingsUnsorted() {
        if (!this.__originalMappingsUnsorted) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappingsUnsorted;
      }
      _sortGeneratedMappings() {
        const mappings = this._generatedMappingsUnsorted;
        mappings.sort(util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = mappings;
      }
      _sortOriginalMappings() {
        const mappings = this._originalMappingsUnsorted;
        mappings.sort(util.compareByOriginalPositions);
        this.__originalMappings = mappings;
      }
      /**
       * The list of original sources.
       */
      get sources() {
        const sources = [];
        for (let i = 0; i < this._sections.length; i++) {
          for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
      /**
       * Returns the original source, line, and column information for the generated
       * source's line and column positions provided. The only argument is an object
       * with the following properties:
       *
       *   - line: The line number in the generated source.  The line number
       *     is 1-based.
       *   - column: The column number in the generated source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - source: The original source file, or null.
       *   - line: The line number in the original source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the original source, or null.  The
       *     column number is 0-based.
       *   - name: The original identifier, or null.
       */
      originalPositionFor(aArgs) {
        const needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        const sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(aNeedle, section2) {
            const cmp = aNeedle.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return aNeedle.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        const section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      }
      /**
       * Return true if we have the source content for every source in the source
       * map, false otherwise.
       */
      hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      }
      /**
       * Returns the original source content. The only argument is the url of the
       * original source file. Returns null if no original source content is
       * available.
       */
      sourceContentFor(aSource, nullOnMissing) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        }
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
      /**
       * Returns the generated line and column information for the original source,
       * line, and column positions provided. The only argument is an object with
       * the following properties:
       *
       *   - source: The filename of the original source.
       *   - line: The line number in the original source.  The line number
       *     is 1-based.
       *   - column: The column number in the original source.  The column
       *     number is 0-based.
       *
       * and an object is returned with the following properties:
       *
       *   - line: The line number in the generated source, or null.  The
       *     line number is 1-based.
       *   - column: The column number in the generated source, or null.
       *     The column number is 0-based.
       */
      generatedPositionFor(aArgs) {
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          const generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            const ret = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret;
          }
        }
        return {
          line: null,
          column: null
        };
      }
      /**
       * Parse the mappings in a string in to a data structure which we can easily
       * query (the ordered arrays in the `this.__generatedMappings` and
       * `this.__originalMappings` properties).
       */
      _parseMappings(aStr, aSourceRoot) {
        const generatedMappings = this.__generatedMappingsUnsorted = [];
        const originalMappings = this.__originalMappingsUnsorted = [];
        for (let i = 0; i < this._sections.length; i++) {
          const section = this._sections[i];
          const sectionMappings = [];
          section.consumer.eachMapping((m) => sectionMappings.push(m));
          for (let j = 0; j < sectionMappings.length; j++) {
            const mapping = sectionMappings[j];
            let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            let name = null;
            if (mapping.name) {
              this._names.add(mapping.name);
              name = this._names.indexOf(mapping.name);
            }
            const adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              originalMappings.push(adjustedMapping);
            }
          }
        }
      }
      eachMapping(aCallback, aContext, aOrder) {
        const context = aContext || null;
        const order = aOrder || SourceMapConsumer2.GENERATED_ORDER;
        let mappings;
        switch (order) {
          case SourceMapConsumer2.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer2.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        const sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          let source = null;
          if (mapping.source !== null) {
            source = this._sources.at(mapping.source);
            source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          }
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      }
      /**
       * Find the mapping that best matches the hypothetical "needle" mapping that
       * we are searching for in the given "haystack" of mappings.
       */
      _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      }
      allGeneratedPositionsFor(aArgs) {
        const line = util.getArg(aArgs, "line");
        const needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        if (needle.originalLine < 1) {
          throw new Error("Line numbers must be >= 1");
        }
        if (needle.originalColumn < 0) {
          throw new Error("Column numbers must be >= 0");
        }
        const mappings = [];
        let index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          let mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            const originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              let lastColumn = mapping.lastGeneratedColumn;
              if (this._computedColumnSpans && lastColumn === null) {
                lastColumn = Infinity;
              }
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            const originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              let lastColumn = mapping.lastGeneratedColumn;
              if (this._computedColumnSpans && lastColumn === null) {
                lastColumn = Infinity;
              }
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      }
      destroy() {
        for (let i = 0; i < this._sections.length; i++) {
          this._sections[i].consumer.destroy();
        }
      }
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    function _factory(aSourceMap, aSourceMapURL) {
      let sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      const consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      return Promise.resolve(consumer);
    }
    function _factoryBSM(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    }
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/lib/source-node.js"(exports2) {
    var SourceMapGenerator2 = require_source_map_generator().SourceMapGenerator;
    var util = require_util3();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    var SourceNode = class _SourceNode {
      constructor(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null) this.add(aChunks);
      }
      /**
       * Creates a SourceNode from generated code and a SourceMapConsumer.
       *
       * @param aGeneratedCode The generated code
       * @param aSourceMapConsumer The SourceMap for the generated code
       * @param aRelativePath Optional. The path that relative sources in the
       *        SourceMapConsumer should be relative to.
       */
      static fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        const node = new _SourceNode();
        const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        let remainingLinesIndex = 0;
        const shiftNextLine = function() {
          const lineContents = getNextLine();
          const newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        let lastGeneratedLine = 1, lastGeneratedColumn = 0;
        let lastMapping = null;
        let nextLine;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              nextLine = remainingLines[remainingLinesIndex] || "";
              const code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          const content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            const source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new _SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      }
      /**
       * Add a chunk of generated JS to this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      /**
       * Add a chunk of generated JS to the beginning of this source node.
       *
       * @param aChunk A string snippet of generated JS code, another instance of
       *        SourceNode, or an array where each member is one of those things.
       */
      prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (let i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      }
      /**
       * Walk over the tree of JS snippets in this node and its children. The
       * walking function is called once for each snippet of JS and is passed that
       * snippet and the its original associated source's line/column location.
       *
       * @param aFn The traversal function.
       */
      walk(aFn) {
        let chunk;
        for (let i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
      /**
       * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
       * each of `this.children`.
       *
       * @param aSep The separator.
       */
      join(aSep) {
        let newChildren;
        let i;
        const len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      }
      /**
       * Call String.prototype.replace on the very right-most source snippet. Useful
       * for trimming whitespace from the end of a source node, etc.
       *
       * @param aPattern The pattern to replace.
       * @param aReplacement The thing to replace the pattern with.
       */
      replaceRight(aPattern, aReplacement) {
        const lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      }
      /**
       * Set the source content for a source file. This will be added to the SourceMapGenerator
       * in the sourcesContent field.
       *
       * @param aSourceFile The filename of the source file
       * @param aSourceContent The content of the source file
       */
      setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      }
      /**
       * Walk over the tree of SourceNodes. The walking function is called for each
       * source file content and is passed the filename and source content.
       *
       * @param aFn The traversal function.
       */
      walkSourceContents(aFn) {
        for (let i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        const sources = Object.keys(this.sourceContents);
        for (let i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      }
      /**
       * Return the string representation of this source node. Walks over the tree
       * and concatenates all the various snippets together to one string.
       */
      toString() {
        let str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      }
      /**
       * Returns the string representation of this source node along with a source
       * map.
       */
      toStringWithSourceMap(aArgs) {
        const generated = {
          code: "",
          line: 1,
          column: 0
        };
        const map = new SourceMapGenerator2(aArgs);
        let sourceMappingActive = false;
        let lastOriginalSource = null;
        let lastOriginalLine = null;
        let lastOriginalColumn = null;
        let lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (let idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map };
      }
    };
    exports2.SourceNode = SourceNode;
  }
});

// ../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/source-map.js
var require_source_map = __commonJS2({
  "../../node_modules/.pnpm/source-map@0.7.4/node_modules/source-map/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS2({
  "../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/.pnpm/convert-source-map@1.8.0/node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS2({
  "../../node_modules/.pnpm/convert-source-map@1.8.0/node_modules/convert-source-map/index.js"(exports2) {
    "use strict";
    var fs4 = require("fs");
    var path3 = require("path");
    var SafeBuffer = require_safe_buffer2();
    Object.defineProperty(exports2, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports2, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });
    function decodeBase64(base64) {
      return (SafeBuffer.Buffer.from(base64, "base64") || "").toString();
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, dir) {
      var r = exports2.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path3.resolve(dir, filename);
      try {
        return fs4.readFileSync(filepath, "utf8");
      } catch (e) {
        throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment) sm = stripComment(sm);
      if (opts.isEncoded) sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    Converter.prototype.toBase64 = function() {
      var json = this.toJSON();
      return (SafeBuffer.Buffer.from(json, "utf8") || "").toString("base64");
    };
    Converter.prototype.toComment = function(options) {
      var base64 = this.toBase64();
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value);
    };
    Converter.prototype.setProperty = function(key, value) {
      this.sourcemap[key] = value;
      return this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports2.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports2.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports2.fromBase64 = function(base64) {
      return new Converter(base64, { isEncoded: true });
    };
    exports2.fromComment = function(comment) {
      comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      return new Converter(comment, { isEncoded: true, hasComment: true });
    };
    exports2.fromMapFileComment = function(comment, dir) {
      return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
    };
    exports2.fromSource = function(content) {
      var m = content.match(exports2.commentRegex);
      return m ? exports2.fromComment(m.pop()) : null;
    };
    exports2.fromMapFileSource = function(content, dir) {
      var m = content.match(exports2.mapFileCommentRegex);
      return m ? exports2.fromMapFileComment(m.pop(), dir) : null;
    };
    exports2.removeComments = function(src) {
      return src.replace(exports2.commentRegex, "");
    };
    exports2.removeMapFileComments = function(src) {
      return src.replace(exports2.mapFileCommentRegex, "");
    };
    exports2.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// src/index.ts
var import_promises3 = __toESM2(require("node:fs/promises"));
var import_node_path3 = __toESM2(require("node:path"));

// src/pretty-bytes.ts
var import_bytes = __toESM2(require_bytes());
var prettyBytes = (n) => (0, import_bytes.default)(n, { unitSeparator: " " });

// src/constants.ts
var MAX_AGE_ONE_YEAR = 31536e3;
var EDGE_FUNCTION_SIZE_LIMIT = 1024 * 1024;
var INTERNAL_PAGES = ["_app", "_error", "_document"];

// src/utils.ts
var import_picomatch = __toESM2(require_picomatch2());
function getImagesConfig(config) {
  const images = config.images || {};
  const remotePatterns = (images.remotePatterns || []).map((p) => ({
    protocol: p.protocol?.replace(/:$/, ""),
    hostname: (0, import_picomatch.makeRe)(p.hostname).source,
    port: p.port,
    pathname: (0, import_picomatch.makeRe)(p.pathname ?? "**", { dot: true }).source,
    search: p.search
  }));
  const localPatterns = images.localPatterns?.map((p) => ({
    pathname: (0, import_picomatch.makeRe)(p.pathname ?? "**", { dot: true }).source,
    search: p.search
  }));
  return {
    localPatterns,
    remotePatterns,
    sizes: [...images.imageSizes || [], ...images.deviceSizes || []],
    domains: images.domains || [],
    qualities: images.qualities,
    minimumCacheTTL: images.minimumCacheTTL,
    formats: images.formats,
    dangerouslyAllowSVG: images.dangerouslyAllowSVG,
    contentSecurityPolicy: images.contentSecurityPolicy,
    contentDispositionType: images.contentDispositionType
  };
}
var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
function escapeStringRegexp(str) {
  return str.replace(matchOperatorsRegex, "\\$&");
}

// src/routing.ts
function modifyWithRewriteHeaders(rewrites, {
  isAfterFilesRewrite = false,
  shouldHandlePrefetchRsc,
  shouldHandleSegmentPrefetches
}) {
  for (let i = 0; i < rewrites.length; i++) {
    const rewrite = rewrites[i];
    if (!rewrite.src || !rewrite.dest) continue;
    let protocol = null;
    if (rewrite.dest.startsWith("http://")) {
      protocol = "http://";
    } else if (rewrite.dest.startsWith("https://")) {
      protocol = "https://";
    }
    let pathname = null;
    let query = null;
    if (!protocol) {
      pathname = rewrite.dest;
      let index = pathname.indexOf("?");
      if (index !== -1) {
        query = pathname.substring(index + 1);
        pathname = pathname.substring(0, index);
        index = query.indexOf("#");
        if (index !== -1) {
          query = query.substring(0, index);
        }
      } else {
        index = pathname.indexOf("#");
        if (index !== -1) {
          pathname = pathname.substring(0, index);
        }
      }
    }
    if (isAfterFilesRewrite) {
      const parts = ["\\.rsc"];
      if (shouldHandlePrefetchRsc) {
        parts.push("\\.prefetch\\.rsc");
      }
      if (shouldHandleSegmentPrefetches) {
        parts.push("\\.segments/.+\\.segment\\.rsc");
      }
      const rscSuffix = parts.join("|");
      rewrite.src = rewrite.src.replace(
        /(\\\/(\?)?)?\(\?:\\\/\)\?\$$/,
        `(?:/)?(?<rscsuff>${rscSuffix})?`
      );
      const destQueryIndex = rewrite.dest.indexOf("?");
      if (destQueryIndex === -1) {
        rewrite.dest = `${rewrite.dest}$rscsuff`;
      } else {
        rewrite.dest = `${rewrite.dest.substring(
          0,
          destQueryIndex
        )}$rscsuff${rewrite.dest.substring(destQueryIndex)}`;
      }
    }
    if (protocol || !pathname && !query) continue;
    rewrite.headers = {
      ...rewrite.headers,
      ...pathname ? {
        ["x-nextjs-rewritten-path"]: pathname
      } : {},
      ...query ? {
        ["x-nextjs-rewritten-query"]: query
      } : {}
    };
  }
}
function normalizeRewrites(rewrites) {
  const normalize = (item) => ({
    src: item.sourceRegex,
    dest: item.destination,
    has: item.has,
    missing: item.missing,
    check: true
  });
  return {
    beforeFiles: rewrites.beforeFiles.map((item) => {
      const route = normalize(item);
      delete route.check;
      route.continue = true;
      route.override = true;
      return route;
    }),
    afterFiles: rewrites.afterFiles.map(normalize),
    fallback: rewrites.fallback.map(normalize)
  };
}
function normalizeNextDataRoutes(config, buildId, shouldHandleMiddlewareDataResolving, isOverride = false) {
  if (!shouldHandleMiddlewareDataResolving) return [];
  const path3 = require("node:path");
  const basePath = config.basePath || "";
  const trailingSlash = config.trailingSlash || false;
  return [
    // ensure x-nextjs-data header is always present if we are doing middleware next data resolving
    {
      src: path3.posix.join("/", basePath, "/_next/data/(.*)"),
      missing: [
        {
          type: "header",
          key: "x-nextjs-data"
        }
      ],
      transforms: [
        {
          type: "request.headers",
          op: "append",
          target: {
            key: "x-nextjs-data"
          },
          args: "1"
        }
      ],
      continue: true
    },
    // strip _next/data prefix for resolving
    {
      src: `^${path3.posix.join(
        "/",
        basePath,
        "/_next/data/",
        buildId.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"),
        "/(.*).json"
      )}`,
      dest: `${path3.posix.join(
        "/",
        basePath,
        "/$1",
        trailingSlash ? "/" : ""
      )}`,
      ...isOverride ? { override: true } : {},
      continue: true,
      has: [
        {
          type: "header",
          key: "x-nextjs-data"
        }
      ]
    },
    // normalize "/index" from "/_next/data/index.json" to -> just "/"
    {
      src: path3.posix.join("^/", basePath, "/index(?:/)?"),
      has: [
        {
          type: "header",
          key: "x-nextjs-data"
        }
      ],
      dest: path3.posix.join("/", basePath, trailingSlash ? "/" : ""),
      ...isOverride ? { override: true } : {},
      continue: true
    }
  ];
}
function denormalizeNextDataRoutes(config, buildId, shouldHandleMiddlewareDataResolving, isOverride = false) {
  if (!shouldHandleMiddlewareDataResolving) return [];
  const path3 = require("node:path");
  const basePath = config.basePath || "";
  const trailingSlash = config.trailingSlash || false;
  return [
    {
      src: path3.posix.join(
        "^/",
        basePath && basePath !== "/" ? `${basePath}${trailingSlash ? "/$" : "$"}` : "$"
      ),
      has: [
        {
          type: "header",
          key: "x-nextjs-data"
        }
      ],
      dest: `${path3.posix.join(
        "/",
        basePath,
        "/_next/data/",
        buildId,
        "/index.json"
      )}`,
      continue: true,
      ...isOverride ? { override: true } : {}
    },
    {
      src: path3.posix.join("^/", basePath, "((?!_next/)(?:.*[^/]|.*))/?$"),
      has: [
        {
          type: "header",
          key: "x-nextjs-data"
        }
      ],
      dest: `${path3.posix.join(
        "/",
        basePath,
        "/_next/data/",
        buildId,
        "/$1.json"
      )}`,
      continue: true,
      ...isOverride ? { override: true } : {}
    }
  ];
}

// src/outputs.ts
var import_node_path2 = __toESM2(require("node:path"));
var import_promises2 = __toESM2(require("node:fs/promises"));
var import_fs_extra12 = __toESM2(require_lib6());
var import_async_sema5 = __toESM2(require_lib7());
var import_node_handler = require("./node-handler");
var import_build_utils = __toESM2(require_dist2());
var import_constants2 = __toESM2(require_constants2());

// src/get-edge-function-source.ts
var import_fs_extra11 = __toESM2(require_lib6());
var import_webpack_sources2 = __toESM2(require_lib8());

// src/sourcemapped.ts
var import_source_map = __toESM2(require_source_map());
var import_convert_source_map = __toESM2(require_convert_source_map());
var import_fs_extra10 = __toESM2(require_lib6());
var import_webpack_sources = __toESM2(require_lib8());
function sourcemapped(strings, ...sources) {
  const concat = new import_webpack_sources.ConcatSource();
  for (let i = 0; i < Math.max(strings.length, sources.length); i++) {
    const string = strings[i];
    const source = sources[i];
    if (string) concat.add(raw(string));
    if (source) concat.add(source);
  }
  return concat;
}
function raw(value) {
  return new import_webpack_sources.OriginalSource(value, "[native code]");
}
async function fileToSource(content, sourceName, fullFilePath) {
  const sourcemap = await getSourceMap(content, fullFilePath);
  const cleanContent = removeInlinedSourceMap(content);
  return sourcemap ? new import_webpack_sources.SourceMapSource(cleanContent, sourceName, sourcemap) : new import_webpack_sources.OriginalSource(cleanContent, sourceName);
}
async function getSourceMap(content, fullFilePath) {
  let map;
  try {
    if (fullFilePath && await import_fs_extra10.default.pathExists(`${fullFilePath}.map`)) {
      const mapJson = await import_fs_extra10.default.readFile(`${fullFilePath}.map`, "utf8");
      map = import_convert_source_map.default.fromJSON(mapJson).toObject();
    } else {
      map = import_convert_source_map.default.fromComment(content).toObject();
    }
  } catch {
    return null;
  }
  if ("sections" in map) {
    return flattenSourceMap(map);
  }
  return map;
}
async function flattenSourceMap(map) {
  return new import_source_map.SourceMapGenerator(await new import_source_map.SourceMapConsumer(map)).toJSON();
}
var SOURCE_MAP_COMMENT_REGEX = /^\s*?\/[/*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
function isValidSourceMapData(encoding, data) {
  if (encoding !== "base64") {
    return false;
  }
  data = data.replace(/\s/g, "").replace(/\*\//g, "");
  return /^[a-zA-Z0-9+=/]+$/.test(data);
}
function removeInlinedSourceMap(source) {
  for (const m of source.matchAll(SOURCE_MAP_COMMENT_REGEX)) {
    if (!isValidSourceMapData(m[4], m[5])) {
      continue;
    }
    source = source.replace(m[0], "");
  }
  return source;
}

// src/get-edge-function-source.ts
var import_path10 = require("path");
var import_zlib = __toESM2(require("zlib"));
var import_util3 = require("util");

// src/edge-function-template.ts
var template = `var b=Object.create;var p=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var P=Object.getPrototypeOf,L=Object.prototype.hasOwnProperty;var h=e=>p(e,"__esModule",{value:!0});var _=(e,n)=>{h(e);for(var t in n)p(e,t,{get:n[t],enumerable:!0})},U=(e,n,t)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of T(n))!L.call(e,i)&&i!=="default"&&p(e,i,{get:()=>n[i],enumerable:!(t=w(n,i))||t.enumerable});return e},A=e=>U(h(p(e!=null?b(P(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);_(exports,{default:()=>N});var R=A(require("async_hooks")),S="@next/request-context",f=Symbol.for(S),C=Symbol.for("internal.storage");function O(){let e=globalThis;if(!e[f]){let n=new R.AsyncLocalStorage,t={get:()=>n.getStore(),[C]:n};e[f]=t}return e[f]}var q=O();function m(e,n){return q[C].run(e,n)}function y(e){let n={};return e&&e.forEach((t,i)=>{n[i]=t,i.toLowerCase()==="set-cookie"&&(n[i]=M(t))}),n}function M(e){let n=[],t=0,i,a,g,o,r;function x(){for(;t<e.length&&/\\s/.test(e.charAt(t));)t+=1;return t<e.length}function s(){return a=e.charAt(t),a!=="="&&a!==";"&&a!==","}for(;t<e.length;){for(i=t,r=!1;x();)if(a=e.charAt(t),a===","){for(g=t,t+=1,x(),o=t;t<e.length&&s();)t+=1;t<e.length&&e.charAt(t)==="="?(r=!0,t=o,n.push(e.substring(i,g)),i=t):t=g+1}else t+=1;(!r||t>=e.length)&&n.push(e.substring(i,e.length))}return n}function N(e){let n=e.staticRoutes.map(i=>({regexp:new RegExp(i.namedRegex),page:i.page})),t=e.dynamicRoutes?.map(i=>({regexp:new RegExp(i.namedRegex),page:i.page}))||[];return async function(a,g){let o=new URL(a.url).pathname,r={};if(e.nextConfig?.basePath&&o.startsWith(e.nextConfig.basePath)&&(o=o.replace(e.nextConfig.basePath,"")||"/"),e.nextConfig?.i18n)for(let s of e.nextConfig.i18n.locales){let u=new RegExp(\`^/\${s}($|/)\`,"i");if(o.match(u)){o=o.replace(u,"/")||"/";break}}for(let s of n)if(s.regexp.exec(o)){r.name=s.page;break}if(!r.name){let s=E(o);for(let u of t||[]){if(s&&!E(u.page))continue;let d=u.regexp.exec(o);if(d){r={name:u.page,params:d.groups};break}}}let x=await m({waitUntil:g.waitUntil},()=>_ENTRIES[\`middleware_\${e.name}\`].default.call({},{request:{url:a.url,method:a.method,headers:y(a.headers),ip:c(a.headers,l.Ip),geo:{city:c(a.headers,l.City,!0),country:c(a.headers,l.Country,!0),latitude:c(a.headers,l.Latitude),longitude:c(a.headers,l.Longitude),region:c(a.headers,l.Region,!0)},nextConfig:e.nextConfig,page:r,body:a.body}}));return x.waitUntil&&g.waitUntil(x.waitUntil),x.response}}function c(e,n,t=!1){let i=e.get(n)||void 0;return t&&i?decodeURIComponent(i):i}function E(e){return e==="/api"||e.startsWith("/api/")}var l;(function(o){o.City="x-vercel-ip-city",o.Country="x-vercel-ip-country",o.Ip="x-real-ip",o.Latitude="x-vercel-ip-latitude",o.Longitude="x-vercel-ip-longitude",o.Region="x-vercel-ip-country-region"})(l||(l={}));`;

// src/get-edge-function-source.ts
var gzip = (0, import_util3.promisify)(import_zlib.default.gzip);
async function getNextjsEdgeFunctionSource(filePaths, params, outputDir, wasm) {
  const chunks = new import_webpack_sources2.ConcatSource(raw(`globalThis._ENTRIES = {};`));
  for (const filePath of filePaths) {
    const fullFilePath = (0, import_path10.join)(outputDir, filePath);
    const content = await (0, import_fs_extra11.readFile)(fullFilePath, "utf8");
    chunks.add(raw(`
/**/;`));
    chunks.add(await fileToSource(content, filePath, fullFilePath));
  }
  const text = chunks.source();
  const wasmFiles = Object.values(wasm || {});
  await validateSize(text, wasmFiles);
  const getPageMatchCode = `(function () {
    const module = { exports: {}, loaded: false };
    const fn = (function(module,exports) {${template}
});
    fn(module, module.exports);
    return module.exports;
  })`;
  return sourcemapped`
  ${raw(getWasmImportStatements(wasm || {}))}
  ${chunks};
  export default ${raw(getPageMatchCode)}.call({}).default(
    ${raw(JSON.stringify(params))}
  )`;
}
function getWasmImportStatements(wasm) {
  return Object.entries(wasm).filter(([name]) => name.startsWith("wasm_")).map(([name]) => {
    const pathname = `/wasm/${name}.wasm`;
    return `const ${name} = require(${JSON.stringify(pathname)});`;
  }).join("\n");
}
async function validateSize(script, wasmFiles) {
  const buffers = [Buffer.from(script, "utf8")];
  for (const filePath of wasmFiles) {
    buffers.push(await (0, import_fs_extra11.readFile)(filePath));
  }
  const content = Buffer.concat(buffers);
  const gzipped = await gzip(content);
  if (gzipped.length > EDGE_FUNCTION_SIZE_LIMIT) {
    throw new Error(
      `Exceeds maximum edge function size: ${prettyBytes(
        gzipped.length
      )} / ${prettyBytes(EDGE_FUNCTION_SIZE_LIMIT)}`
    );
  }
}

// src/outputs.ts
var copy = async (src, dest) => {
  await import_fs_extra12.default.remove(dest);
  await import_fs_extra12.default.copy(src, dest);
};
var writeLock = /* @__PURE__ */ new Map();
var writeIfNotExists = async (filePath, content) => {
  await writeLock.get(filePath);
  const writePromise = import_promises2.default.writeFile(filePath, content, { flag: "wx" }).catch((err) => {
    if (err.code === "EEXIST") return;
    throw err;
  }).finally(() => writeLock.delete(filePath));
  writeLock.set(filePath, writePromise);
  return writePromise;
};
async function handlePublicFiles(publicFolder, vercelOutputDir, config) {
  const topLevelItems = await import_promises2.default.readdir(publicFolder).catch(() => []);
  const fsSema = new import_async_sema5.Sema(16, { capacity: topLevelItems.length });
  await Promise.all(
    topLevelItems.map(async (item) => {
      await fsSema.acquire();
      const destination = import_node_path2.default.join(
        vercelOutputDir,
        "static",
        config.basePath || "",
        item
      );
      const destDirectory = import_node_path2.default.dirname(destination);
      await import_promises2.default.mkdir(destDirectory, { recursive: true });
      await copy(import_node_path2.default.join(publicFolder, item), destination);
      fsSema.release();
    })
  );
}
async function handleStaticOutputs(outputs, {
  config,
  vercelConfig: vercelConfig2,
  vercelOutputDir
}) {
  const fsSema = new import_async_sema5.Sema(16, { capacity: outputs.length });
  await Promise.all(
    outputs.map(async (output) => {
      await fsSema.acquire();
      const srcExtension = import_node_path2.default.extname(output.filePath);
      const isHtml = srcExtension === ".html";
      if (isHtml) {
        vercelConfig2.overrides[import_node_path2.default.posix.join("./", output.pathname + ".html")] = {
          contentType: "text/html; charset=utf-8",
          path: import_node_path2.default.posix.join("./", output.pathname)
        };
      }
      const destination = import_node_path2.default.join(
        vercelOutputDir,
        "static",
        output.pathname + (isHtml ? ".html" : "")
      );
      const destDirectory = import_node_path2.default.dirname(destination);
      await import_promises2.default.mkdir(destDirectory, { recursive: true });
      await copy(output.filePath, destination);
      fsSema.release();
    })
  );
  await import_promises2.default.writeFile(
    import_node_path2.default.posix.join(
      vercelOutputDir,
      "static",
      config.basePath || "",
      "_next/static/not-found.txt"
    ),
    "Not Found"
  );
}
var vercelConfig = JSON.parse(process.env.NEXT_ADAPTER_VERCEL_CONFIG || "{}");
async function handleNodeOutputs(nodeOutputs, {
  config,
  distDir,
  repoRoot,
  projectDir,
  nextVersion,
  isMiddleware,
  prerenderFallbackFalseMap,
  vercelOutputDir
}) {
  const nodeVersion = await (0, import_build_utils.getNodeVersion)(projectDir, void 0, {}, {});
  const fsSema = new import_async_sema5.Sema(16, { capacity: nodeOutputs.length });
  const functionsDir = import_node_path2.default.join(vercelOutputDir, "functions");
  const handlerRelativeDir = import_node_path2.default.posix.relative(repoRoot, projectDir);
  let pages404Output;
  let pagesErrorOutput;
  for (const item of nodeOutputs) {
    if (item.pathname === import_node_path2.default.posix.join("/", config.basePath || "", "/404")) {
      pages404Output = item;
    }
    if (item.pathname === import_node_path2.default.posix.join("/", config.basePath || "", "/_error")) {
      pagesErrorOutput = item;
    }
    if (pages404Output && pagesErrorOutput) {
      break;
    }
  }
  await Promise.all(
    nodeOutputs.map(async (output) => {
      await fsSema.acquire();
      const functionDir = import_node_path2.default.join(
        functionsDir,
        `${output.pathname === "/" ? "/index" : output.pathname}.func`
      );
      await import_promises2.default.mkdir(functionDir, { recursive: true });
      const files = {};
      for (const [relPath, fsPath] of Object.entries(output.assets)) {
        files[relPath] = import_node_path2.default.posix.relative(repoRoot, fsPath);
      }
      files[import_node_path2.default.posix.relative(repoRoot, output.filePath)] = import_node_path2.default.posix.relative(repoRoot, output.filePath);
      if (output.type === import_constants2.AdapterOutputType.PAGES) {
        const notFoundOutput = pages404Output || pagesErrorOutput;
        if (notFoundOutput) {
          for (const [relPath, fsPath] of Object.entries(
            notFoundOutput.assets
          )) {
            files[relPath] = import_node_path2.default.posix.relative(repoRoot, fsPath);
          }
          files[import_node_path2.default.posix.relative(repoRoot, notFoundOutput.filePath)] = import_node_path2.default.posix.relative(repoRoot, notFoundOutput.filePath);
        }
      }
      const handlerFilePath = import_node_path2.default.join(
        functionDir,
        handlerRelativeDir,
        "___next_launcher.cjs"
      );
      await import_promises2.default.mkdir(import_node_path2.default.dirname(handlerFilePath), { recursive: true });
      await writeIfNotExists(
        handlerFilePath,
        (0, import_node_handler.getHandlerSource)({
          projectRelativeDistDir: import_node_path2.default.posix.relative(projectDir, distDir),
          prerenderFallbackFalseMap,
          isMiddleware,
          nextConfig: config
        })
      );
      const operationType = output.type === import_constants2.AdapterOutputType.APP_PAGE || import_constants2.AdapterOutputType.PAGES ? "PAGE" : "API";
      const sourceFile = await getSourceFilePathFromPage({
        workPath: projectDir,
        page: output.sourcePage,
        pageExtensions: config.pageExtensions || []
      });
      const vercelConfigOpts = await (0, import_build_utils.getLambdaOptionsFromFunction)({
        sourceFile,
        config: vercelConfig
      });
      await writeIfNotExists(
        import_node_path2.default.join(functionDir, `.vc-config.json`),
        JSON.stringify(
          // TODO: strongly type this
          {
            ...vercelConfigOpts,
            filePathMap: files,
            operationType,
            framework: {
              slug: "nextjs",
              version: nextVersion
            },
            handler: import_node_path2.default.posix.join(
              import_node_path2.default.posix.relative(repoRoot, projectDir),
              "___next_launcher.cjs"
            ),
            runtime: nodeVersion.runtime,
            maxDuration: output.config.maxDuration,
            supportsResponseStreaming: true,
            experimentalAllowBundling: true,
            // middleware handler always expects Request/Response interface
            useWebApi: isMiddleware,
            launcherType: "Nodejs"
          }
        )
      );
      fsSema.release();
    })
  );
}
async function handlePrerenderOutputs(prerenderOutputs, {
  vercelOutputDir,
  nodeOutputsParentMap
}) {
  const prerenderParentIds = /* @__PURE__ */ new Set();
  const fsSema = new import_async_sema5.Sema(16, { capacity: prerenderOutputs.length });
  const functionsDir = import_node_path2.default.join(vercelOutputDir, "functions");
  await Promise.all(
    prerenderOutputs.map(async (output) => {
      await fsSema.acquire();
      try {
        const prerenderConfigPath = import_node_path2.default.join(
          functionsDir,
          `${output.pathname === "/" ? "/index" : output.pathname}.prerender-config.json`
        );
        const prerenderFallbackPath = output.fallback?.filePath ? import_node_path2.default.join(
          functionsDir,
          `${output.pathname === "/" ? "/index" : output.pathname}.prerender-fallback${import_node_path2.default.extname(output.fallback.filePath)}`
        ) : void 0;
        const { parentOutputId } = output;
        prerenderParentIds.add(parentOutputId);
        const parentNodeOutput = nodeOutputsParentMap.get(parentOutputId);
        if (!parentNodeOutput) {
          throw new Error(
            `Invariant: failed to find parent node output ${output.parentOutputId} for prerender output ${output.pathname}`
          );
        }
        const clonedNodeOutput = Object.assign({}, parentNodeOutput);
        clonedNodeOutput.pathname = output.pathname;
        const parentFunctionDir = import_node_path2.default.join(
          functionsDir,
          `${parentNodeOutput.pathname === "/" ? "/index" : parentNodeOutput.pathname}.func`
        );
        const prerenderFunctionDir = import_node_path2.default.join(
          functionsDir,
          `${output.pathname === "/" ? "/index" : output.pathname}.func`
        );
        if (output.pathname !== parentNodeOutput.pathname) {
          await import_promises2.default.mkdir(import_node_path2.default.dirname(prerenderFunctionDir), {
            recursive: true
          });
          await import_promises2.default.symlink(
            import_node_path2.default.relative(
              import_node_path2.default.dirname(prerenderFunctionDir),
              parentFunctionDir
            ),
            prerenderFunctionDir
          ).catch((err) => {
            if (!(typeof err === "object" && err && err.code === "EEXIST")) {
              throw err;
            }
          });
        }
        const initialHeaders = Object.assign(
          {},
          output.fallback?.initialHeaders
        );
        if (output.fallback?.postponedState && output.fallback.filePath && prerenderFallbackPath) {
          const fallbackHtml = await import_promises2.default.readFile(
            output.fallback.filePath,
            "utf8"
          );
          await writeIfNotExists(
            prerenderFallbackPath,
            `${output.fallback.postponedState}${fallbackHtml}`
          );
          initialHeaders["content-type"] = `application/x-nextjs-pre-render; state-length=${output.fallback.postponedState.length}; origin="text/html; charset=utf-8"`;
        }
        await import_promises2.default.mkdir(import_node_path2.default.dirname(prerenderConfigPath), { recursive: true });
        await writeIfNotExists(
          prerenderConfigPath,
          JSON.stringify(
            // TODO: strongly type this
            {
              group: output.groupId,
              expiration: typeof output.fallback?.initialRevalidate !== "undefined" ? output.fallback?.initialRevalidate : 1,
              staleExpiration: output.fallback?.initialExpiration,
              sourcePath: parentNodeOutput?.pathname,
              // send matches in query instead of x-now-route-matches
              // legacy header
              passQuery: true,
              allowQuery: output.config.allowQuery,
              allowHeader: output.config.allowHeader,
              bypassToken: output.config.bypassToken,
              experimentalBypassFor: output.config.bypassFor,
              initialHeaders,
              initialStatus: output.fallback?.initialStatus,
              fallback: prerenderFallbackPath ? import_node_path2.default.posix.relative(
                import_node_path2.default.dirname(prerenderConfigPath),
                prerenderFallbackPath
              ) : void 0,
              chain: output.pprChain ? {
                ...output.pprChain,
                outputPath: import_node_path2.default.posix.join(parentNodeOutput.pathname)
              } : void 0
            }
          )
        );
        if (output.fallback?.filePath && prerenderFallbackPath && // if postponed state is present we write the fallback file above
        !output.fallback.postponedState) {
          await copy(output.fallback.filePath, prerenderFallbackPath);
        }
      } catch (err) {
        console.error(`Failed to handle output:`, output);
        throw err;
      }
      fsSema.release();
    })
  );
}
async function handleEdgeOutputs(edgeOutputs, {
  config,
  distDir,
  repoRoot,
  projectDir,
  nextVersion,
  vercelOutputDir
}) {
  const fsSema = new import_async_sema5.Sema(16, { capacity: edgeOutputs.length });
  const functionsDir = import_node_path2.default.join(vercelOutputDir, "functions");
  const handlerRelativeDir = import_node_path2.default.posix.relative(repoRoot, projectDir);
  await Promise.all(
    edgeOutputs.map(async (output) => {
      await fsSema.acquire();
      const functionDir = import_node_path2.default.join(
        functionsDir,
        `${output.pathname === "/" ? "index" : output.pathname}.func`
      );
      await import_promises2.default.mkdir(functionDir, { recursive: true });
      const files = {};
      const jsRegex = /\.(m|c)?js$/;
      const nonJsAssetFiles = [];
      for (const [relPath, fsPath] of Object.entries(output.assets)) {
        if (jsRegex.test(fsPath)) {
          files[relPath] = import_node_path2.default.posix.relative(repoRoot, fsPath);
        } else {
          const assetPath = import_node_path2.default.posix.join("assets", relPath);
          files[assetPath] = import_node_path2.default.posix.relative(repoRoot, fsPath);
          nonJsAssetFiles.push({
            name: relPath,
            path: assetPath
          });
        }
      }
      for (const [name, fsPath] of Object.entries(output.wasmAssets || {})) {
        files[`wasm/${name}.wasm`] = import_node_path2.default.posix.relative(repoRoot, fsPath);
      }
      files[import_node_path2.default.posix.relative(projectDir, output.filePath)] = import_node_path2.default.posix.relative(repoRoot, output.filePath);
      const filePaths = [
        import_node_path2.default.posix.relative(projectDir, output.filePath),
        ...Object.values(output.assets).map((item) => import_node_path2.default.posix.relative(projectDir, item)).filter((item) => jsRegex.test(item))
      ];
      const params = {
        name: output.id.replace(/\.rsc$/, ""),
        staticRoutes: [],
        dynamicRoutes: [],
        nextConfig: {
          basePath: config.basePath,
          i18n: config.i18n
        }
      };
      const edgeSourceObj = await getNextjsEdgeFunctionSource(
        filePaths,
        params,
        projectDir,
        output.wasmAssets
      );
      const edgeSource = edgeSourceObj.source();
      const handlerFilePath = import_node_path2.default.join(
        functionDir,
        handlerRelativeDir,
        "index.js"
      );
      await import_promises2.default.mkdir(import_node_path2.default.dirname(handlerFilePath), { recursive: true });
      await writeIfNotExists(handlerFilePath, edgeSource.toString());
      const edgeConfig = {
        runtime: "edge",
        name: params.name,
        entrypoint: import_node_path2.default.posix.join(
          import_node_path2.default.posix.relative(repoRoot, projectDir),
          "index.js"
        ),
        filePathMap: files,
        assets: nonJsAssetFiles,
        deploymentTarget: "v8-worker",
        environment: output.config.env || {},
        regions: output.config.preferredRegion,
        framework: {
          slug: "nextjs",
          version: nextVersion
        }
      };
      await writeIfNotExists(
        import_node_path2.default.join(functionDir, ".vc-config.json"),
        JSON.stringify(edgeConfig)
      );
      fsSema.release();
    })
  );
}
async function handleMiddleware(output, ctx) {
  if (output.runtime === "nodejs") {
    await handleNodeOutputs([output], {
      ...ctx,
      isMiddleware: true
    });
  } else if (output.runtime === "edge") {
    await handleEdgeOutputs([output], ctx);
  } else {
    throw new Error(`Invalid middleware output ${JSON.stringify(output)}`);
  }
  const routes = [];
  for (const matcher of output.config.matchers || []) {
    const route = {
      continue: true,
      has: matcher.has,
      src: matcher.sourceRegex,
      missing: matcher.missing
    };
    route.middlewarePath = output.pathname;
    route.middlewareRawSrc = matcher.source ? [matcher.source] : [];
    route.override = true;
    routes.push(route);
  }
  return routes;
}
var _usesSrcCache;
async function usesSrcDirectory(workPath) {
  if (!_usesSrcCache) {
    const sourcePages = import_node_path2.default.join(workPath, "src", "pages");
    try {
      if ((await import_promises2.default.stat(sourcePages)).isDirectory()) {
        _usesSrcCache = true;
      }
    } catch (_err) {
      _usesSrcCache = false;
    }
  }
  if (!_usesSrcCache) {
    const sourceAppdir = import_node_path2.default.join(workPath, "src", "app");
    try {
      if ((await import_promises2.default.stat(sourceAppdir)).isDirectory()) {
        _usesSrcCache = true;
      }
    } catch (_err) {
      _usesSrcCache = false;
    }
  }
  return Boolean(_usesSrcCache);
}
function isDirectory2(path3) {
  return import_fs_extra12.default.existsSync(path3) && import_fs_extra12.default.lstatSync(path3).isDirectory();
}
async function getSourceFilePathFromPage({
  workPath,
  page,
  pageExtensions
}) {
  const usesSrcDir = await usesSrcDirectory(workPath);
  const extensionsToTry = pageExtensions || ["js", "jsx", "ts", "tsx"];
  for (const pageType of [
    // middleware is not nested in pages/app
    ...page === "middleware" ? [""] : ["pages", "app"]
  ]) {
    let fsPath = import_node_path2.default.join(workPath, pageType, page);
    if (usesSrcDir) {
      fsPath = import_node_path2.default.join(workPath, "src", pageType, page);
    }
    if (import_fs_extra12.default.existsSync(fsPath)) {
      return import_node_path2.default.relative(workPath, fsPath);
    }
    const extensionless = fsPath;
    for (const ext of extensionsToTry) {
      fsPath = `${extensionless}.${ext}`;
      if (pageType === "app" && extensionless === import_node_path2.default.join(workPath, `${usesSrcDir ? "src/" : ""}app/index`)) {
        fsPath = `${extensionless.replace(/index$/, "page")}.${ext}`;
      }
      if (import_fs_extra12.default.existsSync(fsPath)) {
        return import_node_path2.default.relative(workPath, fsPath);
      }
    }
    if (isDirectory2(extensionless)) {
      if (pageType === "pages") {
        for (const ext of extensionsToTry) {
          fsPath = import_node_path2.default.join(extensionless, `index.${ext}`);
          if (import_fs_extra12.default.existsSync(fsPath)) {
            return import_node_path2.default.relative(workPath, fsPath);
          }
        }
      } else {
        for (const ext of extensionsToTry) {
          fsPath = import_node_path2.default.join(extensionless, `page.${ext}`);
          if (import_fs_extra12.default.existsSync(fsPath)) {
            return import_node_path2.default.relative(workPath, fsPath);
          }
          fsPath = import_node_path2.default.join(extensionless, `route.${ext}`);
          if (import_fs_extra12.default.existsSync(fsPath)) {
            return import_node_path2.default.relative(workPath, fsPath);
          }
        }
      }
    }
  }
  if (page === "/_not-found/page") {
    return "";
  }
  if (page === "/_global-error/page") {
    return "";
  }
  if (!INTERNAL_PAGES.includes(page)) {
    console.log(
      `WARNING: Unable to find source file for page ${page} with extensions: ${extensionsToTry.join(
        ", "
      )}, this can cause functions config from \`vercel.json\` to not be applied`
    );
  }
  return "";
}

// src/index.ts
var myAdapter = {
  name: "Vercel",
  async onBuildComplete({
    routes,
    config,
    buildId,
    outputs,
    distDir,
    repoRoot,
    projectDir,
    nextVersion
  }) {
    const vercelOutputDir = import_node_path3.default.join(distDir, "output");
    await import_promises3.default.mkdir(vercelOutputDir, { recursive: true });
    const escapedBuildId = escapeStringRegexp(buildId);
    const hasMiddleware = Boolean(outputs.middleware);
    const hasAppDir = outputs.appPages.length > 0 || outputs.appRoutes.length > 0;
    const hasPagesDir = outputs.pages.length > 0 || outputs.pagesApi.length > 0;
    const shouldHandleMiddlewareDataResolving = hasPagesDir && hasMiddleware;
    const i18nConfig = config.i18n;
    const vercelConfig2 = {
      version: 3,
      overrides: {},
      wildcard: i18nConfig?.domains ? i18nConfig.domains.map((item) => {
        return {
          domain: item.domain,
          value: item.defaultLocale === i18nConfig.defaultLocale ? "" : `/${item.defaultLocale}`
        };
      }) : void 0,
      images: getImagesConfig(config)
    };
    await handlePublicFiles(
      import_node_path3.default.join(projectDir, "public"),
      vercelOutputDir,
      config
    );
    await handleStaticOutputs(outputs.staticFiles, {
      config,
      vercelConfig: vercelConfig2,
      vercelOutputDir
    });
    const nodeOutputsParentMap = /* @__PURE__ */ new Map();
    const edgeOutputs = [];
    const nodeOutputs = [];
    let hasNotFoundOutput = false;
    let has404Output = false;
    let has500Output = false;
    for (const output of [
      ...outputs.appPages,
      ...outputs.appRoutes,
      ...outputs.pages,
      ...outputs.pagesApi
    ]) {
      if (output.pathname.endsWith("/_not-found")) {
        hasNotFoundOutput = true;
      }
      if (output.pathname.endsWith("/404")) {
        has404Output = true;
      }
      if (output.pathname.endsWith("/500")) {
        has500Output = true;
      }
      if (output.runtime === "nodejs") {
        nodeOutputsParentMap.set(output.id, output);
        nodeOutputs.push(output);
      } else if (output.runtime === "edge") {
        edgeOutputs.push(output);
      }
    }
    for (const output of outputs.staticFiles) {
      if (output.pathname.endsWith("/_not-found")) {
        hasNotFoundOutput = true;
      }
      if (output.pathname.endsWith("/404")) {
        has404Output = true;
      }
      if (output.pathname.endsWith("/500")) {
        has500Output = true;
      }
    }
    const notFoundPath = hasNotFoundOutput ? "/_not-found" : has404Output ? "/404" : "/_error";
    await handleEdgeOutputs(edgeOutputs, {
      repoRoot,
      projectDir,
      vercelOutputDir,
      nextVersion,
      config,
      distDir
    });
    const prerenderFallbackFalseMap = {};
    for (const prerender of outputs.prerenders) {
      if (prerender.parentFallbackMode === false && !prerender.pathname.includes("_next/data") && !prerender.pathname.endsWith(".rsc")) {
        const parentOutput = nodeOutputsParentMap.get(prerender.parentOutputId);
        if (!parentOutput) {
          throw new Error(
            `Invariant: missing parent output ${prerender.parentOutputId} for prerender ${JSON.stringify(prerender)}`
          );
        }
        const parentPage = parentOutput.pathname.substring(
          config.basePath.length
        );
        let currentMap = prerenderFallbackFalseMap[parentPage];
        if (!currentMap) {
          currentMap = prerenderFallbackFalseMap[parentPage] = [];
        }
        currentMap.push(prerender.pathname.substring(config.basePath.length));
      }
    }
    let middlewareRoutes = [];
    if (outputs.middleware) {
      middlewareRoutes = await handleMiddleware(outputs.middleware, {
        config,
        distDir,
        repoRoot,
        projectDir,
        vercelOutputDir,
        nextVersion,
        prerenderFallbackFalseMap
      });
    }
    await handleNodeOutputs(nodeOutputs, {
      config,
      distDir,
      repoRoot,
      projectDir,
      nextVersion,
      vercelOutputDir,
      prerenderFallbackFalseMap
    });
    await handlePrerenderOutputs(outputs.prerenders, {
      vercelOutputDir,
      nodeOutputsParentMap
    });
    const shouldHandlePrefetchRsc = Boolean(
      config.experimental.cacheComponents
    );
    const shouldHandleSegmentPrefetches = Boolean(
      config.experimental.clientSegmentCache || config.experimental.cacheComponents
    );
    const convertedRewrites = normalizeRewrites(routes.rewrites);
    if (shouldHandlePrefetchRsc || shouldHandleSegmentPrefetches) {
      modifyWithRewriteHeaders(convertedRewrites.beforeFiles, {
        shouldHandlePrefetchRsc,
        shouldHandleSegmentPrefetches
      });
      modifyWithRewriteHeaders(convertedRewrites.afterFiles, {
        isAfterFilesRewrite: true,
        shouldHandlePrefetchRsc,
        shouldHandleSegmentPrefetches
      });
      modifyWithRewriteHeaders(convertedRewrites.fallback, {
        shouldHandlePrefetchRsc,
        shouldHandleSegmentPrefetches
      });
    }
    const priorityRedirects = [];
    const redirects = [];
    for (const redirect of routes.redirects) {
      const route = {
        src: redirect.sourceRegex,
        headers: {
          Location: redirect.destination
        },
        status: redirect.statusCode,
        has: redirect.has,
        missing: redirect.missing
      };
      if (redirect.priority) {
        route.continue = true;
        priorityRedirects.push(route);
      } else {
        redirects.push(route);
      }
    }
    const headers = [];
    for (const route of routes.headers) {
      headers.push({
        src: route.sourceRegex,
        headers: route.headers,
        continue: true,
        has: route.has,
        missing: route.missing,
        ...route.priority ? {
          important: true
        } : {}
      });
    }
    const dynamicRoutes = [];
    let addedNextData404Route = false;
    for (const route of routes.dynamicRoutes) {
      if (hasPagesDir && !hasMiddleware) {
        if (!route.sourceRegex.includes("_next/data") && !addedNextData404Route) {
          addedNextData404Route = true;
          dynamicRoutes.push({
            src: import_node_path3.default.posix.join("/", config.basePath || "", "_next/data/(.*)"),
            dest: import_node_path3.default.posix.join("/", config.basePath || "", "404"),
            status: 404,
            check: true
          });
        }
      }
      dynamicRoutes.push({
        src: route.sourceRegex,
        dest: route.destination,
        check: true,
        has: route.has,
        missing: route.missing
      });
    }
    vercelConfig2.routes = [
      /*
        Desired routes order
        - Runtime headers
        - User headers and redirects
        - Runtime redirects
        - Runtime routes
        - Check filesystem, if nothing found continue
        - User rewrites
        - Builder rewrites
      */
      ...priorityRedirects,
      // normalize _next/data URL before processing redirects
      ...normalizeNextDataRoutes(
        config,
        buildId,
        shouldHandleMiddlewareDataResolving,
        true
      ),
      ...config.i18n ? [
        // Handle auto-adding current default locale to path based on
        // $wildcard
        // This is split into two rules to avoid matching the `/index` route as it causes issues with trailing slash redirect
        {
          src: `^${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?!(?:_next/.*|${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})(?:/.*|$))$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${config.basePath && config.basePath !== "/" ? import_node_path3.default.posix.join("/", config.basePath) : ""}$wildcard${config.trailingSlash ? "/" : ""}`,
          continue: true
        },
        {
          src: `^${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?!(?:_next/.*|${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})(?:/.*|$))(.*)$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${config.basePath && config.basePath !== "/" ? import_node_path3.default.posix.join("/", config.basePath) : ""}$wildcard/$1`,
          continue: true
        },
        // Handle redirecting to locale specific domains
        ...config.i18n.domains && config.i18n.domains.length > 0 && config.i18n.localeDetection !== false ? [
          {
            src: `^${import_node_path3.default.posix.join(
              "/",
              config.basePath
            )}/?(?:${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})?/?$`,
            locale: {
              redirect: config.i18n.domains.reduce(
                (prev, item) => {
                  prev[item.defaultLocale] = `http${item.http ? "" : "s"}://${item.domain}/`;
                  if (item.locales) {
                    item.locales.map((locale) => {
                      prev[locale] = `http${item.http ? "" : "s"}://${item.domain}/${locale}`;
                    });
                  }
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        // Handle redirecting to locale paths
        ...config.i18n.localeDetection !== false ? [
          {
            // TODO: if default locale is included in this src it won't
            // be visitable by users who prefer another language since a
            // cookie isn't set signaling the default locale is
            // preferred on redirect currently, investigate adding this
            src: "/",
            locale: {
              redirect: config.i18n.locales.reduce(
                (prev, locale) => {
                  prev[locale] = locale === config.i18n?.defaultLocale ? `/` : `/${locale}`;
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        // We only want to add these rewrites before user redirects
        // when `skipDefaultLocaleRewrite` is not flagged on
        // and when localeDetection is enabled.
        {
          src: `^${import_node_path3.default.posix.join("/", config.basePath)}$`,
          dest: `${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            config.i18n.defaultLocale
          )}`,
          continue: true
        },
        // Auto-prefix non-locale path with default locale
        // note for prerendered pages this will cause
        // x-now-route-matches to contain the path minus the locale
        // e.g. for /de/posts/[slug] x-now-route-matches would have
        // 1=posts%2Fpost-1
        {
          src: `^${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?!(?:_next/.*|${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})(?:/.*|$))(.*)$`,
          dest: `${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            config.i18n.defaultLocale
          )}/$1`,
          continue: true
        }
      ] : [],
      ...headers,
      ...redirects,
      // server actions name meta routes - placeholder for server actions
      // middleware route - placeholder for middleware configuration
      ...middlewareRoutes,
      ...convertedRewrites.beforeFiles,
      // add 404 handling if /404 or locale variants are requested literally
      ...config.i18n ? [
        {
          src: `${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?:${config.i18n.locales.map((locale) => locale.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|")})?[/]?404/?`,
          status: 404,
          continue: true,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate"
            }
          ]
        }
      ] : [
        {
          src: import_node_path3.default.posix.join("/", config.basePath, "404/?"),
          status: 404,
          continue: true,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate"
            }
          ]
        }
      ],
      // add 500 handling if /500 or locale variants are requested literally
      ...config.i18n ? [
        {
          src: `${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?:${config.i18n.locales.map((locale) => locale.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")).join("|")})?[/]?500/?`,
          status: 500,
          continue: true
        }
      ] : [
        {
          src: import_node_path3.default.posix.join("/", config.basePath, "500/?"),
          status: 500,
          continue: true
        }
      ],
      // denormalize _next/data if middleware + pages
      ...denormalizeNextDataRoutes(
        config,
        buildId,
        shouldHandleMiddlewareDataResolving,
        true
      ),
      // RSC and prefetch request handling for App Router
      ...hasAppDir ? [
        // Full RSC request rewriting
        {
          src: `^${import_node_path3.default.posix.join("/", config.basePath, "/?")}`,
          has: [
            {
              type: "header",
              key: "rsc",
              value: "1"
            }
          ],
          dest: import_node_path3.default.posix.join("/", config.basePath, "/index.rsc"),
          headers: {
            vary: "RSC, Next-Router-State-Tree, Next-Router-Prefetch"
          },
          continue: true,
          override: true
        },
        {
          src: `^${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/((?!.+\\.rsc).+?)(?:/)?$"
          )}`,
          has: [
            {
              type: "header",
              key: "rsc",
              value: "1"
            }
          ],
          dest: import_node_path3.default.posix.join("/", config.basePath, "/$1.rsc"),
          headers: {
            vary: "RSC, Next-Router-State-Tree, Next-Router-Prefetch"
          },
          continue: true,
          override: true
        }
      ] : [],
      { handle: "filesystem" },
      // ensure the basePath prefixed _next/image is rewritten to the root
      // _next/image path
      ...config.basePath ? [
        {
          src: import_node_path3.default.posix.join("/", config.basePath, "_next/image/?"),
          dest: "/_next/image",
          check: true
        }
      ] : [],
      // normalize _next/data if middleware + pages
      ...normalizeNextDataRoutes(
        config,
        buildId,
        shouldHandleMiddlewareDataResolving,
        false
      ),
      ...!hasMiddleware ? [
        // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
        // if no match to prevent rewriting _next/data unexpectedly
        {
          src: import_node_path3.default.posix.join("/", config.basePath, "_next/data/(.*)"),
          dest: import_node_path3.default.posix.join("/", config.basePath, "_next/data/$1"),
          check: true
        }
      ] : [],
      // normalize /index.rsc to just / for App Router
      ...hasAppDir ? [
        {
          src: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/index(\\.action|\\.rsc)"
          ),
          dest: import_node_path3.default.posix.join("/", config.basePath),
          continue: true
        }
      ] : [],
      ...convertedRewrites.afterFiles,
      // ensure bad rewrites with /.rsc are fixed for App Router
      ...hasAppDir ? [
        {
          src: import_node_path3.default.posix.join("/", config.basePath, "/\\.rsc$"),
          dest: import_node_path3.default.posix.join("/", config.basePath, `/index.rsc`),
          check: true
        },
        {
          src: import_node_path3.default.posix.join("/", config.basePath, "(.+)/\\.rsc$"),
          dest: import_node_path3.default.posix.join("/", config.basePath, "$1.rsc"),
          check: true
        }
      ] : [],
      { handle: "resource" },
      ...convertedRewrites.fallback,
      // make sure 404 page is used when a directory is matched without
      // an index page
      { src: import_node_path3.default.posix.join("/", config.basePath, ".*"), status: 404 },
      { handle: "miss" },
      // 404 to plain text file for _next/static
      {
        src: import_node_path3.default.posix.join("/", config.basePath, "_next/static/.+"),
        status: 404,
        check: true,
        dest: import_node_path3.default.posix.join(
          "/",
          config.basePath,
          "_next/static/not-found.txt"
        ),
        headers: {
          "content-type": "text/plain; charset=utf-8"
        }
      },
      // if i18n is enabled attempt removing locale prefix to check public files
      // remove locale prefixes to check public files and
      // to allow checking non-prefixed lambda outputs
      ...config.i18n ? [
        // When `skipDefaultLocaleRewrite` is flagged on and localeDetection is disabled,
        // we only want to add the rewrite as the fallback case once routing is complete.
        ...config.i18n?.localeDetection === false ? [
          {
            src: `^${import_node_path3.default.posix.join("/", config.basePath)}$`,
            dest: `${import_node_path3.default.posix.join(
              "/",
              config.basePath,
              config.i18n.defaultLocale
            )}`,
            check: true
          },
          // Auto-prefix non-locale path with default locale
          // note for prerendered pages this will cause
          // x-now-route-matches to contain the path minus the locale
          // e.g. for /de/posts/[slug] x-now-route-matches would have
          // 1=posts%2Fpost-1
          {
            src: `^${import_node_path3.default.posix.join(
              "/",
              config.basePath,
              "/"
            )}(?!(?:_next/.*|${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})(?:/.*|$))(.*)$`,
            dest: `${import_node_path3.default.posix.join(
              "/",
              config.basePath,
              config.i18n.defaultLocale
            )}/$1`,
            check: true
          }
        ] : [],
        {
          src: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            escapeStringRegexp(config.i18n.defaultLocale)
          ),
          dest: "/",
          check: true
        },
        {
          src: `^${import_node_path3.default.posix.join("/", config.basePath)}/?(?:${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})/(.*)`,
          dest: `${import_node_path3.default.posix.join("/", config.basePath, "/")}$1`,
          check: true
        }
      ] : [],
      // If it didn't match any of the static routes or dynamic ones, then we
      // should fallback to either prefetch or normal RSC request
      ...shouldHandleSegmentPrefetches ? [
        {
          src: "^/(?<path>.+)(?<rscSuffix>\\.segments/.+\\.segment\\.rsc)(?:/)?$",
          dest: `/$path${shouldHandlePrefetchRsc ? ".prefetch.rsc" : ".rsc"}`,
          check: true
        }
      ] : [],
      { handle: "rewrite" },
      // denormalize _next/data if middleware + pages - placeholder
      ...denormalizeNextDataRoutes(
        config,
        buildId,
        shouldHandleMiddlewareDataResolving,
        false
      ),
      // apply _next/data routes (including static ones if middleware + pages)
      // This would require the data routes from the Next.js build manifest
      // apply normal dynamic routes
      ...dynamicRoutes,
      // apply x-nextjs-matched-path header and __next_data_catchall rewrite
      // if middleware + pages - placeholder for middleware handling
      ...hasMiddleware ? [
        {
          src: `^${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/_next/data/",
            escapedBuildId,
            "/(.*).json"
          )}`,
          headers: {
            "x-nextjs-matched-path": "/$1"
          },
          continue: true,
          override: true
        },
        // add a catch-all data route so we don't 404 when getting
        // middleware effects
        {
          src: `^${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/_next/data/",
            escapedBuildId,
            "/(.*).json"
          )}`,
          dest: "__next_data_catchall"
        }
      ] : [],
      { handle: "hit" },
      // Before we handle static files we need to set proper caching headers
      {
        // This ensures we only match known emitted-by-Next.js files and not
        // user-emitted files which may be missing a hash in their filename.
        src: import_node_path3.default.posix.join(
          "/",
          config.basePath || "",
          `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
        ),
        // Next.js assets contain a hash or entropy in their filenames, so they
        // are guaranteed to be unique and cacheable indefinitely.
        headers: {
          "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
        },
        continue: true,
        important: true
      },
      {
        src: config.basePath && config.basePath !== "/" ? import_node_path3.default.posix.join("/", config.basePath, "/?(?:index)?(?:/)?$") : `/(?:index)?(?:/)?$`,
        headers: {
          "x-matched-path": "/"
        },
        continue: true,
        important: true
      },
      {
        src: import_node_path3.default.posix.join(
          "/",
          config.basePath || "",
          `/((?!index$|_error$|500$).*?)(?:/)?$`
        ),
        headers: {
          "x-matched-path": "/$1"
        },
        continue: true,
        important: true
      },
      { handle: "error" },
      // Custom Next.js 404 page
      ...config.i18n ? [
        {
          src: `${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?<nextLocale>${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})(/.*|$)`,
          dest: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/$nextLocale",
            notFoundPath
          ),
          status: 404,
          caseSensitive: true
        },
        {
          src: import_node_path3.default.posix.join("/", config.basePath, ".*"),
          dest: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            `/${config.i18n.defaultLocale}`,
            notFoundPath
          ),
          status: 404
        }
      ] : [
        {
          src: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            // if config.basePath is populated we need to
            // add optional handling for trailing slash so
            // that the config.basePath (basePath) itself matches
            `${config.basePath && config.basePath !== "/" ? "?" : ""}.*`
          ),
          dest: import_node_path3.default.posix.join("/", config.basePath, notFoundPath),
          status: 404
        }
      ],
      // custom 500 page if present
      ...config.i18n && has500Output ? [
        {
          src: `${import_node_path3.default.posix.join(
            "/",
            config.basePath,
            "/"
          )}(?<nextLocale>${config.i18n.locales.map((locale) => escapeStringRegexp(locale)).join("|")})(/.*|$)`,
          dest: import_node_path3.default.posix.join("/", config.basePath, "/$nextLocale/500"),
          status: 500,
          caseSensitive: true
        },
        {
          src: import_node_path3.default.posix.join("/", config.basePath, ".*"),
          dest: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            `/${config.i18n.defaultLocale}/500`
          ),
          status: 500
        }
      ] : [
        {
          src: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            // if config.basePath is populated we need to
            // add optional handling for trailing slash so
            // that the config.basePath (basePath) itself matches
            `${config.basePath && config.basePath !== "/" ? "?" : ""}.*`
          ),
          dest: import_node_path3.default.posix.join(
            "/",
            config.basePath,
            has500Output ? "/500" : "/_error"
          ),
          status: 500
        }
      ]
    ];
    const outputConfigPath = import_node_path3.default.join(vercelOutputDir, "config.json");
    await import_promises3.default.writeFile(outputConfigPath, JSON.stringify(vercelConfig2, null, 2));
  }
};
module.exports = myAdapter;
/*! Bundled license information:

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)
*/
